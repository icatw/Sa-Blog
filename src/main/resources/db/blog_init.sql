-- MySQL dump 10.13  Distrib 8.0.24, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blog_reconstruction
-- ------------------------------------------------------
-- Server version	8.0.24

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE database if NOT EXISTS `blog_init` default character set utf8mb4 collate utf8mb4_0900_ai_ci;
use `blog_init`;
--
-- Table structure for table `tb_article`
--

DROP TABLE IF EXISTS `tb_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_article` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '作者',
  `category_id` int DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容',
  `type` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章类型 1原创 2转载 3翻译',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '原文链接',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否置顶 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态值 1公开 2私密 3评论可见',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  FULLTEXT KEY `ft_search` (`article_content`)
) ENGINE=InnoDB AUTO_INCREMENT=139 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_article`
--

LOCK TABLES `tb_article` WRITE;
/*!40000 ALTER TABLE `tb_article` DISABLE KEYS */;
INSERT INTO `tb_article` VALUES (56,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png','尚医通项目总结','::: hljs-center\n\n## 尚医通项目总结\n\n:::\n# 模块说明\n#### yygh_parent：根目录，管理子模块\n##### common：公共模块父节点\n###### common-util：工具类模块，所有模块都可以依赖于它\n###### rabbit-util：rabbitmq业务封装\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\n##### hospital-manage：医院接口模拟端\n##### model：实体类模块\n##### server-gateway：服务网关\n##### service：api接口服务父节点\n###### service-cmn：字典api接口服务\n###### service-hosp：医院api接口服务\n###### service-order：订单api接口服务\n###### service-oss：文件存储api接口服务\n###### service-sms：短信api接口服务\n###### service-statistics：统计api接口服务\n###### service-task：定时任务服务\n###### service-user：用户api接口服务\n##### service-client：feign服务调用父节点\n###### service-cmn-client：字典api接口\n###### service-hosp-client：医院api接口\n###### service-order-client：订单api接口\n###### service-user-client：用户api接口\n#### sql：项目涉及的sql文件\n\n# 1、项目介绍\n> 尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\n# 2、技术点\n #### 后端:\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\n3. MyBatis-Plus：持久层框架\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\n6. EasyExcel：操作excel表格，进行行读写操作\n7. RabbitMQ：消息中间件（订单相关操作）\n8. HTTPClient: Http协议客户端\n9. Nginx：负载均衡\n10. Mysql：关系型数据库\n11. \n#### 前端：\n1. Vue.js：web 界面的渐进式框架\n2. Node.js： JavaScript 运行环境\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\n4. NPM：包管理器\n5. Babel：转码器\n6. Webpack：打包工具\n7. ECharts：图表展示\n#### 其他:\n1. Lombok\n2. Swagger2：Api接口文档工具\n3. Docker ：容器技术\n4. Git：代码管理工具\n5. 阿里云oss\n6. 阿里云短信服务\n7. 微信登录、支付\n8. 定时任务\n# 3、业务流程\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\n\n# 4、微服务架构\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\n\n# 5、git地址\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\n\n\n',1,'',0,0,1,'2022-02-20 21:29:03','2024-04-17 15:11:00'),(57,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/399f7c02ac3ca36bd18fe67de0fada06.png','花花世界博客总结','# <center> **花花世界博客总结**</center>\n# 一、项目背景\n基于大二下期开学前两周的javaweb实训而开发的博客项目\n# 二、技术架构\n## 项目总体采用主流的springboot+vue前后端分离开发\n### 后端技术：\n1. springboot+mybatis-plus作为快速开发\n2. 采用redis缓存用户信息以及文章信息，加快网站响应速度\n3. 集成spring security作为后台权限控制以及用户认证\n4. lombok 小辣椒用于简化bean开发\n5. 阿里云oss，存储文章图片\n6. jwt+redis，使用token令牌的登陆方式，加快访问认证速度\n7. ThreadLocal 本地线程池保存用户信息\n由于博客比较简洁故使用单体架构减少开发成本\n# 三、开发环境\n- Maven\n- Idea 2021.3\n- Mysql8.0+Navicat\n- VS Code\n- 谷歌浏览器\n# 四、项目截图\n1.前台结构\n![博客前台后端结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f4af97d2cf7284b7f21605ed0b9c23e6.png)\n2.后台管理系统结构\n![后台管理系统结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b57b63451dbd35a63e2b96886d2a4f13.png)\n3.博客首页\n![博客首页.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/deeed83ae27fbb65b10eeca90edbb0f4.png)\n4.后台管理系统\n![后台管理系统页面.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/498bf5709c2289cbb29ceb69c1ccf9e8.png)\n5.数据库结构\n![数据库.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/41631d4e88bf8d0b502a7bbf1c15aee5.png)\n# 五、项目功能\n发表文章、评论、登录注册、音乐播放器\n（音乐播放器从凌晨两点肝到了凌晨四点从肝出来）\n# 六、项目源码\n- gitee地址：\n后端：[后端](https://gitee.com/icatw/blog-parent)\n前端：[前端](https://gitee.com/icatw/blog-app)\n\n- GitHub地址：\n后端：[后端](https://github.com/icatw/blog-parent)\n前端：[前端](https://github.com/icatw/blog-app)\n\n欢迎star！\n# 七、个人总结\n### 1、锻炼了团队协作能力\n### 2、学习了spring security的使用，了解了权限认证流程\n### 3、加强了开发能力，对springboot+mp的使用更为熟练（虽然但是，技术上还是有很大的差距，熟练度有待加强，还是要多做项目多练手）\n### 4、了解了jwt+redis作为缓存用户登陆信息的使用\n### 5、再次感谢花花世界团队~\n# 很高兴你能看到这里 谢谢！\n# 大二学期的java课程就告一段落啦！\n最后 在此立个小flag \n- 早睡早起\n- 早日完成谷粒商城\n- 多敲代码多总结多思考\n\n很喜欢老师说的一句话：“只要在敲代码就是进步”\n\n',1,'',0,0,1,'2022-03-06 00:49:33','2022-03-28 03:11:15'),(58,1,NULL,'','java并发多线程，线程池【ThreadPoolExecutor】的使用','\n# <center>ThreadPoolExecutor线程池\n## 一、线程池\n### 1.为什么要使用线程池\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\n>阿里开发手册有一段描述：\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n简单的说就是把线程统一管理。\n\n#### 线程池优势：\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\n（4）提供更强大的功能，延时定时线程池。\n### 2. 线程池分类\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\n### 3. 选择\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\n### 4. 总结\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\n***\n## 二、ThreadPoolExecutor的7大参数\n### （一）7大参数\n#### 1. 构造方法源码\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n#### 2. 官方注释\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\n### （二）参数详解\n#### 1. **corePoolSize 线程池核心线程大小**\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\n\n#### 2. **maximumPoolSize 线程池最大线程数量**\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\n#### 3. **keepAliveTime 空闲线程存活时间**\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\n#### 4. **unit 空闲线程存活时间单位**\nkeepAliveTime的计量单位\n#### 5. **workQueue 工作队列**\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\n##### (1) ArrayBlockingQueue\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\n##### (2) LinkedBlockingQuene\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\n##### (3) SynchronousQuene\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\n##### (4) PriorityBlockingQueue\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\n#### 6. **threadFactory 线程工厂**\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n7. **handler 拒绝策略**\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\n##### (1) CallerRunsPolicy\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\n##### (2) DiscardPolicy\n该策略下，直接丢弃任务，什么都不做。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\n##### (3) AbortPolicy\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\n\n##### (4) DiscardOldestPolicy\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n![image.png](7)\n***\n### 三、使用（基于springboot）\n#### （一） 配置\n##### 1. 自定义配置类\n``` java\n@Configuration\npublic class MyThreadConfig {\n    @Bean\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\n        return new ThreadPoolExecutor(pool.getCoreSize(),\n                pool.getMaxSize(),\n                pool.getKeepAliveTime(),\n                TimeUnit.SECONDS,\n                new LinkedBlockingDeque<>(100000),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.AbortPolicy());\n    }\n}\n```\n##### 2. 自定义配置文件类\n``` java\n@ConfigurationProperties(prefix = \"gulimall.thread\")\n@Component\n@Data\npublic class ThreadPoolConfigProperties {\n    private Integer coreSize;\n    private Integer maxSize;\n    private Integer keepAliveTime;\n}\n```\n##### 3. 抽取配置文件application.properties\n```\n#线程池配置\ngulimall.thread.core-size=20\ngulimall.thread.max-size=200\ngulimall.thread.keep-alive-time=10\n```\n#### （二） 实践\n##### 1. bean自动注入\n```java\n @Autowired\n    ThreadPoolExecutor executor;\n```\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\n```java\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\n		//异步线程任务1\n                //1、远程查询当前要添加的商品的信息\n                R skuInfo = productFeignService.getSkuInfo(skuId);\n                SkuInfoVo data = skuInfo.getData(\"skuInfo\", new TypeReference<SkuInfoVo>() {\n                });\n                cartItemVo.setCheck(true);\n                cartItemVo.setCount(num);\n                cartItemVo.setImage(data.getSkuDefaultImg());\n                cartItemVo.setTitle(data.getSkuTitle());\n                cartItemVo.setPrice(data.getPrice());\n                cartItemVo.setSkuId(skuId);\n            }, executor);\n```\n***\n```java\n	//3、远程查询sku的组合信息\n	//异步线程任务2\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\n            }, executor);\n```\n***\n``` java\n//异步编排，等待所有异步线程任务结束\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\n```\n***\n### 四、总结\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\n#### 1. 优点\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\n\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\n#### 2. 使用场景\n**适用于高并发多线程场景**\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\n',1,'',0,1,3,'2022-03-28 03:05:52','2022-05-11 13:52:00'),(59,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f43c49ff7cf3506a528ac439a810e374.jpg','java高并发多线程，线程池【ThreadPoolExecutor】的使用','\n# <center>ThreadPoolExecutor线程池\n## 一、线程池\n### 1.为什么要使用线程池\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\n>阿里开发手册有一段描述：\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n简单的说就是把线程统一管理。\n\n#### 线程池优势：\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\n（4）提供更强大的功能，延时定时线程池。\n### 2. 线程池分类\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\n### 3. 选择\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\n### 4. 总结\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\n***\n## 二、ThreadPoolExecutor的7大参数\n### （一）7大参数\n#### 1. 构造方法源码\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n#### 2. 官方注释\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\n### （二）参数详解\n#### 1. **corePoolSize 线程池核心线程大小**\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\n\n#### 2. **maximumPoolSize 线程池最大线程数量**\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\n#### 3. **keepAliveTime 空闲线程存活时间**\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\n#### 4. **unit 空闲线程存活时间单位**\nkeepAliveTime的计量单位\n#### 5. **workQueue 工作队列**\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\n##### (1) ArrayBlockingQueue\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\n##### (2) LinkedBlockingQuene\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\n##### (3) SynchronousQuene\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\n##### (4) PriorityBlockingQueue\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\n#### 6. **threadFactory 线程工厂**\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n7. **handler 拒绝策略**\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\n##### (1) CallerRunsPolicy\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\n##### (2) DiscardPolicy\n该策略下，直接丢弃任务，什么都不做。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\n##### (3) AbortPolicy\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\n\n##### (4) DiscardOldestPolicy\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bef4f09fe171e35c830b4647cabd460.png)\n***\n### 三、使用（基于springboot）\n#### （一） 配置\n##### 1. 自定义配置类\n``` java\n@Configuration\npublic class MyThreadConfig {\n    @Bean\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\n        return new ThreadPoolExecutor(pool.getCoreSize(),\n                pool.getMaxSize(),\n                pool.getKeepAliveTime(),\n                TimeUnit.SECONDS,\n                new LinkedBlockingDeque<>(100000),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.AbortPolicy());\n    }\n}\n```\n##### 2. 自定义配置文件类\n``` java\n@ConfigurationProperties(prefix = \"gulimall.thread\")\n@Component\n@Data\npublic class ThreadPoolConfigProperties {\n    private Integer coreSize;\n    private Integer maxSize;\n    private Integer keepAliveTime;\n}\n```\n##### 3. 抽取配置文件application.properties\n```text\n#线程池配置\ngulimall.thread.core-size=20\ngulimall.thread.max-size=200\ngulimall.thread.keep-alive-time=10\n```\n#### （二） 实践\n##### 1. bean自动注入\n```java\n @Autowired\n    ThreadPoolExecutor executor;\n```\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\n```java\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\n		//异步线程任务1\n                //1、远程查询当前要添加的商品的信息\n                R skuInfo = productFeignService.getSkuInfo(skuId);\n                SkuInfoVo data = skuInfo.getData(\"skuInfo\", new TypeReference<SkuInfoVo>() {\n                });\n                cartItemVo.setCheck(true);\n                cartItemVo.setCount(num);\n                cartItemVo.setImage(data.getSkuDefaultImg());\n                cartItemVo.setTitle(data.getSkuTitle());\n                cartItemVo.setPrice(data.getPrice());\n                cartItemVo.setSkuId(skuId);\n            }, executor);\n```\n***\n```java\n	//3、远程查询sku的组合信息\n	//异步线程任务2\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\n            }, executor);\n```\n***\n``` java\n//异步编排，等待所有异步线程任务结束\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\n```\n***\n### 四、总结\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\n#### 1. 优点\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\n\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\n#### 2. 使用场景\n**适用于高并发多线程场景**\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\n',1,'',0,0,1,'2022-03-28 03:10:47','2022-03-28 03:17:15'),(60,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/fbb61a1551e0dae8fd0d3cfb9936de17.jpg','java基础面试题：equals与==的区别','# <center>equals与==的区别\n## equals\n**equals用来比较的是两个对象的内容是否相等**，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。\n## ==\n**== 比较的是变量(栈)内存中存放的对象的(堆)内存地址**，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。\n1. 比较的是操作符两端的操作数是否是同一个对象。\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\n\n### 例：\n```java\npublic class equalsTest {\n    public static void main(String[] args) {\n        String s1 = \"abc\";\n        String s2 = s1;\n        String s5 = \"abc\";\n        String s3 = new String(\"abc\");\n        String s4 = new String(\"abc\");\n        System.out.println(\"==comparison:\"+(s1==s5));\n        System.out.println(\"==comparison:\"+(s1==s2));\n        System.out.println(\"Using equals method :\"+s1.equals(s2));\n        System.out.println(\"==comparison:\"+s3==s4);\n        System.out.println(\"Using equals method :\"+s3.equals(s4));\n    }\n}\n```\n### 结果：\n```java\n==comparison:true\n==comparison:true\nUsing equals method :true\nfalse\nUsing equals method :true\n```\n## 总结\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\n\n',1,'',0,0,1,'2022-03-31 02:13:43',NULL),(61,1,NULL,'','java基础面试题（一）','## 1、 Java语言有哪些特点\n1. 简单易学、有丰富的类库\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\n3. 与平台无关性（JVM是Java跨平台使用的根本）\n4. 可靠安全\n5. 支持多线程\n## 2、面向对象和面向过程的区别\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\n\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\n## 3 、八种基本数据类型的大小，以及他们的封装类\n|基本类型 |大小（字节）|默认值|封装类|\n|-|-|-|-|\n|byte|1|(byte)0|Byte|\n|short|2|(short)0|Short|\n|int|4|0|Integer|\n|long|8|0L|Long|\n|float|4|0.0f|Float|\n|double|8|0.0d|Double|\n|boolean|-|false|Boolean|\n|char|2|\\u0000(null)|Char|\n注：\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\n\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\n\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\n## 4、标识符的命名规则。\n<b>标识符的含义：</b>\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\n\n<b>命名规则：（硬性要求）</b>\n- 标识符可以包含英文字母，0-9的数字，$以及_\n- 标识符不能以数字开头\n- 标识符不是关键字\n\n\n<b>命名规范：（非硬性要求）</b>\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\n- 方法名规范：同变量名。\n## 5、instanceof 关键字的作用\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\n``` java\nboolean result = obj instanceof Class\n```\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\n\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\n``` java\nint i = 0;\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\nSystem.out.println(i instanceof Object);//编译不通过\n```\n``` java\nInteger integer = new Integer(1);\nSystem.out.println(integer instanceof Integer);//true\n\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\nfalse。\nSystem.out.println(null instanceof Object);\n```\n## 6、Java自动装箱与拆箱\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\nvalueOf(int) 方法</b>\n\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\n``` java\nInteger i = new Integer(10);\n```\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\n样就可以了：\n``` java\nInteger i = 10;\n```\n<b><i>面试题1： 以下代码会输出什么？</i></b>\n``` java\npublic class Main {\n	public static void main(String[] args) {\n		Integer i1 = 100;\n		Integer i2 = 100;\n		Integer i3 = 200;\n		Integer i4 = 200;\n		System.out.println(i1==i2);\n		System.out.println(i3==i4);\n	}\n}\n\n```\n运行结果：\n``` java\ntrue\nfalse\n```\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\n``` java\npublic static Integer valueOf(int i) {\n	if(i >= -128 && i <= IntegerCache.high)\n		return IntegerCache.cache[i + 128];\n	else\n		return new Integer(i);\n}\n\n```\n\n其中IntegerCache类的实现为：\n``` java\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\n\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\n\n***面试题2：以下代码输出什么***\n``` java\npublic class Main {\n	public static void main(String[] args) {\n		Double i1 = 100.0;\n		Double i2 = 100.0;\n		Double i3 = 200.0;\n		Double i4 = 200.0;\n		System.out.println(i1==i2);\n		System.out.println(i3==i4);\n	}\n}\n\n```\n\n运行结果：\n``` java\nfalse\nfalse\n```\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\n## 7、 重载和重写的区别\n<b>重写(Override)</b>\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\n``` java\npublic class Father {\npublic static void main(String[] args) {\n	// TODO Auto-generated method stub\n	Son s = new Son();\n	s.sayHello();\n}\npublic void sayHello() {\n	System.out.println(\"Hello\");\n	}\n}\nclass Son extends Father{\n	@Override\n	public void sayHello() {\n		// TODO Auto-generated method stub\n		System.out.println(\"hello by \");\n	}\n}\n```\n重写 总结：\n1.发生在父类与子类之间\n2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\n3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\n4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\n重载（Overload）\n在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）\n则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来\n判断重载。\n重载 总结：\n1.重载Overload是一个类中多态性的一种表现\n2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\n3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\n8、 equals与==的区别\n== ：\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是\n指相同一个对象。比较的是真正意义上的指针操作。\n1、比较的是操作符两端的操作数是否是同一个对象。\n2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\n3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\nequals：\npublic class Father {\npublic static void main(String[] args) {\n// TODO Auto-generated method stub\nFather s = new Father();\ns.sayHello();\ns.sayHello(\"wintershii\");\n}\npublic void sayHello() {\nSystem.out.println(\"Hello\");\n}\npublic void sayHello(String name) {\nSystem.out.println(\"Hello\" + \" \" + name);\n}\n}\nequals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以\n适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\nequals方法返回的却是==的判断。\n总结：\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的\nequals object可能为null 则空指针\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排\n查老代码使用“==”，替换成equals\n9、 Hashcode的作用\njava的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中\n插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法\n就会比较满。\n于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对\n象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就\n可以确定该对象应该存储的那个区域。\n hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合\n要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。\n如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上\n已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地\n址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\n10、String、String StringBuffer 和 StringBuilder 的区别是什\n么?\nString是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符\n数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的\nString对象。\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接\n+后面的字符。\nStringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder\n抽象类中我们可以看到\nprivate final char value[];\n/**\n* The value is used for character storage.\n*/\nchar[] value;\n他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是\n线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。',1,'',0,1,3,'2022-04-14 21:51:54','2022-05-11 13:52:00'),(62,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b6ca16c4768b3e963997131f64e49b63.jpg','java基础面试题（一）','## 1、 Java语言有哪些特点\n1. 简单易学、有丰富的类库\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\n3. 与平台无关性（JVM是Java跨平台使用的根本）\n4. 可靠安全\n5. 支持多线程\n## 2、面向对象和面向过程的区别\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\n\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\n## 3 、八种基本数据类型的大小，以及他们的封装类\n|基本类型 |大小（字节）|默认值|封装类|\n|-|-|-|-|\n|byte|1|(byte)0|Byte|\n|short|2|(short)0|Short|\n|int|4|0|Integer|\n|long|8|0L|Long|\n|float|4|0.0f|Float|\n|double|8|0.0d|Double|\n|boolean|-|false|Boolean|\n|char|2|\\u0000(null)|Char|\n注：\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\n\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\n\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\n## 4、标识符的命名规则。\n<b>标识符的含义：</b>\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\n\n<b>命名规则：（硬性要求）</b>\n- 标识符可以包含英文字母，0-9的数字，$以及_\n- 标识符不能以数字开头\n- 标识符不是关键字\n\n\n<b>命名规范：（非硬性要求）</b>\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\n- 方法名规范：同变量名。\n## 5、instanceof 关键字的作用\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\n``` java\nboolean result = obj instanceof Class\n```\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\n\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\n``` java\nint i = 0;\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\nSystem.out.println(i instanceof Object);//编译不通过\n```\n``` java\nInteger integer = new Integer(1);\nSystem.out.println(integer instanceof Integer);//true\n\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\nfalse。\nSystem.out.println(null instanceof Object);\n```\n## 6、Java自动装箱与拆箱\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\nvalueOf(int) 方法</b>\n\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\n``` java\nInteger i = new Integer(10);\n```\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\n样就可以了：\n``` java\nInteger i = 10;\n```\n<b><i>面试题1： 以下代码会输出什么？</i></b>\n``` java\npublic class Main {\n	public static void main(String[] args) {\n		Integer i1 = 100;\n		Integer i2 = 100;\n		Integer i3 = 200;\n		Integer i4 = 200;\n		System.out.println(i1==i2);\n		System.out.println(i3==i4);\n	}\n}\n\n```\n运行结果：\n``` java\ntrue\nfalse\n```\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\n``` java\npublic static Integer valueOf(int i) {\n	if(i >= -128 && i <= IntegerCache.high)\n		return IntegerCache.cache[i + 128];\n	else\n		return new Integer(i);\n}\n\n```\n\n其中IntegerCache类的实现为：\n``` java\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\n\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\n\n***面试题2：以下代码输出什么***\n``` java\npublic class Main {\n	public static void main(String[] args) {\n		Double i1 = 100.0;\n		Double i2 = 100.0;\n		Double i3 = 200.0;\n		Double i4 = 200.0;\n		System.out.println(i1==i2);\n		System.out.println(i3==i4);\n	}\n}\n\n```\n\n运行结果：\n``` java\nfalse\nfalse\n```\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\n## 7、 重载和重写的区别\n<b>重写(Override)</b>\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\n``` java\npublic class Father {\npublic static void main(String[] args) {\n	// TODO Auto-generated method stub\n	Son s = new Son();\n	s.sayHello();\n}\npublic void sayHello() {\n	System.out.println(\"Hello\");\n	}\n}\nclass Son extends Father{\n	@Override\n	public void sayHello() {\n		// TODO Auto-generated method stub\n		System.out.println(\"hello by \");\n	}\n}\n```\n<b>重写总结：</b>\n1. 发生在父类与子类之间\n2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\n3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\n4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\n\n\n<b>重载（Overload）</b>\n在一个类中，同名的方法如果有不同的参数列表<b>（参数类型不同、参数个数不同甚至是参数顺序不同）</b>则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<b>不能通过返回类型是否相同来判断重载。</b>\n\n``` java\npublic class Father {\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Father s = new Father();\n		s.sayHello();\n		s.sayHello(\"wintershii\");\n	}\n	public void sayHello() {\n		System.out.println(\"Hello\");\n	}\n	public void sayHello(String name) {\n		System.out.println(\"Hello\" + \" \" + name);\n	}\n}\n```\n<b>重载总结：</b>\n1. 重载Overload是一个类中多态性的一种表现\n2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\n3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\n## 8、 equals与==的区别\n<b>== ：</b>\n\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，**用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。**\n1. 比较的是操作符两端的操作数是否是同一个对象。\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\n\n<b>equals：</b>\n\n&emsp;&emsp;equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\nequals方法返回的却是==的判断。\n\n<b>总结：</b>\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针。\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\n## 9、 Hashcode的作用\n&emsp;&emsp;**java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复**。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。\n\n&emsp;&emsp;于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。\n\n&emsp;&emsp;hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\n## 10、String、String StringBuffer 和 StringBuilder 的区别是什么?\n\n**String是只读字符串，它并不是基本数据类型，而是一个对象**。从底层源码来看是一个final类型的字符\n数组，所引用的字符串不能被改变，**一经定义，无法再增删改。每次对String的操作都会生成新的String对象**。\n``` java\nprivate final char value[];\n```\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。\n\n**StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类**，从AbstractStringBuilder抽象类中我们可以看到\n``` java\n/**\n* The value is used for character storage.\n*/\nchar[] value;\n```\n他们的底层都是可变的字符数组，**所以在进行频繁的字符串操作时，建议使用StringBuffer和\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的**。',1,'',0,0,1,'2022-04-14 22:13:04','2022-05-23 22:56:28'),(63,1,NULL,'','java基础面试题（二）','## 11、ArrayList和linkedList的区别\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\n<p>例如：</p>\n\n``` java\nint[] a = new int[4];//推介使用int[] 这种方式初始化\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\n```\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\n\n**List有两个重要的实现类：ArrayList和LinkedList**\n\n**ArrayList: 可以看作是能够自动增长容量的数组**\n\n**ArrayList的toArray方法返回一个数组**\n\n**ArrayList的asList方法返回一个列表**\n**ArrayList底层的实现是Array, 数组扩容实现**\n\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\n\n## 12、 HashMap和HashTable的区别\n1. **两者父类不同**\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\n\nHashMap源码：\n``` java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n...\n}\n```\nHashTable源码：\n``` java\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable {\n\n...\n}\n```\n2. **对外提供的接口不同**\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\n\n3. **对null的支持不同**\n**Hashtable：key和value都不能为null**。\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\n\n4. **安全性不同**\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\n\n5. **初始容量大小和每次扩充容量大小不同**\n6. **计算hash值的方法不同**\n\n## 13、Collection包结构，与Collections的区别\n\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\n\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\n\n## 14、Java的四种引用，强弱软虚\n- 强引用\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\n式：\n``` java\nString str = new String(\"str\");\n```\n\n- 软引用\n软引用在内存不足时，会被回收，使用方式：\n``` java\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\n// 这里的软引用指的是指向new String(\"str\")的引用，也就是SoftReference类中T\nSoftReference<String> wrf = new SoftReference<String>(new String(\"str\"));\n```\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\n- 弱引用\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\n``` java\nWeakReference<String> wrf = new WeakReference<String>(str);\n```\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\n- 虚引用\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\n``` java\nPhantomReference<String> prf = new PhantomReference<String>(new\nString(\"str\"), new ReferenceQueue<>());\n```\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\n这类动作，但是这个方式即不安全又低效\n\n\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\n( SoftReference 等)**。\n\n## 15、泛型常用特点\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\n\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\n``` java\nList<Integer> iniData = new ArrayList<>()\n```\n**使用泛型的好处**：\n\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\n\n## 16、Java创建对象有几种方式？\nJava中提供了以下四种创建对象的方式：\n- new创建新对象\n- 通过反射机制\n- 采用clone机制\n- 通过序列化机制\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\n\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\n下几种方式来处理:\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\n\n## 18、深拷贝和浅拷贝的区别是什么？\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\n\n## 19、final有哪些用法？\n- 被final修饰的类无法被继承\n- 被final修饰的方法无法被重写\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\n- 被final修饰的常量，在编译阶段会存入常量池中\n\n\n除此之外，编译器对final域要遵守的两个重排序规则更好：\n\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\n',1,'',0,1,3,'2022-04-15 21:37:47','2022-05-11 13:52:00'),(64,1,NULL,'','java基础面试题（二）','## 11、ArrayList和linkedList的区别\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\n<p>例如：</p>\n\n``` java\nint[] a = new int[4];//推介使用int[] 这种方式初始化\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\n```\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\n\n**List有两个重要的实现类：ArrayList和LinkedList**\n\n**ArrayList: 可以看作是能够自动增长容量的数组**\n\n**ArrayList的toArray方法返回一个数组**\n\n**ArrayList的asList方法返回一个列表**\n**ArrayList底层的实现是Array, 数组扩容实现**\n\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\n\n## 12、 HashMap和HashTable的区别\n1. **两者父类不同**\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\n\nHashMap源码：\n``` java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n...\n}\n```\nHashTable源码：\n``` java\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable {\n\n...\n}\n```\n2. **对外提供的接口不同**\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\n\n3. **对null的支持不同**\n**Hashtable：key和value都不能为null**。\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\n\n4. **安全性不同**\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\n\n5. **初始容量大小和每次扩充容量大小不同**\n6. **计算hash值的方法不同**\n\n## 13、Collection包结构，与Collections的区别\n\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\n\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\n\n## 14、Java的四种引用，强弱软虚\n- 强引用\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\n式：\n``` java\nString str = new String(\"str\");\n```\n\n- 软引用\n软引用在内存不足时，会被回收，使用方式：\n``` java\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\n// 这里的软引用指的是指向new String(\"str\")的引用，也就是SoftReference类中T\nSoftReference<String> wrf = new SoftReference<String>(new String(\"str\"));\n```\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\n- 弱引用\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\n``` java\nWeakReference<String> wrf = new WeakReference<String>(str);\n```\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\n- 虚引用\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\n``` java\nPhantomReference<String> prf = new PhantomReference<String>(new\nString(\"str\"), new ReferenceQueue<>());\n```\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\n这类动作，但是这个方式即不安全又低效\n\n\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\n( SoftReference 等)**。\n\n## 15、泛型常用特点\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\n\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\n``` java\nList<Integer> iniData = new ArrayList<>()\n```\n**使用泛型的好处**：\n\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\n\n## 16、Java创建对象有几种方式？\nJava中提供了以下四种创建对象的方式：\n- new创建新对象\n- 通过反射机制\n- 采用clone机制\n- 通过序列化机制\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\n\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\n下几种方式来处理:\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\n\n## 18、深拷贝和浅拷贝的区别是什么？\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\n\n## 19、final有哪些用法？\n- 被final修饰的类无法被继承\n- 被final修饰的方法无法被重写\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\n- 被final修饰的常量，在编译阶段会存入常量池中\n\n\n除此之外，编译器对final域要遵守的两个重排序规则更好：\n\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\n## 20、static都有哪些用法?\nstatic关键字有两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.\n\n除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:\n``` java\npublic class PreCache{\n	static{\n		//执行相关操作，静态初始化\n	}\n}\n```\n此外static也多用于修饰内部类,此时称之为静态内部类.\n\n最后一种用法就是静态导包,即 ```import static .import static```是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:\n``` java\nimport static java.lang.Math.*;\npublic class Test{\n	public static void main(String[] args){\n	//System.out.println(Math.sin(20));传统做法\n	System.out.println(sin(20));//静态导包作法\n	}\n}\n\n```\n\n',1,'',0,1,3,'2022-04-15 21:41:29','2022-05-11 13:52:00'),(65,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f8f00bcc0d1424975a35eb231d9f9cde.jpg','java基础面试题（二）','## 11、ArrayList和linkedList的区别\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\n<p>例如：</p>\n\n``` java\nint[] a = new int[4];//推介使用int[] 这种方式初始化\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\n```\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\n\n**List有两个重要的实现类：ArrayList和LinkedList**\n\n**ArrayList: 可以看作是能够自动增长容量的数组**\n\n**ArrayList的toArray方法返回一个数组**\n\n**ArrayList的asList方法返回一个列表**\n**ArrayList底层的实现是Array, 数组扩容实现**\n\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\n\n## 12、 HashMap和HashTable的区别\n1. **两者父类不同**\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\n\nHashMap源码：\n``` java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n...\n}\n```\nHashTable源码：\n``` java\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable {\n\n...\n}\n```\n2. **对外提供的接口不同**\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\n\n3. **对null的支持不同**\n**Hashtable：key和value都不能为null**。\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\n\n4. **安全性不同**\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\n\n5. **初始容量大小和每次扩充容量大小不同**\n6. **计算hash值的方法不同**\n\n## 13、Collection包结构，与Collections的区别\n\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\n\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\n\n## 14、Java的四种引用，强弱软虚\n- 强引用\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\n式：\n``` java\nString str = new String(\"str\");\n```\n\n- 软引用\n软引用在内存不足时，会被回收，使用方式：\n``` java\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\n// 这里的软引用指的是指向new String(\"str\")的引用，也就是SoftReference类中T\nSoftReference<String> wrf = new SoftReference<String>(new String(\"str\"));\n```\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\n- 弱引用\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\n``` java\nWeakReference<String> wrf = new WeakReference<String>(str);\n```\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\n- 虚引用\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\n``` java\nPhantomReference<String> prf = new PhantomReference<String>(new\nString(\"str\"), new ReferenceQueue<>());\n```\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\n这类动作，但是这个方式即不安全又低效\n\n\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\n( SoftReference 等)**。\n\n## 15、泛型常用特点\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\n\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\n``` java\nList<Integer> iniData = new ArrayList<>()\n```\n**使用泛型的好处**：\n\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\n\n## 16、Java创建对象有几种方式？\nJava中提供了以下四种创建对象的方式：\n- new创建新对象\n- 通过反射机制\n- 采用clone机制\n- 通过序列化机制\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\n\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\n下几种方式来处理:\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\n\n## 18、深拷贝和浅拷贝的区别是什么？\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\n\n## 19、final有哪些用法？\n- 被final修饰的类无法被继承\n- 被final修饰的方法无法被重写\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\n- 被final修饰的常量，在编译阶段会存入常量池中\n\n\n除此之外，编译器对final域要遵守的两个重排序规则更好：\n\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\n## 20、static都有哪些用法?\nstatic关键字有两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.\n\n除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:\n``` java\npublic class PreCache{\n	static{\n		//执行相关操作，静态初始化\n	}\n}\n```\n此外static也多用于修饰内部类,此时称之为静态内部类.\n\n最后一种用法就是静态导包,即 ```import static .import static```是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:\n``` java\nimport static java.lang.Math.*;\npublic class Test{\n	public static void main(String[] args){\n	//System.out.println(Math.sin(20));传统做法\n	System.out.println(sin(20));//静态导包作法\n	}\n}\n\n```\n\n',1,'',0,0,1,'2022-04-15 21:42:19',NULL),(66,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2904b329e08607f13e50d22582c9716d.jpg','java基础面试题（三）','## 21、3*0.1==0.3的返回值是什么\nfalse，因为有些浮点数不能完全精确的表示出来（精度问题）\n\n## 22、a=a+b与a+=b有什么区别吗？\n<b>```+=```操作符会进行隐式自动类型转换</b>，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，<b>而a=a+b则不会自动进行类型转换</b>，如：\n``` java\nbyte a = 127;\nbyte b = 127;\nb = a + b; // 报编译错误:cannot convert from int to byte\nb += a;\n```\n以下代码是否有错，有的话怎么改？\n``` java\nshort s1=1;\ns1 = s1 + 1; \n```\n有错误，因为1为int型，short类型在进行运算时会自动提升为int类型,也就是说 ```s1+1``` 的运算结果是int类型,而s1是short类型,此时编译器会报错.\n\n正确写法：\n``` java\nshort s1 = 1;\ns1 += 1;\n```\n<b>+=操作符会对右边的表达式结果强转匹配左边的数据类型</b>\n\n## 23、try catch finally，try里有return，finally还执行么？\n**执行，并且finally的执行早于try里面的return**\n\n**结论**：\n1. 不管有没有出现异常，finally块中的代码都会执行\n2. 当try和catch中有return中，finally仍然会执行\n3. finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保\n存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的\n4. finally中最好不要包含return，否则程序会提前退出，返回值为finally块中的return值，而不是try或catch中保存的返回值\n\n## 24、Excption与Error包结构\nJava可抛出(Throwable)的结构分为三种类型：**被检查的异常(CheckedException)，运行时异常\n(RuntimeException)，错误(Error)**。\n1. 运行时异常\n**定义:RuntimeException及其子类都被称为运行时异常。**\n<p>特点:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既\"没有通过throws声明抛出它\"，也\"没有用try-catch语句捕获它\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常（java.util包下面的所有的集合类都是快速失败的，“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Fail-safe，java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。\nConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。）等，都属于运行时异常。</p>\n\n常见的五种运行时异常：\nClassCastException（类转换异常）\nIndexOutOfBoundsException（数组越界）\nNullPointerException（空指针异常）\nArrayStoreException（数据存储异常，操作数组是类型不一致）\nBufferOverflowException\n\n2. 被检查异常\n**定义:Exception类本身，以及Exception的子类中除了\"运行时异常\"之外的其它子类都属于被检查异常**\n\n特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的\n\n如：\nIOException\nFileNotFoundException\nSQLException\n被检查的异常适用于那些不是因程序引起的错误情况，\n比如：\n读取文件时文件不存在引发的FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException 。\n\n3. 错误\n**定义 : Error类及其子类**。\n\n特点 : 和运行时异常一样，编译器也不会对错误进行检查。\n当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。\nOutOfMemoryError、ThreadDeath。\nJava虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等\n\n## 25、OOM你遇到过哪些情况，SOF你遇到过哪些情况\n**OOM**：\n1. OutOfMemoryError异常\n\n\n除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。\n\nJava Heap 溢出：\n\n一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。\n\njava堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。\n\n出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。\n\n如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。\n\n如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。\n\n2. 虚拟机栈和本地方法栈溢出\n\n\n如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。\n\n如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常\n\n这里需要注意当栈的大小越大可分配的线程数就越少。\n\n3. 运行时常量池溢出\n\n异常信息：java.lang.OutOfMemoryError:PermGenspace\n\n如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。\n\n4. 方法区溢出\n\n方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。\n\n异常信息：java.lang.OutOfMemoryError:PermGenspace\n方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。\n\n**SOF（堆栈溢出StackOverflow）**：\n\n- StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。\n因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。\n**栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大**\n\n## 26、简述线程、程序、进程的基本概念。以及他们之间关系是什么?\n\n**线程与进程相似，但线程是一个比进程更小的执行单位**。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，**线程也被称为轻量级进程**。\n\n**程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码**。\n\n**进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的**。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n## 27、线程有哪些基本状态？\n Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c215fe0eb4996fc14aefd73c412bb6e9.png)\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/17118c32c11f932819aa138f5e7bb71c.png)\n> 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava：Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ae96eb1fbd464707f2983b29338b8d63.png)\n\n当线程执行 wait() 方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis） 方法或 wait（long millis） 方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable的 run() 方法之后将会进入到 TERMINATED（终止） 状态。\n## 28、Java 序列化中如果有些字段不想进行序列化，怎么办？\n对于不想进行序列化的变量，使用transient 关键字修饰。\n\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。\n## 29、Java 中 IO 流\nJava中IO流分为几种？\n- 按照流的流向分，可以分为输入流和输出流；\n- 按照操作单元划分，可以划分为字节流和字符流；\n- 按照流的角色划分为节点流和处理流。\n## 30、Java反射的作用与原理\n1. **定义**\n**反射机制是在运行时，对于任意一个类，都能够知到这个类的所有属性和方法**；对于任意个对象，都能够调用他的意任意一个方法，在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。\n> 这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。\n\n2. **哪里会用到反射机制**？\n**jdbc就是典型的反射**\n``` java\nClass.forName(\'com.mysql.cj.jdbc.Driver.class\');//加载MySQL的驱动类\n```\n这就是反射。如hibernate，struts等框架使用反射实现的。\n\n3. **反射的实现方式**\n第一步：获取Class对象，有4中方法：\n1）Class.forName(“类的路径”)；\n2）类名.class\n3）对象名.getClass()\n4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象\n\n4. **实现Java反射的类**：\n1）Class：表示正在运行的Java应用程序中的类和接口\n注意： 所有获取对象的信息都需要Class类来实现。\n2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。\n3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限\n4）Method：提供类或接口中某个方法的信息\n5. **反射机制的优缺点**：\n**优点**：\n1）能够运行时动态获取类的实例，提高灵活性；\n2）与动态编译结合\n**缺点**：\n1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。\n解决方案：\n1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；\n2、多次创建一个类的实例时，有缓存会快很多\n3、ReflectASM工具类，通过字节码生成的方式加快反射速度\n2）相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）\n## 31、说说List,Set,Map三者的区别？\n- **List(对付顺序的好帮手)**： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\n- **Set(注重独一无二的性质)**: **不允许重复的集合**。不会有多个元素引用相同的对象。\n- **Map(用Key来搜索的专家)**: **使用键值对存储**。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\n\n\n\n\n',1,'',0,0,1,'2022-04-17 00:32:43',NULL),(67,1,195,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8867125f0009f89c4db3a889365e0f5d.jpg','二分查找法入门','## 二分查找法\n### 前提:\n只能用于升序数组\n\n### 定义：\n在升序数组nums中寻找目标值target，对于特定下标i，比较nums[i]和target的大小：\n- 如果nums[i]=targer，则下标i为要寻找的下标；\n- 如果nums[i]>targer，则target只能是在下标i的左侧；\n- 如果nums[i]<targer，则target在下标i的右侧。\n\n二分查找的做法为，定义查找的范围```[left,right]```，初始查找范围是整个数组，每次取查找范围的中点```mid``` ``` (mid的值为(left+right)/2) ``` ，比较nums[mid]和target的大小，如果相等则mid为要寻找的下标，如果target>nums[mid]，则使right=mid-1，否则，left=mid+1\n\n### 例子：\n**LeetCode 704.二分查找**：\n> 给定一个 ```  n``` 个元素有序的（升序）整型数组 ```nums``` 和一个目标值 ```target```  ，写一个函数搜索 ```nums``` 中的 ```target```，如果目标值存在返回下标，否则返回 ```-1```。\n\n示例1：\n``` text\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n```\n\n示例2：\n``` text\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n提示1：\n``` text\n1.你可以假设 nums 中的所有元素是不重复的。\n2.n 将在 [1, 10000]之间。\n3.nums 的每个元素都将在 [-9999, 9999]之间。\n```\n**Java题解**：\n``` java\nclass Solution {\n    public int search(int[] nums, int target) {\n    //初始化left为第一个，0\n    int left=0;\n    //初始化right为最后一个，nums.length-1\n    int right=nums.length-1;\n    while(left<=right){\n	//定义中间值下标\n        int mid=(left+right)/2;\n        if(nums[mid]==target){\n            return mid;\n        }\n        else if(nums[mid]>target){\n            right=mid-1;\n        } else {\n            left=mid+1;\n        }\n    }\n    return -1;\n   }\n}\n```\n',1,'',0,0,1,'2022-04-17 02:44:29',NULL),(68,1,NULL,'','数据结构学习笔记：栈和队列','## 栈\n### 理论基础：\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\n\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\n### 栈的实现\n这里基于**Java链表**实现\n\n#### 栈的API设计\n|类名|Stack|\n|-|-|\n|构造方法|public Stack()|\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\n|结点内部类|private class Node|\n\n#### 代码实现\n``` java\n/**\n * 堆栈\n *\n * @author icatw\n * @date 2022/4/17\n * @email 762188827@qq.com\n * @apiNote\n */\npublic class Stack<T> implements Iterable<T> {\n    private Node head;\n    private int N;\n\n    public Stack() {\n        this.head = new Node(null, null);\n        this.N = 0;\n    }\n\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    public int size() {\n        return N;\n    }\n\n    /**\n     * 弹出栈顶元素\n     *\n     * @return {@link T}\n     */\n    public T pop() {\n        //找到首结点指向的第一个结点\n        Node oldFirst = this.head.next;\n        //让首结点指向原来的第一个结点的下一个结点\n        if (oldFirst == null) {\n            return null;\n        }\n        head.next = oldFirst.next;\n        //元素个数-1\n        N--;\n        return oldFirst.item;\n    }\n\n    /**\n     * 向栈中压入元素t\n     *\n     * @param t t\n     */\n    public void push(T t) {\n        //找到首结点指向的第一个结点\n        Node oldFirst = head.next;\n        //    创建新结点\n        Node newNode = new Node(t, null);\n        //    让首结点指向新结点\n        head.next = newNode;\n        //    让新结点指向原来的第一个结点\n        newNode.next = oldFirst;\n        //    元素个数+1\n        N++;\n    }\n\n\n    private class Node {\n        public T item;\n        public Node next;\n\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new IterableI();\n    }\n\n    private class IterableI implements Iterator<T> {\n        private Node n;\n\n        public IterableI() {\n            this.n = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return n.next != null;\n        }\n\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n```\n#### 案例\n##### **LeetCode 20.有效的括号**\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n1.左括号必须用相同类型的右括号闭合。\n2.左括号必须以正确的顺序闭合。\n\n**Java代码实现**\n``` java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> left=  new Stack<>();\n        for(char c : s.toCharArray()){\n            //左括号，则入栈\n            if (c == \'(\' || c == \'{\' || c == \'[\')\n                left.push(c);\n            else //右括号\n                if (!left.isEmpty() && leftOf(c) == left.peek())\n                    left.pop();\n                else\n                    // 和最近的左括号不匹配\n                    return false;\n        }\n        //是否所有的左括号都被匹配了\n        return left.isEmpty();\n    }\n\n    char leftOf(char c) {\n        if (c == \'}\') return \'{\';\n        if (c == \')\') return \'(\';\n        return \'[\';\n    }\n}\n```\n解题思路\n> 1.创建一个栈用来存储左括号\n2.从左往右遍历字符串，拿到每一个字符\n3.判断该字符是不是左括号，如果是，放入栈中存储\n4.判断该字符是不是右括号，如果不是，继续下一次循环\n5.如果该字符是右括号，则从栈中弹出一个元素t；\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\n``` text\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\nif (!left.isEmpty() && leftOf(c) == left.peek())\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\n否则，此右括号和最近的左括号不匹配，直接返回false\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\n栈为空，则匹配成功，否则返回失败\n```\n\n##### 逆波兰表达式求值问题\n1. 什么是逆波兰表达式（后缀表达式）？\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\n2. 中缀表达式\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\n\n**对应关系**：\n|中缀表达式|逆波兰表达式|\n|--|--|\n|a+b|ab+|\n|a+(b-c)|abc-+|\n|a+(b-c)*d|abc-d*+|\n|a*(b-c)+d|abc-*d+|\n\n## 队列\n### 理论基础：\n**队列（queue）**，是一种先进先出（FIFO，First In First Out）的数据结构，\n\n',1,'',0,1,3,'2022-04-18 01:35:03','2022-05-11 13:52:00'),(69,1,NULL,'','数据结构学习笔记：栈和队列','# 栈\n## 理论基础：\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\n\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\n### 栈的实现\n这里基于**Java链表**实现\n\n### 栈的API设计\n|类名|Stack|\n|-|-|\n|构造方法|public Stack()|\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\n|结点内部类|private class Node|\n\n### 代码实现\n``` java\n/**\n * 堆栈\n *\n * @author icatw\n * @date 2022/4/17\n * @email 762188827@qq.com\n * @apiNote\n */\npublic class Stack<T> implements Iterable<T> {\n    private Node head;\n    private int N;\n\n    public Stack() {\n        this.head = new Node(null, null);\n        this.N = 0;\n    }\n\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    public int size() {\n        return N;\n    }\n\n    /**\n     * 弹出栈顶元素\n     *\n     * @return {@link T}\n     */\n    public T pop() {\n        //找到首结点指向的第一个结点\n        Node oldFirst = this.head.next;\n        //让首结点指向原来的第一个结点的下一个结点\n        if (oldFirst == null) {\n            return null;\n        }\n        head.next = oldFirst.next;\n        //元素个数-1\n        N--;\n        return oldFirst.item;\n    }\n\n    /**\n     * 向栈中压入元素t\n     *\n     * @param t t\n     */\n    public void push(T t) {\n        //找到首结点指向的第一个结点\n        Node oldFirst = head.next;\n        //    创建新结点\n        Node newNode = new Node(t, null);\n        //    让首结点指向新结点\n        head.next = newNode;\n        //    让新结点指向原来的第一个结点\n        newNode.next = oldFirst;\n        //    元素个数+1\n        N++;\n    }\n\n\n    private class Node {\n        public T item;\n        public Node next;\n\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new IterableI();\n    }\n\n    private class IterableI implements Iterator<T> {\n        private Node n;\n\n        public IterableI() {\n            this.n = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return n.next != null;\n        }\n\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n```\n### 案例\n#### **LeetCode 20.有效的括号**\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n1.左括号必须用相同类型的右括号闭合。\n2.左括号必须以正确的顺序闭合。\n\n**Java代码实现**\n``` java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> left=  new Stack<>();\n        for(char c : s.toCharArray()){\n            //左括号，则入栈\n            if (c == \'(\' || c == \'{\' || c == \'[\')\n                left.push(c);\n            else //右括号\n                if (!left.isEmpty() && leftOf(c) == left.peek())\n                    left.pop();\n                else\n                    // 和最近的左括号不匹配\n                    return false;\n        }\n        //是否所有的左括号都被匹配了\n        return left.isEmpty();\n    }\n\n    char leftOf(char c) {\n        if (c == \'}\') return \'{\';\n        if (c == \')\') return \'(\';\n        return \'[\';\n    }\n}\n```\n解题思路\n> 1.创建一个栈用来存储左括号\n2.从左往右遍历字符串，拿到每一个字符\n3.判断该字符是不是左括号，如果是，放入栈中存储\n4.判断该字符是不是右括号，如果不是，继续下一次循环\n5.如果该字符是右括号，则从栈中弹出一个元素t；\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\n``` text\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\nif (!left.isEmpty() && leftOf(c) == left.peek())\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\n否则，此右括号和最近的左括号不匹配，直接返回false\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\n栈为空，则匹配成功，否则返回失败\n```\n\n#### 逆波兰表达式求值问题\n1. 什么是逆波兰表达式（后缀表达式）？\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\n2. 中缀表达式\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\n\n**对应关系**：\n|中缀表达式|逆波兰表达式|\n|:--:|:--:|\n|a+b|ab+|\n|a+(b-c)|abc-+|\n|a+(b-c)*d|abc-d*+|\n|a*(b-c)+d|abc-*d+|\n**需求**：\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\n分析：\n> 1.创建一个栈对象oprands存储操作数\n2.从左往右遍历逆波兰表达式，得到每一个字符串\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n5.使用该运算符计算o1和o2，得到结果result\n6.把该结果压入oprands栈中\n7.遍历结束后，拿出栈中最终的结果返回\n\n流程图：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\n\n**代码实现**：\n``` java\n/**\n * 逆波兰表示法\n *\n * @author icatw\n * @date 2022/04/17\n */\npublic class ReversePolishNotation {\n    public static void main(String[] args) {\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\n        String[] notation = {\"3\", \"17\", \"15\", \"-\", \"*\", \"18\", \"6\", \"/\", \"+\"};\n        int result = calculate(notation);\n        System.out.println(\"逆波兰表达式的结果为：\" + result);\n    }\n\n    /**\n     * @param notation 逆波兰表达式的数组表示方式\n     * @return 逆波兰表达式的计算结果\n     */\n    public static int calculate(String[] notation) {\n        //1、定义一个栈用来存储操作数\n        Stack<Integer> operands = new Stack<>();\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\n        for (int i = 0; i < notation.length; i++) {\n            String curr = notation[i];\n            //3、判断当前元素是运算符还是操作数\n            Integer o1;\n            Integer o2;\n            Integer result;\n            switch (curr) {\n                case \"+\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 + o1;\n                    operands.push(result);\n                    break;\n                case \"-\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 - o1;\n                    operands.push(result);\n                    break;\n                case \"*\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 * o1;\n                    operands.push(result);\n                    break;\n                case \"/\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 / o1;\n                    operands.push(result);\n                    break;\n                default:\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\n                    operands.push(Integer.valueOf(curr));\n                    break;\n            }\n\n            //5、操作数，把该操作数压入栈中\n\n        }\n        Integer pop = operands.pop();\n        System.out.println(pop);\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\n        return pop;\n    }\n}\n```\n# 队列\n## 理论基础：\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\n## API设计\n|类名|Queue|\n|-|-|\n|构造方法|public Queue()：创建Queue对象|\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\n|内部结点类|private class Node|\n## 代码实现\n基于Java链表\n``` java\n/**\n * @author icatw\n * @date 2022/4/18\n * @email 762188827@qq.com\n * @apiNote\n */\npublic class Queue<T> implements Iterable<T> {\n    //记录首结点\n    private Node head;\n    //记录最后一个结点\n    private Node last;\n    //记录队列中元素的个数\n    private int N;\n\n    public Queue() {\n        head = new Node(null, null);\n        last = null;\n        N = 0;\n    }\n\n    //判断队列是否为空\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    //返回队列中元素的个数\n    public int size() {\n        return N;\n    }\n\n    //向队列中插入元素t\n    public void enqueue(T t) {\n        //1、当前尾结点，last为null\n        if (last == null) {\n            last = new Node(t, null);\n            head.next = last;\n        }\n        //    2、当前尾结点不为null\n        else {\n            Node oldLast = this.last;\n            Node newNode = new Node(t, null);\n            last = newNode;\n            oldLast.next = last;\n        }\n        N++;\n    }\n\n    //从队列中拿出一个元素\n    public T dequeue() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node oldFirst = head.next;\n        head.next = oldFirst.next;\n        N--;\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\n        if (isEmpty()) {\n            last = null;\n        }\n        return oldFirst.item;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new IterableI();\n    }\n\n\n    private class Node {\n        public T item;\n        public Node next;\n\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private class IterableI implements Iterator<T> {\n        private Node n;\n\n        public IterableI() {\n            this.n = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n\n            return n.next != null;\n        }\n\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n```',1,'',0,1,3,'2022-04-18 02:27:46','2022-05-11 13:52:00'),(70,1,195,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d8afa7b4d72f0765e8a1cae491582411.jpg','数据结构学习笔记：栈和队列','# 栈\n## 理论基础：\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\n\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\n## 栈的实现\n这里基于**Java链表**实现\n\n## 栈的API设计\n|类名|Stack|\n|-|-|\n|构造方法|public Stack()|\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\n|结点内部类|private class Node|\n\n## 代码实现\n``` java\n/**\n * 堆栈\n *\n * @author icatw\n * @date 2022/4/17\n * @email 762188827@qq.com\n * @apiNote\n */\npublic class Stack<T> implements Iterable<T> {\n    private Node head;\n    private int N;\n\n    public Stack() {\n        this.head = new Node(null, null);\n        this.N = 0;\n    }\n\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    public int size() {\n        return N;\n    }\n\n    /**\n     * 弹出栈顶元素\n     *\n     * @return {@link T}\n     */\n    public T pop() {\n        //找到首结点指向的第一个结点\n        Node oldFirst = this.head.next;\n        //让首结点指向原来的第一个结点的下一个结点\n        if (oldFirst == null) {\n            return null;\n        }\n        head.next = oldFirst.next;\n        //元素个数-1\n        N--;\n        return oldFirst.item;\n    }\n\n    /**\n     * 向栈中压入元素t\n     *\n     * @param t t\n     */\n    public void push(T t) {\n        //找到首结点指向的第一个结点\n        Node oldFirst = head.next;\n        //    创建新结点\n        Node newNode = new Node(t, null);\n        //    让首结点指向新结点\n        head.next = newNode;\n        //    让新结点指向原来的第一个结点\n        newNode.next = oldFirst;\n        //    元素个数+1\n        N++;\n    }\n\n\n    private class Node {\n        public T item;\n        public Node next;\n\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new IterableI();\n    }\n\n    private class IterableI implements Iterator<T> {\n        private Node n;\n\n        public IterableI() {\n            this.n = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return n.next != null;\n        }\n\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n```\n## 案例\n### **LeetCode 20.有效的括号**\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n1.左括号必须用相同类型的右括号闭合。\n2.左括号必须以正确的顺序闭合。\n\n**Java代码实现**\n``` java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> left=  new Stack<>();\n        for(char c : s.toCharArray()){\n            //左括号，则入栈\n            if (c == \'(\' || c == \'{\' || c == \'[\')\n                left.push(c);\n            else //右括号\n                if (!left.isEmpty() && leftOf(c) == left.peek())\n                    left.pop();\n                else\n                    // 和最近的左括号不匹配\n                    return false;\n        }\n        //是否所有的左括号都被匹配了\n        return left.isEmpty();\n    }\n\n    char leftOf(char c) {\n        if (c == \'}\') return \'{\';\n        if (c == \')\') return \'(\';\n        return \'[\';\n    }\n}\n```\n解题思路\n> 1.创建一个栈用来存储左括号\n2.从左往右遍历字符串，拿到每一个字符\n3.判断该字符是不是左括号，如果是，放入栈中存储\n4.判断该字符是不是右括号，如果不是，继续下一次循环\n5.如果该字符是右括号，则从栈中弹出一个元素t；\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\n``` text\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\nif (!left.isEmpty() && leftOf(c) == left.peek())\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\n否则，此右括号和最近的左括号不匹配，直接返回false\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\n栈为空，则匹配成功，否则返回失败\n```\n\n### 逆波兰表达式求值问题\n1. 什么是逆波兰表达式（后缀表达式）？\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\n2. 中缀表达式\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\n\n**对应关系**：\n|中缀表达式|逆波兰表达式|\n|:--:|:--:|\n|a+b|ab+|\n|a+(b-c)|abc-+|\n|a+(b-c)*d|abc-d*+|\n|a*(b-c)+d|abc-*d+|\n**需求**：\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\n分析：\n> 1.创建一个栈对象oprands存储操作数\n2.从左往右遍历逆波兰表达式，得到每一个字符串\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n5.使用该运算符计算o1和o2，得到结果result\n6.把该结果压入oprands栈中\n7.遍历结束后，拿出栈中最终的结果返回\n\n流程图：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\n\n**代码实现**：\n``` java\n/**\n * 逆波兰表示法\n *\n * @author icatw\n * @date 2022/04/17\n */\npublic class ReversePolishNotation {\n    public static void main(String[] args) {\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\n        String[] notation = {\"3\", \"17\", \"15\", \"-\", \"*\", \"18\", \"6\", \"/\", \"+\"};\n        int result = calculate(notation);\n        System.out.println(\"逆波兰表达式的结果为：\" + result);\n    }\n\n    /**\n     * @param notation 逆波兰表达式的数组表示方式\n     * @return 逆波兰表达式的计算结果\n     */\n    public static int calculate(String[] notation) {\n        //1、定义一个栈用来存储操作数\n        Stack<Integer> operands = new Stack<>();\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\n        for (int i = 0; i < notation.length; i++) {\n            String curr = notation[i];\n            //3、判断当前元素是运算符还是操作数\n            Integer o1;\n            Integer o2;\n            Integer result;\n            switch (curr) {\n                case \"+\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 + o1;\n                    operands.push(result);\n                    break;\n                case \"-\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 - o1;\n                    operands.push(result);\n                    break;\n                case \"*\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 * o1;\n                    operands.push(result);\n                    break;\n                case \"/\":\n                    o1 = operands.pop();\n                    o2 = operands.pop();\n                    result = o2 / o1;\n                    operands.push(result);\n                    break;\n                default:\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\n                    operands.push(Integer.valueOf(curr));\n                    break;\n            }\n\n            //5、操作数，把该操作数压入栈中\n\n        }\n        Integer pop = operands.pop();\n        System.out.println(pop);\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\n        return pop;\n    }\n}\n```\n# 队列\n## 理论基础：\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\n## API设计\n|类名|Queue|\n|-|-|\n|构造方法|public Queue()：创建Queue对象|\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\n|内部结点类|private class Node|\n## 代码实现\n基于Java链表\n``` java\n/**\n * @author icatw\n * @date 2022/4/18\n * @email 762188827@qq.com\n * @apiNote\n */\npublic class Queue<T> implements Iterable<T> {\n    //记录首结点\n    private Node head;\n    //记录最后一个结点\n    private Node last;\n    //记录队列中元素的个数\n    private int N;\n\n    public Queue() {\n        head = new Node(null, null);\n        last = null;\n        N = 0;\n    }\n\n    //判断队列是否为空\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    //返回队列中元素的个数\n    public int size() {\n        return N;\n    }\n\n    //向队列中插入元素t\n    public void enqueue(T t) {\n        //1、当前尾结点，last为null\n        if (last == null) {\n            last = new Node(t, null);\n            head.next = last;\n        }\n        //    2、当前尾结点不为null\n        else {\n            Node oldLast = this.last;\n            Node newNode = new Node(t, null);\n            last = newNode;\n            oldLast.next = last;\n        }\n        N++;\n    }\n\n    //从队列中拿出一个元素\n    public T dequeue() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node oldFirst = head.next;\n        head.next = oldFirst.next;\n        N--;\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\n        if (isEmpty()) {\n            last = null;\n        }\n        return oldFirst.item;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new IterableI();\n    }\n\n\n    private class Node {\n        public T item;\n        public Node next;\n\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n\n    private class IterableI implements Iterator<T> {\n        private Node n;\n\n        public IterableI() {\n            this.n = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n\n            return n.next != null;\n        }\n\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n```\n## 案例\n### LeetCode 225. 用队列实现栈\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\nvoid push(int x) 将元素 x 压入栈顶。\nint pop() 移除并返回栈顶元素。\nint top() 返回栈顶元素。\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n**代码实现**：\n``` java\nclass MyStack {\n\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<Integer>();\n        queue2 = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        queue2.offer(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    public int pop() {\n        return queue1.poll();\n    }\n    \n    public int top() {\n        return queue1.peek();\n    }\n    \n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n```',1,'',0,0,1,'2022-04-18 02:47:44','2022-05-23 22:54:57'),(71,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg','springboot+vue跨域问题','## springboot+vue解决跨域问题的两种方法\n### 第一种解决方案\n这种方案是直接的解决跨域问题的方案，就是吧 Vue 编译后的代码放到 Spring-boot 的 `resources/static` 目录下（当然你的 axios 的 BaseURL 改成 /api 类似这样不需要域名前缀了）。也就是前后端使用一个服务，这样自然不会有跨域问题了。实际上这已经不算是前后端分离了，只是前后端分离开发 :D)。\n\n### 第二种解决方案\n第二种解决方案当然是使用官方提供的方法：CORS。Spring 下有两种方式使用 CORS：\n\n1. 使用注解\n在需要提供前端跨域请求的接口上使用注解\n\n```\n@CrossOrigin(origins = {\"http://localhost:8080\", \"null\"})\n@RequestMapping(value = \"/helloword\", method = RequestMethod.Post)\npublic String helloword() {\n    return \"{\\\"message\\\": \\\"helloword\\\"}\";\n}\n```\n这种方式是在接口级上控制跨域访问，在前后端分离的架构下，这种方式显得不大合适。\n\n2. 在配置类中设置 CORS\n```\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurerAdapter {\n  @Override\n  public void addCorsMappings(CorsRegistry registry) {\n    registry.addMapping(\"/**\")\n            .allowedOrigins(\"http://localhost:8080\")\n            .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\")\n            .maxAge(3600)\n            .allowCredentials(true);\n  }\n}\n```\n`http://localhost:8080` 是你的 Vue 项目的服务地址和端口号，这样 Spring boot 后端服务就允许 Vue 前端跨域反问所有接口了。',1,'',0,1,1,'2022-04-27 13:16:55','2022-04-27 13:17:58'),(72,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg','springboot+vue跨域问题','## springboot+vue解决跨域问题的两种方法\n### 第一种解决方案\n这种方案是直接的解决跨域问题的方案，就是吧 Vue 编译后的代码放到 Spring-boot 的 `resources/static` 目录下（当然你的 axios 的 BaseURL 改成 /api 类似这样不需要域名前缀了）。也就是前后端使用一个服务，这样自然不会有跨域问题了。实际上这已经不算是前后端分离了，只是前后端分离开发 :D)。\n\n### 第二种解决方案\n第二种解决方案当然是使用官方提供的方法：CORS。Spring 下有两种方式使用 CORS：\n\n1. 使用注解\n在需要提供前端跨域请求的接口上使用注解\n\n```\n@CrossOrigin(origins = {\"http://localhost:8080\", \"null\"})\n@RequestMapping(value = \"/helloword\", method = RequestMethod.Post)\npublic String helloword() {\n    return \"{\\\"message\\\": \\\"helloword\\\"}\";\n}\n```\n这种方式是在接口级上控制跨域访问，在前后端分离的架构下，这种方式显得不大合适。\n\n2. 在配置类中设置 CORS\n```\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurerAdapter {\n  @Override\n  public void addCorsMappings(CorsRegistry registry) {\n    registry.addMapping(\"/**\")\n            .allowedOrigins(\"http://localhost:8080\")\n            .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\")\n            .maxAge(3600)\n            .allowCredentials(true);\n  }\n}\n```\n`http://localhost:8080` 是你的 Vue 项目的服务地址和端口号，这样 Spring boot 后端服务就允许 Vue 前端跨域反问所有接口了。',1,'',0,0,1,'2022-04-27 13:17:02',NULL),(73,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1962ead9290560146a571c4ce2f281b.png','springboot集成可视化api接口文档','## springboot集成swagger-ui+knife4j可视化api接口文档\n\n### springboot集成swagger-ui\nswagger-ui官网：[swagger-ui官网](https://swagger.io/tools/swagger-ui/)\n1. 引pom\n``` java\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-boot-starter</artifactId>\n            <version>3.0.0</version>\n        </dependency>\n```\n2. 改配置\n添加配置文件\n``` java\n/**\n * 配置\n *\n * @author 76218\n * @date 2022/04/27\n */\n@Configuration\n@EnableOpenApi\npublic class SwaggerConfig {\n\n\n    /**\n     * 创建API应用\n     * apiInfo() 增加API相关信息\n     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，\n     * 本例采用指定扫描的包路径来定义指定要建立API的目录。\n     *\n     * @return\n     */\n    @Bean\n    public Docket restApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .groupName(\"标准接口\")\n                .apiInfo(apiInfo(\"Spring Boot中使用Swagger2构建RESTful APIs\", \"1.0\"))\n                .useDefaultResponseMessages(true)\n                .forCodeGeneration(false)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"cn.icatw.springboot.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 创建该API的基本信息（这些基本信息会展现在文档页面中）\n     * 访问地址：http://ip:port/swagger-ui.html\n     *\n     * @return\n     */\n    private ApiInfo apiInfo(String title, String version) {\n        return new ApiInfoBuilder()\n                .title(title)\n                .description(\"icatw: http://www.icatw.top\")\n                .termsOfServiceUrl(\"http://www.icatw.top\")\n                .contact(new Contact(\"icatw\", \"http://www.icatw.top\", \"762188827@qq.com\"))\n                .version(version)\n                .build();\n    }\n\n\n}\n```\n3. 添加注解\n- @Api(tags = \"用户模块\")：api模块信息\n- @ApiOperation(value = \"新增或修改用户信息\")：接口信息\n\n``` java\n/**\n * (SysUser)表控制层\n *\n * @author icatw\n * @since 2022-04-26 08:37:23\n */\n@Api(tags = \"用户模块\")\n@RestController\n@RequestMapping(\"sysUser\")\npublic class SysUserController {\n    /**\n     * 服务对象\n     */\n    @Autowired\n    private SysUserService userService;\n\n    /**\n     * 保存\n     *\n     * @param user 用户\n     * @return boolean\n     */\n    @ApiOperation(value = \"新增或修改用户信息\")\n    @PostMapping\n    public boolean save(@RequestBody SysUser user) {\n        // 新增或者更新\n        return userService.saveOrUpdate(user);\n    }\n}\n\n```\n\n4. 测试\n重启springboot项目 访问 `http://ip:port/swagger-ui.html`\nhttp://localhost:9090/swagger-ui/index.html\n\n效果\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6893461959b9f38ec30233eb3545e850.png)\n\n### springboot集成knife4j\n个人认为knife4j更为美观\nknife4j官网： [knife4j官网](https://doc.xiaominfo.com/)\n1. 引pom\n<dependency>\n            <groupId>com.github.xiaoymin</groupId>\n            <artifactId>knife4j-spring-boot-starter</artifactId>\n            <version>2.0.7</version>\n        </dependency>\n\n2. 改配置\n``` java\n\n/**\n * knife4j配置\n *\n * @author icatw\n * @date 2022/04/27\n */\n@Configuration\n@EnableSwagger2WebMvc\npublic class Knife4jConfiguration {\n\n    @Bean(value = \"defaultApi2\")\n    public Docket defaultApi2() {\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(new ApiInfoBuilder()\n                        //.title(\"swagger-bootstrap-ui-demo RESTful APIs\")\n                        .description(\"icatwの后台管理系统api接口\")\n                        .termsOfServiceUrl(\"http://www.icatw.top/\")\n                        .contact(new Contact(\"icatw\",\"http://www.icatw.top/\",\"762188827@qq.com\"))\n                        .version(\"1.0\")\n                        .build())\n                //分组名称\n                .groupName(\"2.X版本\")\n                .select()\n                //这里指定Controller扫描包路径\n                .apis(RequestHandlerSelectors.basePackage(\"cn.icatw.springboot.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n        return docket;\n    }\n}\n```\n3. 添加注解\n> 注解方式同swagger\n\n4. 重启测试\n`http://localhost:9090/doc.html`\n效果图\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f9cad759caf6cac5caa21aca5af62337.png)\n\n完成！',1,'',0,0,1,'2022-04-27 15:55:38',NULL),(74,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/84c756229e2049a2ab5e97d3ee3fb708.png','springboot集成EasyPoi实现Excel数据导入导出','## springboot集成EasyPoi实现Excel数据导入导出\n\n> 在我们平时工作中经常会遇到要操作Excel的功能，比如导出个用户信息或者订单信息的Excel报表。你肯定听说过POI这个东西，可以实现。但是POI实现的API确实很麻烦，它需要写那种逐行解析的代码（类似Xml解析）。今天给大家推荐一款非常好用的Excel导入导出工具EasyPoi，希望对大家有所帮助！\n\n### EasyPoi简介 \n用惯了SpringBoot的朋友估计会想到，有没有什么办法可以直接定义好需要导出的数据对象，然后添加几个注解，直接自动实现Excel导入导出功能？\n\nEasyPoi正是这么一款工具，如果你不太熟悉POI，想简单地实现Excel操作，用它就对了！\n\nEasyPoi的目标不是替代POI，而是让一个不懂导入导出的人也能快速使用POI完成Excel的各种操作，而不是看很多API才可以完成这样的工作。\n\n### 集成\n> 在SpringBoot中集成EasyPoi非常简单，只需添加如下一个依赖即可，真正的开箱即用\n\n``` java\n<dependency>\n    <groupId>cn.afterturn</groupId>\n    <artifactId>easypoi-spring-boot-starter</artifactId>\n    <version>4.4.0</version>\n</dependency>\n```\n\n### 使用\n> 接下来介绍下EasyPoi的使用，以用户信息的导入导出为例，实现下简单的单表导出\n### 简单导出\n\n>我们以会员信息列表导出为例，使用EasyPoi来实现下导出功能，看看是不是够简单！\n- 首先创建一个用户对象sysUser，封装用户信息；\n``` java\n/**\n * (SysUser)表实体类\n *\n * @author icatw\n * @since 2022-04-26 08:37:23\n */\n@EqualsAndHashCode(callSuper = true)\n@Data\npublic class SysUser extends Model<SysUser> {\n    /**\n     * id\n     */\n    @Excel(name = \"ID\", width = 10)\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n    /**\n     * 用户名\n     */\n    @Excel(name = \"用户名\",width = 20,needMerge = true)\n    private String username;\n    /**\n     * 密码\n     */\n    @JsonIgnore\n    @Excel(name = \"密码\",width = 20,needMerge = true)\n    private String password;\n    /**\n     * 昵称\n     */\n    @Excel(name = \"昵称\",width = 20,needMerge = true)\n    private String nickname;\n    /**\n     * 电子邮件\n     */\n    @Excel(name = \"邮箱\",width = 20,needMerge = true)\n    private String email;\n    /**\n     * 电话\n     */\n    @Excel(name = \"手机号\",width = 20,needMerge = true,desensitizationRule = \"3_4\")\n    private String phone;\n    /**\n     * 地址\n     */\n    @Excel(name = \"地址\",width = 20,needMerge = true)\n    private String address;\n    /**\n     * 创建时间\n     */\n    @Excel(name = \"注册时间\",width = 20,format = \"yyyy-MM-dd\")\n    private Date createTime;\n    /**\n     * 头像\n     */\n    private String avatarUrl;\n}\n```\n- 在此我们就可以看到EasyPoi的核心注解`@Excel`，通过在对象上添加`@Excel`注解，可以将对象信息直接导出到Excel中去，下面对注解中的属性做个介绍；\n   - name：Excel中的列名；\n   - width：指定列的宽度；\n  - needMerge：是否需要纵向合并单元格；\n  - format：当属性为时间类型时，设置时间的导出导出格式；\n  - desensitizationRule：数据脱敏处理，3_4表示只显示字符串的前3位和后4位，其他  为*号；\n  - replace：对属性进行替换；\n  - suffix：对数据添加后缀。 \n- 接下来在Controller中添加一个接口，用于导出用户列表到Excel，具体代码如下；\n``` java\n    /**\n     * 导出用户列表\n     *\n     * @param map      地图\n     * @param request  请求\n     * @param response 响应\n     */\n    @ApiOperation(value = \"导出会员列表Excel\")\n    @GetMapping(\"/export\")\n    public void exportUserList(ModelMap map,\n                               HttpServletRequest request,\n                               HttpServletResponse response) {\n        List<SysUser> memberList = userService.list();//此处为mp查询所有用户信息\n	//先查询出用户信息封装为对象再进行导出\n        ExportParams params = new ExportParams(\"用户信息列表\", \"用户信息列表\", ExcelType.XSSF);\n        map.put(NormalExcelConstants.DATA_LIST, memberList);\n        map.put(NormalExcelConstants.CLASS, SysUser.class);\n        map.put(NormalExcelConstants.PARAMS, params);\n        map.put(NormalExcelConstants.FILE_NAME, \"用户信息\");\n        PoiBaseView.render(map, request, response, NormalExcelConstants.EASYPOI_EXCEL_VIEW);\n    }\n```\n之后通过访问url即可导出Excel文件\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/77b92b1ebd73af5f4ef82cc5b6783d41.png)\n\n### 简单导入\n>导入功能实现起来也非常简单，下面以vue的会员信息列表的导入为例\n- 首先在controller中添加导入的接口\n``` java\n    /**\n     * 导入成员列表\n     *\n     * @param file 文件\n     * @return {@link List}<{@link SysUser}>\n     * @throws Exception 异常\n     */\n    @ApiOperation(\"从Excel导入会员列表\")\n    @PostMapping(\"/import\")\n    public List<SysUser> importMemberList(@RequestPart(\"file\") MultipartFile file) throws Exception {\n        ImportParams params = new ImportParams();\n        params.setTitleRows(1);\n        params.setHeadRows(1);\n        List<SysUser> list = ExcelImportUtil.importExcel(\n                file.getInputStream(),\n                SysUser.class, params);\n        log.info(list.toString());\n        userService.saveOrUpdateBatch(list);\n        return userService.list();\n    }\n```\n- 在vue项目中添加导入按钮\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/03fcbd2e20825782fbc2da8d02c611ea.png)\n导入按钮（element-ui中的文件上传）代码如下：\n``` java\n<el-upload\n          class=\"upload-demo\"\n          action=\"http://localhost:9090/sysUser/import\"\n          :show-file-list=\"false\" accept=\"xlsx\" :on-success=\"handleExcelImportSuccess\" style=\"display: inline-block\">\n        <el-button type=\"primary\" class=\"ml-5\">导入 <i class=\"el-icon-bottom\"></i></el-button>\n      </el-upload>\n```\n``` text\naction后接请求接口\n:on-success=\"handleExcelImportSuccess\"  绑定导入成功之后的事件\n```\n``` java\n   //导入Excel\n    handleExcelImportSuccess() {\n      this.$message.success(\"导入成功\")\n      this.load()\n    }\n```\n### 总结\n使用easyPoi导入导出Excel数据是十分的简单的！\n\n### 参考资料 \n项目官网：https://gitee.com/lemur/easypoi\n\n### 项目源码地址 \nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easypo\n\n\n',1,'',0,0,1,'2022-04-27 21:18:48',NULL),(75,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/81ed78be39afb3fc4d1b4bcf46d7aff7.png','springboot统一结果返回集','## springboot前后端分离项目的统一配置\n### 统一返回对象Result\n``` java\n/**\n * 统一返回对象R\n *\n * @author icatw\n * @since 2022-05-04 19:23:27\n */\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class R {\n\n    private Integer code;\n    private String msg;\n    private Object data;\n\n    public static R ok() {\n        return new R(ResultStatusEnum.SUCCESS.getCode(), \"\", null);\n    }\n\n    public static R ok(Object data) {\n        return new R(ResultStatusEnum.SUCCESS.getCode(), \"\", data);\n    }\n\n    public static R fail(Integer code, String msg) {\n        return new R(code, msg, null);\n    }\n\n    public static R fail() {\n        return new R(ResultStatusEnum.SYSTEM_EXCEPTION.getCode(), ResultStatusEnum.SYSTEM_EXCEPTION.getMessage(), null);\n    }\n\n}\n```\n### 统一响应结果状态枚举类\n``` java\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n/**\n * 响应结果状态枚举类\n *\n * @author icatw\n * @date 2022/04/28\n */\n@NoArgsConstructor\n@AllArgsConstructor\npublic enum ResultStatusEnum {\n    /**\n     * 请求成功\n     */\n    SUCCESS(200, \"请求成功！\"),\n\n    /**\n     * 密码错误\n     */\n    PASSWORD_NOT_MATCHING(300, \"用户名或密码错误\"),\n    /**\n     * 用户存在\n     */\n    USER_EXISTS(301, \"该用户名已存在\"),\n    NO_TOKEN_EXCEPTION(302, \"没有token，请重新登陆\"),\n    TOKEN_VERIFICATION_FAILED(303, \"token验证失败，请重新登录\"),\n    NOT_USER(304, \"用户不存在，请重新登录\"),\n    /**\n     * 系统异常\n     */\n    SYSTEM_EXCEPTION(401, \"系统错误\"),\n    /**\n     * 其他异常\n     */\n    OTHER_EXCEPTION(500, \"其他错误\");\n\n    @Getter\n    @Setter\n    private int code;\n\n    @Getter\n    @Setter\n    private String message;\n}\n```\n### 自定义异常\n``` java\n/**\n * 自定义异常\n *\n * @author icatw\n * @date 2022/04/28\n */\n@Getter\npublic class CustomException extends RuntimeException {\n    private int code;\n    private String message;\n\n    public CustomException(int code, String message) {\n        this.code = code;\n        this.message = message;\n    }\n\n    public CustomException(ResultStatusEnum resultStatusEnum) {\n        this.code = resultStatusEnum.getCode();\n        this.message = resultStatusEnum.getMessage();\n    }\n}\n\n```\n\n### 全局异常处理\n``` java\n/**\n * 全局异常处理\n *\n * @author icatw\n * @date 2022/4/28\n * @email 762188827@qq.com\n * @apiNote\n */\n@ControllerAdvice\npublic class GlobalExceptionHandle {\n    @ResponseBody\n    @ExceptionHandler(CustomException.class)\n    public R handleCustomException(CustomException customException) {\n\n        return R.fail(customException.getCode(), customException.getMessage());\n    }\n}\n```',1,'',0,0,1,'2022-05-04 20:20:59',NULL),(76,1,191,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9a2fceb5460b1e87030b4f1c9d817c3a.png','记一次springboot跨域携带请求头token的问题','## 记一次springboot跨域携带请求头token的问题\n<p>今天在学习springboot+vue前后台分离后台管理系统的时候遇到的一个bug\n，使用postman测试接口时可以得到后端传来的请求头，可前端死活接收不到token</p>\n问题如下图\n\n\n### postman可以请求成功\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/64141a10b524283cf2d070ccb9e173e2.png)\n### 后端也有响应返回给前端请求头\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/771c4215439f569e1f4f697bf4dd5e0c.png)\n\n### 前端请求携带不上token\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d3a6f28b3d7e98a3b1d9c55cfe37329f.png)\n### 检查前端axios请求\n贴上axios.js的代码\n``` java\nimport axios from \"axios\";\nimport router from \"./router\";\nimport Element from \"element-ui\"\n\naxios.defaults.baseURL = \"http://localhost:8081\"\n\nconst request = axios.create({\n    timeout: 5000,\n    headers: {\n        \'Content-Type\': \"application/json; charset=utf-8\"\n    }\n})\n\nrequest.interceptors.request.use(config => {\n    config.headers[\'Authorization\'] = localStorage.getItem(\"token\")\n    return config\n})\n\nrequest.interceptors.response.use(\n    response => {\n\n        console.log(\"response ->\" + response)\n\n        let res = response.data\n\n        if (res.code === 200) {\n            return response\n        } else {\n            Element.Message.error(!res.msg ? \'系统异常\' : res.msg)\n            return Promise.reject(response.data.msg)\n        }\n    },\n    error => {\n\n        console.log(error)\n\n        if (error.response.data) {\n            error.massage = error.response.data.msg\n        }\n\n        if (error.response.status === 401) {\n            router.push(\"/login\")\n        }\n\n        Element.Message.error(error.massage, {duration: 3000})\n        return Promise.reject(error)\n    }\n)\n\nexport default request\n\n```\n可以看出前端vue发送请求是设置了headers的\n\n### 检查后端spring security\n\n``` java\npackage cn.icatw.admin.security;\n\nimport cn.hutool.json.JSONUtil;\nimport cn.icatw.admin.common.R;\nimport cn.icatw.admin.utils.JwtUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.web.authentication.AuthenticationSuccessHandler;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @author icatw\n * @date 2022/5/5\n * @email 762188827@qq.com\n * @apiNote\n */\n@Component\n@Slf4j\npublic class LoginSuccessHandler implements AuthenticationSuccessHandler {\n    @Autowired\n    JwtUtil jwtUtil;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        ServletOutputStream outputStream = response.getOutputStream();\n\n        // 生成jwt，并放置到请求头中\n        String jwt = jwtUtil.generateToken(authentication.getName());\n        log.info(\"token为---------------------------------------\"+jwt);\n        response.setHeader(jwtUtil.getHeader(), jwt);\n\n        R result = R.ok(\"\");\n\n        outputStream.write(JSONUtil.toJsonStr(result).getBytes(\"UTF-8\"));\n\n        outputStream.flush();\n        outputStream.close();\n    }\n}\n\n```\n这里也是设置成功了请求头\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/11bc45f83e2272d7e4864290ef677f7d.png)\n\n### 最后发现是跨域配置的问题...\n原配置代码\n``` java\npackage cn.icatw.springboot.config;\n\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\n//@Configuration\npublic class CorsConfig {\n\n    // 当前跨域请求最大有效时长。这里默认1天\n    private static final long MAX_AGE = 24 * 60 * 60;\n\n    //@Bean\n    public CorsFilter corsFilter() {\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n        corsConfiguration.addAllowedOrigin(\"http://localhost:8080\"); // 1 设置访问源地址\n        corsConfiguration.addAllowedHeader(\"*\"); // 2 设置访问源请求头\n        corsConfiguration.addAllowedMethod(\"*\"); // 3 设置访问源请求方法\n        corsConfiguration.setMaxAge(MAX_AGE);\n        source.registerCorsConfiguration(\"/**\", corsConfiguration); // 4 对接口配置跨域设置\n        return new CorsFilter(source);\n    }\n}\n\n```\n修改后的跨域配置\n``` java\n/**\n * 跨域配置\n *\n * @author icatw\n * @date 2022/05/06\n */\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n\n    private CorsConfiguration buildConfig() {\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n        corsConfiguration.addAllowedOrigin(\"*\");\n        corsConfiguration.addAllowedHeader(\"*\");\n        corsConfiguration.addAllowedMethod(\"*\");\n        corsConfiguration.addExposedHeader(\"Authorization\");\n        return corsConfiguration;\n    }\n\n    @Bean\n    public CorsFilter corsFilter() {\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", buildConfig());\n        return new CorsFilter(source);\n    }\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n                .allowedOrigins(\"*\")\n//          .allowCredentials(true)\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                .maxAge(3600);\n    }\n\n}\n```\n加上 `corsConfiguration.addExposedHeader(\"Authorization\");`之后便能成功携带请求头访问\n\n又是被自己蠢哭的一次....',1,'',0,0,1,'2022-05-06 09:53:37',NULL),(77,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg','vue的axios delete请求参数','### vue中axios 的delete和post,put在传值上有点区别\npost和put有三个参数，url,data和config，所以在使用这两个时，可以写成`axios.post(api,{id:1}),axios.put(api,{id:1})`,但是delete只有两个参数：url和config，data在config中，所以需要写成 `axios.delete(api,{data:{id:1}})`\n\n如：\n1. 如果是服务端将参数当作Java对象来封装接收则 参数格式为：{data: param}\n``` java\nvar ids = []\n      id ? ids.push(id) : this.multipleSelection.forEach(row => {\n        ids.push(row.id)\n      })\n      console.log(ids)\n      this.$axios.delete(\"/sys/role/\", {data:ids}).then(res => {\n```\n后端请求应该为：\n``` java\n    /**\n     * 单条/批量删除数据\n     */\n    @ApiOperation(value = \"单条/批量删除数据 \")\n    @DeleteMapping\n    @PreAuthorize(\"hasAuthority(\'sys:role:delete\')\")\n    @Transactional(rollbackFor = Exception.class)\n    public R delete(@RequestBody List<Long> ids) {\n        this.sysRoleService.removeByIds(ids);\n        //同步删除中间表记录\n        sysUserRoleService.remove(new QueryWrapper<SysUserRole>()\n                .in(\"role_id\", ids));\n        sysRoleMenuService.remove(new QueryWrapper<SysRoleMenu>()\n                .in(\"role_id\", ids));\n        //同步删除缓存权限信息\n        for (Long id : ids) {\n            sysUserService.clearUserAuthorityInfoByRoleId(id);\n        }\n        return R.ok();\n    }\n```\n2. 如果服务端将参数当做url 参数 接收，则格式为：{params: param}，这样发送的url将变为http:www.XXX.com?a=…&b=…\n\n后端请求则应为路径变量\n',1,'',0,1,1,'2022-05-06 14:40:01','2022-05-06 14:40:18'),(78,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg','vue的axios delete请求参数','### vue中axios 的delete和post,put在传值上有点区别\npost和put有三个参数，url,data和config，所以在使用这两个时，可以写成`axios.post(api,{id:1}),axios.put(api,{id:1})`,但是delete只有两个参数：url和config，data在config中，所以需要写成 `axios.delete(api,{data:{id:1}})`\n\n如：\n1. 如果是服务端将参数当作Java对象来封装接收则 参数格式为：{data: param}\n``` java\nvar ids = []\n      id ? ids.push(id) : this.multipleSelection.forEach(row => {\n        ids.push(row.id)\n      })\n      console.log(ids)\n      this.$axios.delete(\"/sys/role/\", {data:ids}).then(res => {\n```\n后端请求应该为：\n``` java\n    /**\n     * 单条/批量删除数据\n     */\n    @ApiOperation(value = \"单条/批量删除数据 \")\n    @DeleteMapping\n    @PreAuthorize(\"hasAuthority(\'sys:role:delete\')\")\n    @Transactional(rollbackFor = Exception.class)\n    public R delete(@RequestBody List<Long> ids) {\n        this.sysRoleService.removeByIds(ids);\n        //同步删除中间表记录\n        sysUserRoleService.remove(new QueryWrapper<SysUserRole>()\n                .in(\"role_id\", ids));\n        sysRoleMenuService.remove(new QueryWrapper<SysRoleMenu>()\n                .in(\"role_id\", ids));\n        //同步删除缓存权限信息\n        for (Long id : ids) {\n            sysUserService.clearUserAuthorityInfoByRoleId(id);\n        }\n        return R.ok();\n    }\n```\n2. 如果服务端将参数当做url 参数 接收，则格式为：{params: param}，这样发送的url将变为http:www.XXX.com?a=…&b=…\n\n后端请求则应为路径变量\n',1,'',0,0,1,'2022-05-06 14:40:05',NULL),(79,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/140a0e8e8883c566c717a918ca85cda1.png','springboot循环依赖及解决方法','# Springboot循环依赖如何解决\n今天在做后台管理系统的时候遇到了循环依赖的问题，报错如下\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/274832222934dde59f563225f57ade7e.png)\n于是便开始了百度(面向百度编程)...，在浏览十分钟之后找到了一种最简单的解决方法：\n在注入的service上加上`@Lazy`注解\n``` java\n    @Autowired\n    @Lazy\n    SysUserService sysUserService;\n//存粹是为了方便，主要是懒...\n```\n下面是借鉴学习大佬的一篇博客([springboot循环依赖问题](https://blog.csdn.net/qq_18298439/article/details/88818418))\n## 1.循环依赖是什么？\nBean A 依赖 B，Bean B 依赖 A这种情况下出现循环依赖。\nBean A → Bean B → Bean A\n更复杂的间接依赖造成的循环依赖如下。\nBean A → Bean B → Bean C → Bean D → Bean E → Bean A\n\n## 2.循环依赖会产生什么结果？\n当Spring正在加载所有Bean时，Spring尝试以能正常创建Bean的顺序去创建Bean。\n例如，有如下依赖:\nBean A → Bean B → Bean C\nSpring先创建beanC，接着创建bean B（将C注入B中)，最后创建bean A(将B注入A中)。\n\n但当存在循环依赖时，Spring将无法决定先创建哪个bean。这种情况下，Spring将产生异常BeanCurrentlyInCreationException。\n\n## 3.普通注入之间的循环依赖\n比如：我现在有一个ServiceA需要调用ServiceB的方法，那么ServiceA就依赖于ServiceB，那在ServiceB中再调用ServiceA的方法，就形成了循环依赖。Spring在初始化bean的时候就不知道先初始化哪个，bean就会报错。\n``` java\npublic class ClassA {\n \n@Autowired\n \nClassB classB;\n \n}\n \npublic class ClassB {\n \n@Autowired\n \nClassA classA\n \n}\n```\n如何解决循环依赖，最好的方法是重构代码，进行解耦，如果没有时间重构，可以使用下面的方法：\n (1). 在你的配置文件中，在互相依赖的两个bean的任意一个加上lazy-init属性\n``` java\n<bean id=\"ServiceDependent1\" class=\"org.xyz.ServiceDependent1\" lazy-init=\"true\"> \n \n<constructor-arg ref=\"Service\"/> </bean>  \n \n <bean id=\"ServiceDependent2\" class=\"org.xyz.ServiceDependent2\" lazy-init=\"true\"> \n \n<constructor-arg ref=\"Service\"/> </bean>   \n```\n(2).在你注入bean时，在互相依赖的两个bean上加上@Lazy注解也可以\n``` java\n@Autowired     \n \n@Lazy      \n \nprivate ClassA classA; \n \n \n@Autowired \n \n@Lazy      \n \nprivate ClassB classB; \n```\n\n## 4. 构造器注入循环依赖实例\n首先定义两个相互通过构造器注入依赖的bean。\n``` java\n@Component\npublic class CircularDependencyA {\n \n    private CircularDependencyB circB;\n \n    @Autowired\n    public CircularDependencyA(CircularDependencyB circB) {\n        this.circB = circB;\n    }\n}\n```\n``` java\n@Component\npublic class CircularDependencyB {\n \n    private CircularDependencyA circA;\n \n    @Autowired\n    public CircularDependencyB(CircularDependencyA circA) {\n        this.circA = circA;\n    }\n}\n```\n\n``` java\n@Configuration\n@ComponentScan(basePackages = { \"com.baeldung.circulardependency\" })\npublic class TestConfig {\n}\n```\n\n``` java\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = { TestConfig.class })\npublic class CircularDependencyTest {\n \n    @Test\n    public void givenCircularDependency_whenConstructorInjection_thenItFails() {\n        // Empty test; we just want the context to load\n    }\n}\n```\n运行方法givenCircularDependency_whenConstructorInjection_thenItFails将会产生异常：BeanCurrentlyInCreationException: Error creating bean with name ‘circularDependencyA’:\nRequested bean is currently in creation: Is there an unresolvable circular reference?\n\n## 如何解决\n（1）重新设计\n\n重新设计结构，消除循环依赖。\n\n（2）使用注解 `@Lazy`\n\n一种最简单的消除循环依赖的方式是通过延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象完成注入。\n``` java\n@Component\npublic class CircularDependencyA {\n \n    private CircularDependencyB circB;\n \n    @Autowired\n    public CircularDependencyA(@Lazy CircularDependencyB circB) {\n        this.circB = circB;\n    }\n}\n```\n使用`@Lazy`后，运行代码，可以看到异常消除。\n\n（3）使用Setter/Field注入\nSpring文档建议的一种方式是使用setter注入。当依赖最终被使用时才进行注入。对前文的样例代码少做修改，来观察测试效果。\n``` java\n@Component\npublic class CircularDependencyA {\n \n    private CircularDependencyB circB;\n \n    @Autowired\n    public void setCircB(CircularDependencyB circB) {\n        this.circB = circB;\n    }\n \n    public CircularDependencyB getCircB() {\n        return circB;\n    }\n}\n```\n``` java\n@Component\npublic class CircularDependencyB {\n \n    private CircularDependencyA circA;\n \n    private String message = \"Hi!\";\n \n    @Autowired\n    public void setCircA(CircularDependencyA circA) {\n        this.circA = circA;\n    }\n \n    public String getMessage() {\n        return message;\n    }\n}\n```\n``` java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = { TestConfig.class })\npublic class CircularDependencyTest {\n \n    @Autowired\n    ApplicationContext context;\n \n    @Bean\n    public CircularDependencyA getCircularDependencyA() {\n        return new CircularDependencyA();\n    }\n \n    @Bean\n    public CircularDependencyB getCircularDependencyB() {\n        return new CircularDependencyB();\n    }\n \n    @Test\n    public void givenCircularDependency_whenSetterInjection_thenItWorks() {\n        CircularDependencyA circA = context.getBean(CircularDependencyA.class);\n \n        Assert.assertEquals(\"Hi!\", circA.getCircB().getMessage());\n    }\n}\n```\n\n（4） 使用@PostConstruct\n``` java\n@Component\npublic class CircularDependencyA {\n \n    @Autowired\n    private CircularDependencyB circB;\n \n    @PostConstruct\n    public void init() {\n        circB.setCircA(this);\n    }\n \n    public CircularDependencyB getCircB() {\n        return circB;\n    }\n}\n \n```\n\n``` java\n@Component\npublic class CircularDependencyB {\n \n    private CircularDependencyA circA;\n     \n    private String message = \"Hi!\";\n \n    public void setCircA(CircularDependencyA circA) {\n        this.circA = circA;\n    }\n     \n    public String getMessage() {\n        return message;\n    }\n \n```\n\n（5）实现ApplicationContextAware与InitializingBean\n\n``` java\n@Component\npublic class CircularDependencyA implements ApplicationContextAware, InitializingBean {\n \n    private CircularDependencyB circB;\n \n    private ApplicationContext context;\n \n    public CircularDependencyB getCircB() {\n        return circB;\n    }\n \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        circB = context.getBean(CircularDependencyB.class);\n    }\n \n    @Override\n    public void setApplicationContext(final ApplicationContext ctx) throws BeansException {\n        context = ctx;\n    }\n}\n```\n``` java\n@Component\npublic class CircularDependencyB {\n \n    private CircularDependencyA circA;\n \n    private String message = \"Hi!\";\n \n    @Autowired\n    public void setCircA(CircularDependencyA circA) {\n        this.circA = circA;\n    }\n \n    public String getMessage() {\n        return message;\n    }\n}\n```\n## 总结：我认为对于个人开发使用`@Lazy`或者setter注入的方式会更为简单方便！',2,'https://blog.csdn.net/qq_18298439/article/details/88818418',0,0,1,'2022-05-09 14:17:20',NULL),(80,1,NULL,'','2022-05-11','1',1,'',0,1,3,'2022-05-11 13:51:33','2022-05-11 13:51:47'),(81,1,191,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png','SpringBoot2.6.0集成knife4j启动报错问题处理','## 问题描述：\nSpringBoot项目中集成了knife4j，在将SpringBoot更新到2.6.0后启动项目报错 Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException，导致系统不能正常启动。\n详细报错如下：\n``` java\nError starting ApplicationContext. To display the conditions report re-run your application with \'debug\' enabled.\n2021-12-23 16:52:35.735 ERROR 15348 --- [           main] o.s.boot.SpringApplication               : Application run failed\n\norg.springframework.context.ApplicationContextException: Failed to start bean \'documentationPluginsBootstrapper\'; nested exception is java.lang.NullPointerException\n	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:181)\n	at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:54)\n	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:356)\n	at org.springframework.context.support.DefaultLifecycleProcessor$$Lambda$778/18341126.accept(Unknown Source)\n	at java.lang.Iterable.forEach(Iterable.java:75)\n	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:155)\n	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:123)\n	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:935)\n	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)\n	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145)\n	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:730)\n	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412)\n	at org.springframework.boot.SpringApplication.run(SpringApplication.java:302)\n	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301)\n	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290)\n	at com.chqiuu.test.TestApplication.main(TestApplication.java:23)\nCaused by: java.lang.NullPointerException: null\n	at springfox.documentation.spring.web.WebMvcPatternsRequestConditionWrapper.getPatterns(WebMvcPatternsRequestConditionWrapper.java:56)\n	at springfox.documentation.RequestHandler.sortedPaths(RequestHandler.java:113)\n	at springfox.documentation.spi.service.contexts.Orderings.lambda$byPatternsCondition$3(Orderings.java:89)\n	at springfox.documentation.spi.service.contexts.Orderings$$Lambda$796/7205235.apply(Unknown Source)\n	at java.util.Comparator.lambda$comparing$77a9974f$1(Comparator.java:469)\n	at java.util.Comparator$$Lambda$68/3330950.compare(Unknown Source)\n	at java.util.TimSort.countRunAndMakeAscending(TimSort.java:351)\n	at java.util.TimSort.sort(TimSort.java:230)\n	at java.util.Arrays.sort(Arrays.java:1512)\n	at java.util.ArrayList.sort(ArrayList.java:1454)\n	at java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:387)\n	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)\n	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)\n	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)\n	at java.util.stream.Sink$ChainedReference.end(Sink.java:258)\n	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)\n	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\n	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\n	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\n	at springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:81)\n	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper$$Lambda$790/3038834.apply(Unknown Source)\n	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\n	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374)\n	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)\n	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\n	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\n	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\n	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.withDefaults(AbstractDocumentationPluginsBootstrapper.java:107)\n	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.buildContext(AbstractDocumentationPluginsBootstrapper.java:91)\n	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.bootstrapDocumentationPlugins(AbstractDocumentationPluginsBootstrapper.java:82)\n	at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:100)\n	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:178)\n	... 15 common frames omitted\n\n```\n## 解决方案：\n这个问题困扰了我很久，也在网上找了好多资料，也有些人说springboot版本升级的导致的问题。\n找到的解决办法有两种： \n1. 将springboot降级到2.5.7，但这也只是暂时解决问题的办法，不是长久之计；\n2. 从SpringFox迁移到SpringDoc，这种方式虽然可以处理问题，但对于已经上线的项目来说改动量还是有点大。\n这上面两种解决方案都不是我最想要的，最近对Spring Boot 2.6.0的文档进行研究发现，2.6.0开始使用基于PathPatternParser的路径匹配，而Springfox版本一直没有更新还是使用的AntPathMatcher导致了这个问题，要处理问题也很简单，修改yaml文件，将SpringBoot路劲匹配模式修改为AntPathMatcher就可以了，配置如下：`spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER`\n\n修改application.yml文件配置\n``` java\nspring:\n  mvc:\n    pathmatch:\n      matching-strategy: ANT_PATH_MATCHER\n\n```',1,'',0,0,3,'2022-05-11 14:48:13',NULL),(82,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dfd3dca49d70eaaae9878797737ed8fa.png','springboot集成谷歌验证码','## springboot集成谷歌kaptcha验证码功能\n\n### 引入maven依赖\n``` java\n  <!--        谷歌验证码-->\n        <dependency>\n            <groupId>com.github.axet</groupId>\n            <artifactId>kaptcha</artifactId>\n            <version>0.0.9</version>\n        </dependency>\n```\n### kaptcha配置类\n\n``` java\n/**\n * 验证码配置\n *\n * @author icatw\n * @date 2022/5/11\n * @email 762188827@qq.com\n * @apiNote\n */\n@Configuration\npublic class CaptchaConfig {\n    @Bean\n    public DefaultKaptcha getDefaultKaptcha() {\n        //验证码生成器\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n        //配置\n        Properties properties = new Properties();\n        //是否有边框\n        properties.setProperty(\"kaptcha.border\", \"yes\");\n        //设置边框颜色\n        properties.setProperty(\"kaptcha.border.color\", \"105,179,90\");\n        //边框粗细度，默认为1\n        // properties.setProperty(\"kaptcha.border.thickness\",\"1\");\n        //验证码\n        properties.setProperty(\"kaptcha.session.key\", \"code\");\n        //验证码文本字符颜色 默认为黑色\n        properties.setProperty(\"kaptcha.textproducer.font.color\", \"blue\");\n        //设置字体样式\n        properties.setProperty(\"kaptcha.textproducer.font.names\", \"宋体,楷体,微软雅黑\");\n        //字体大小，默认40\n        properties.setProperty(\"kaptcha.textproducer.font.size\", \"30\");\n        //验证码文本字符内容范围 默认为abced2345678gfynmnpwx\n        // properties.setProperty(\"kaptcha.textproducer.char.string\", \"\");\n        //字符长度，默认为5\n        properties.setProperty(\"kaptcha.textproducer.char.length\", \"5\");\n        //字符间距 默认为2\n        properties.setProperty(\"kaptcha.textproducer.char.space\", \"4\");\n        //验证码图片宽度 默认为200\n        properties.setProperty(\"kaptcha.image.width\", \"100\");\n        //验证码图片高度 默认为40\n        properties.setProperty(\"kaptcha.image.height\", \"40\");\n        Config config = new Config(properties);\n        defaultKaptcha.setConfig(config);\n        return defaultKaptcha;\n    }\n}\n```\n### Controller层使用\n\n``` java\n/**\n * @author icatw\n * @date 2022/5/11\n * @email 762188827@qq.com\n * @apiNote\n */\n@Slf4j\n@RestController\npublic class CaptchaController {\n    @Autowired\n    private DefaultKaptcha defaultKaptcha;\n\n    @ApiOperation(value = \"验证码\")\n    @GetMapping(value = \"/captcha\",produces = \"image/jpeg\")\n    public void captcha(HttpServletRequest request, HttpServletResponse response) {\n        // 定义response输出类型为image/jpeg类型\n        response.setDateHeader(\"Expires\", 0);\n        // Set standard HTTP/1.1 no-cache headers.\n        response.setHeader(\"Cache-Control\", \"no-store, no-cache, mustrevalidate\");\n        // Set IE extended HTTP/1.1 no-cache headers (use addHeader).\n        response.addHeader(\"Cache-Control\", \"post-check=0, pre-check=0\");\n        // Set standard HTTP/1.0 no-cache header.\n        response.setHeader(\"Pragma\", \"no-cache\");\n        // return a jpeg\n        response.setContentType(\"image/jpeg\");\n        //---------------生成验证码begin\n        //获取验证码文本内容\n        String text = defaultKaptcha.createText();\n        log.info(\"验证码内容为：\" + text);\n        //将验证码文本内容放入session，//TODO 可优化为存入redis\n        request.getSession().setAttribute(\"captcha\", text);\n        //根据文本验证码内容创建图形验证码\n        BufferedImage image = defaultKaptcha.createImage(text);\n        ServletOutputStream outputStream = null;\n        try {\n            outputStream = response.getOutputStream();\n            //输出流输出图片，格式为jpg\n            ImageIO.write(image, \"jpg\", outputStream);\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (outputStream != null) {\n                try {\n                    outputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        //---------------生成验证码end\n    }\n}\n```\n### 测试效果\n![_PN0CBQT7~J9I0ETFY.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dfd3dca49d70eaaae9878797737ed8fa.png)',1,'',0,0,1,'2022-05-12 09:49:33',NULL),(83,1,NULL,'','spring boot security设置忽略地址不生效的解决','## spring boot security设置忽略地址不生效\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\n``` java\n//动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n```\n之后出现的，报错如下\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\n### 最初security主要代码如下：\n这个是忽略地址\n``` java\n  private static final String[] URL_WHITELIST = {\n            \"/login\",\n            \"/logout\",\n            \"/captcha\",\n            \"favicon.ico\",\n            \"/swagger-ui.html/**\",\n            \"/webjars/**\",\n            \"/v2/**\",\n            \"/swagger-resources/**\",\n            \"/doc.html\",\n            \"/upload\"\n    };\n```\nsecurity配置：\n``` java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //使用jwt，不需要csrf\n        http.csrf()\n                .disable()\n                //基于token不需要session\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                //允许登录访问\n                .and()\n                .authorizeRequests()\n                .antMatchers(URL_WHITELIST)\n                .permitAll()\n                //除了上面,所有请求都需要认证\n                .anyRequest()\n                .authenticated()\n                //动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n                //禁用缓存\n                .and()\n                .headers()\n                .cacheControl();\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n        //    添加自定义未授权和未登录结果返回\n        http.exceptionHandling()\n                .accessDeniedHandler(accessDeniedHandler)\n                .authenticationEntryPoint(authenticationEntryPoint);\n\n    }\n```\n### 修改后代码\n\n``` java\n@Override\n    public void configure(WebSecurity web) throws Exception {\n        //忽略白名单，放行以下路径\n        web.ignoring().antMatchers(URL_WHITELIST);\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //使用jwt，不需要csrf\n        http.csrf()\n                .disable()\n                //基于token不需要session\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                //允许登录访问\n                .and()\n                .authorizeRequests()\n                //.antMatchers(URL_WHITELIST)\n                //.permitAll()\n                //除了上面,所有请求都需要认证\n                .anyRequest()\n                .authenticated()\n                //动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n                //禁用缓存\n                .and()\n                .headers()\n                .cacheControl();\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n        //    添加自定义未授权和未登录结果返回\n        http.exceptionHandling()\n                .accessDeniedHandler(accessDeniedHandler)\n                .authenticationEntryPoint(authenticationEntryPoint);\n\n    }\n```\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\n``` java\n@Override\n    public void configure(WebSecurity web) throws Exception {\n        //忽略白名单，放行以下路径\n        web.ignoring().antMatchers(URL_WHITELIST);\n    }\n```\n可idea控制台又出现了新的问题....\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\n### 于是进行二次修改\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\n\n### 重点方法\n当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\n1. `WebSecurity`\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\n\n2. `HttpSecurity`\n具体的权限控制规则配置\n',1,'',0,1,3,'2022-05-12 14:40:20','2022-05-23 22:55:07'),(84,1,191,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/df9c1307704f20ebaf55d7a0ffffe126.jpg','spring boot security设置忽略地址不生效的解决','## spring boot security设置忽略地址不生效\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\n``` java\n//动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n```\n之后出现的，报错如下\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\n### 最初security主要代码如下：\n这个是忽略地址\n``` java\n  private static final String[] URL_WHITELIST = {\n            \"/login\",\n            \"/logout\",\n            \"/captcha\",\n            \"favicon.ico\",\n            \"/swagger-ui.html/**\",\n            \"/webjars/**\",\n            \"/v2/**\",\n            \"/swagger-resources/**\",\n            \"/doc.html\",\n            \"/upload\"\n    };\n```\nsecurity配置：\n``` java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //使用jwt，不需要csrf\n        http.csrf()\n                .disable()\n                //基于token不需要session\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                //允许登录访问\n                .and()\n                .authorizeRequests()\n                .antMatchers(URL_WHITELIST)\n                .permitAll()\n                //除了上面,所有请求都需要认证\n                .anyRequest()\n                .authenticated()\n                //动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n                //禁用缓存\n                .and()\n                .headers()\n                .cacheControl();\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n        //    添加自定义未授权和未登录结果返回\n        http.exceptionHandling()\n                .accessDeniedHandler(accessDeniedHandler)\n                .authenticationEntryPoint(authenticationEntryPoint);\n\n    }\n```\n### 修改后代码\n\n``` java\n@Override\n    public void configure(WebSecurity web) throws Exception {\n        //忽略白名单，放行以下路径\n        web.ignoring().antMatchers(URL_WHITELIST);\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //使用jwt，不需要csrf\n        http.csrf()\n                .disable()\n                //基于token不需要session\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                //允许登录访问\n                .and()\n                .authorizeRequests()\n                //.antMatchers(URL_WHITELIST)\n                //.permitAll()\n                //除了上面,所有请求都需要认证\n                .anyRequest()\n                .authenticated()\n                //动态权限配置\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n                    @Override\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\n                        object.setAccessDecisionManager(customUrlDecisionManager);\n                        object.setSecurityMetadataSource(customFilter);\n                        return object;\n                    }\n                })\n                //禁用缓存\n                .and()\n                .headers()\n                .cacheControl();\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n        //    添加自定义未授权和未登录结果返回\n        http.exceptionHandling()\n                .accessDeniedHandler(accessDeniedHandler)\n                .authenticationEntryPoint(authenticationEntryPoint);\n\n    }\n```\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\n``` java\n@Override\n    public void configure(WebSecurity web) throws Exception {\n        //忽略白名单，放行以下路径\n        web.ignoring().antMatchers(URL_WHITELIST);\n    }\n```\n可idea控制台又出现了新的问题....\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\n### 于是进行二次修改\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\n**百度所得：**\n- **原因分析**： 自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器。\n- **解决办法**： 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\n\n这里我按照这个方法修改了代码，可还是走了过滤器链...\n具体原因，之后有空再研究一下\n**最终还是选择使用`WebSecurity`配置忽略地址**\n### 总结\n1. 当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\n(1)  . `WebSecurity`\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\n(2). `HttpSecurity`\n具体的权限控制规则配置\n2. 当我们使用依赖注入的方式注入过滤器时,自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器\n- **解决办法**： \n	- 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\n	- **使用WebSecurity配置忽略名单，这里我采用的是这种方式**\n   \n\n\n\n',1,'',0,0,1,'2022-05-12 14:52:44','2022-05-12 23:45:29'),(85,1,191,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2904b329e08607f13e50d22582c9716d.jpg','Spring boot @putmapping接收参数为null解决与理解','## Spring boot @putmapping接收参数为null的问题\n> 今天遇到了前端使用restful风格传参时，后端使用@PutMapping接收参数为null的问题\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/be8d1da446e777455dac66702908edf6.png)\n\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0b51411632a1f17635898ea6273784e5.png)\n\n### 原因\n使用了`public class SwaggerWebMvcConfig extends WebMvcConfigurationSupport`\n``` java\n@Configuration\npublic class SwaggerWebMvcConfig extends WebMvcConfigurationSupport {\n    //WebMvcConfigurationSupport\n    //WebMvcConfigurer\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"swagger-ui.html\")\n                .addResourceLocations(\"classpath:/META-INF/resources/\");\n        registry.addResourceHandler(\"doc.html\").addResourceLocations(\"classpath:/META-INF/resources/\");\n        registry.addResourceHandler(\"/webjars/**\")\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\");\n    }\n}\n```\n### 解决方法\n将原代码修改为\n``` java\n/**\n * swagger mvc配置\n *\n * @author icatw\n * @date 2022/05/05\n */\n@Configuration\npublic class SwaggerWebMvcConfig implements WebMvcConfigurer {\n    //WebMvcConfigurationSupport\n    //WebMvcConfigurer\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"swagger-ui.html\")\n                .addResourceLocations(\"classpath:/META-INF/resources/\");\n        registry.addResourceHandler(\"doc.html\").addResourceLocations(\"classpath:/META-INF/resources/\");\n        registry.addResourceHandler(\"/webjars/**\")\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\");\n    }\n}\n```\n',1,'',0,0,1,'2022-05-12 23:22:37',NULL),(86,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9f14607471ff104a270e5eda1f9ffacc.png','swagger knife4j 解决接口下载文件响应乱码问题','### 问题描述\n> 在使用knife4j测试easyPoi导出Excel接口时出现了乱码问题\n![_G7HFWODPDM35B99.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9f14607471ff104a270e5eda1f9ffacc.png)\n\n### 解决方法：\n\n添加`produces` 属性\n``` java\n  @ApiOperation(value = \"导出员工数据\")\n  @GetMapping(value = \"/export\", produces = \"application/octet-stream\")\n```\n完整代码\n``` java\n    @ApiOperation(value = \"导出员工数据\")\n    @GetMapping(value = \"/export\", produces = \"application/octet-stream\")\n    public void exportEmployee(HttpServletResponse response) {\n        List<Employee> list = employeeService.getEmployee(null);\n        ExportParams params = new ExportParams(\"员工表\", \"员工表\", ExcelType.HSSF);\n        Workbook book = ExcelExportUtil.exportExcel(params, Employee.class, list);\n        ServletOutputStream out = null;\n        try {\n            //流形式\n            response.setHeader(\"content-type\", \"application/octet-stream\");\n            //防止中文乱码\n            response.setHeader(\"content-disposition\", \"attachment;filename=\" +\n                    URLEncoder.encode(\"员工表.xls\", \"UTF-8\"));\n            out = response.getOutputStream();\n            book.write(out);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (null != out) {\n                try {\n                    out.flush();\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```',1,'',0,0,1,'2022-05-14 00:31:33',NULL),(87,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg','springboot实现邮件发送','## springboot集成mail实现邮件发送\n### 引入pom依赖\n``` java\n  	<!--mail 依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-mail</artifactId>\n        </dependency>\n        <!--thymeleaf 依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n\n```\n这里使用thymeleaf作为邮件的html模板\n\n### 添加配置信息\n``` java\nserver:\n  # 端口\n  port: 8082\nspring:\n  # 邮件配置\n  mail:\n    # 邮件服务器地址\n    host: smtp.qq.com\n    # 协议\n    protocol: smtp\n    # 编码格式\n    default-encoding: utf-8\n    # 授权码（在邮箱开通服务时获取）\n    password: qxazsukhylrrbcjd\n    # 发送者邮箱地址\n    username: 762188827@qq.com\n    # 端口（不同邮箱端口号不同）\n    port: 25\n```\n### thymeleaf模板\nmail.html\n``` html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>入职欢迎邮件</title>\n</head>\n<body>\n欢迎 <span th:text=\"${name}\"></span> 加入 云e办 大家庭，您的入职信息如下：\n<table border=\"1\">\n    <tr>\n        <td>姓名</td>\n        <td th:text=\"${name}\"></td>\n    </tr>\n    <tr>\n        <td>职位</td>\n        <td th:text=\"${posName}\"></td>\n    </tr>\n    <tr>\n        <td>职称</td>\n        <td th:text=\"${joblevelName}\"></td>\n    </tr>\n    <tr>\n        <td>部门</td>\n        <td th:text=\"${departmentName}\"></td>\n    </tr>\n</table>\n<p>我们公司的工作忠旨是严格，创新，诚信，您的加入将为我们带来新鲜的血液，带来创新的思维，以及为\n    我们树立良好的公司形象!希望在以后的工作中我们能够齐心协力，与时俱进，团结协作!同时也祝您在本公\n    司，工作愉快，实现自己的人生价值!希望在未来的日子里，携手共进！</p>\n</body>\n</html>\n\n```\n### mail监听器（集成了rabbitMq消息可靠性以及使用redis实现幂等性）\n``` java\npackage cn.icatw.yeb.mail.receiver;\n\nimport cn.icatw.yeb.server.common.Constants.MailConstants;\nimport cn.icatw.yeb.server.domain.Employee;\nimport com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.amqp.support.AmqpHeaders;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.mail.MailProperties;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageHeaders;\nimport org.springframework.stereotype.Component;\nimport org.thymeleaf.TemplateEngine;\nimport org.thymeleaf.context.Context;\n\nimport javax.mail.internet.MimeMessage;\nimport java.io.IOException;\nimport java.util.Date;\n\n/**\n * 邮件接收方\n *\n * @author icatw\n * @date 2022/5/14\n * @email 762188827@qq.com\n * @apiNote\n */\n@Component\n@Slf4j\npublic class MailReceiver {\n    //日志记录，相当于slf4j\n    //private static final Log LOG = LogFactory.getLog(MailReceiver.class);\n    @Autowired\n    private JavaMailSender javaMailSender;\n    @Autowired\n    private MailProperties mailProperties;\n    @Autowired\n    private TemplateEngine templateEngine;\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    /**\n     * 处理程序\n     * 监听rabbitMq发送来的消息（携带员工信息），进行邮件发送\n     *\n     * @param message 消息\n     * @param channel 通道\n     */\n    @RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)\n    public void handler(Message<Employee> message, Channel channel) {\n        //从消息负载中获取员工信息\n        Employee employee = message.getPayload();\n        MessageHeaders headers = message.getHeaders();\n        //消息序号\n        long tag = (long) headers.get(AmqpHeaders.DELIVERY_TAG);\n        String msgId = (String) headers.get(\"spring_returned_message_correlation\");\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        try {\n            if (hashOperations.entries(\"mail_log\").containsKey(msgId)) {\n                //[d, f, 2, 8, e, 7, 9, 0, -, 9, 8, a, e, -, 4, 3, a, c, -, a, e, f, 1, -, 9, 0, 8, 4, c, 0, 5, 2, 7, 5, 8, 9]\n                //    redis中包含key，说明消息已经被消费，手动确认，直接返回\n                log.info(\"消息已经被消费======>{}\", msgId);\n                /**\n                 * 手动确认消息\n                 * tag：消息序号\n                 * multiple：是否多条\n                 */\n                channel.basicAck(tag, false);\n                return;\n            }\n            MimeMessage msg = javaMailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(msg);\n            //设置邮件相关信息\n            //发件人\n            helper.setFrom(mailProperties.getUsername());\n            //收件人\n            helper.setTo(employee.getEmail());\n            //    主题\n            helper.setSubject(\"入职欢迎邮件\");\n            //    发送日期’\n            helper.setSentDate(new Date());\n            //    邮件内容，将员工信息设置到thymeleaf上下文中\n            Context context = new Context();\n            context.setVariable(\"name\", employee.getName());\n            context.setVariable(\"posName\", employee.getPosition().getName());\n            context.setVariable(\"joblevelName\", employee.getJoblevel().getName());\n            context.setVariable(\"departmentName\", employee.getDepartment().getName());\n            String mail = templateEngine.process(\"mail\", context);\n            //将thymeleaf模板内容设置为邮件文本内容\n            helper.setText(mail, true);\n            javaMailSender.send(msg);\n            log.info(\"邮件发送成功！\");\n            //    将消息id存入redis\n            assert msgId != null;\n            hashOperations.put(\"mail_log\", msgId, \"OK\");\n            //    手动确认消息\n            channel.basicAck(tag, false);\n\n        } catch (Exception e) {\n            try {\n                channel.basicNack(tag, false, true);\n            } catch (IOException ex) {\n                log.error(\"消息确认失败=====>{}\", ex.getMessage());\n            }\n            log.error(\"邮件发送失败======>{}\", e.getMessage());\n        }\n    }\n}\n\n```',1,'',0,0,1,'2022-05-18 10:14:27',NULL),(88,1,191,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg','GrantedAuthority错误解决','### 错误描述\n``` java\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of org.springframework.security.core.GrantedAuthority (no Creators, like default constructor, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\n```\n截图：\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0973aa2cfe375a6fa497faff538557ef.png)\n\n\n虽然该类实现了序列化 但是这个集合不能被解析\n\n其实就是在spring security 权限集合反序列化失败\n``` java\n   @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        List<SimpleGrantedAuthority> authorities = new ArrayList<>();\n        for (Role role : roles) {\n            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role.getName());\n            authorities.add(authority);\n        }\n        return authorities;\n    }\n\n```\n这时候我们就需要自定义一个反序列化的类\n``` java\npublic class CustomAuthorityDeserializer extends JsonDeserializer {\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        ObjectMapper mapper = (ObjectMapper) p.getCodec();\n        JsonNode jsonNode = mapper.readTree(p);\n        LinkedList<GrantedAuthority> grantedAuthorities = new LinkedList<>();\n        Iterator<JsonNode> elements = jsonNode.elements();\n        while (elements.hasNext()) {\n            JsonNode next = elements.next();\n            JsonNode authority = next.get(\"authority\");\n            //将得到的值放入链表 最终返回该链表\n            grantedAuthorities.add(new SimpleGrantedAuthority(authority.asText()));\n        }\n        return grantedAuthorities;\n    }\n}\n```\n同时加上一个注解 自定义解析即可生效\n@JsonDeserialize(using = CustomAuthorityDeserializer.class)\n\n    @Override\n    @JsonDeserialize(using = CustomAuthorityDeserializer.class)\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        List<SimpleGrantedAuthority> authorities = new ArrayList<>();\n        for (Role role : roles) {\n            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role.getName());\n            authorities.add(authority);\n        }\n        return authorities;\n    }\n\n',2,'https://blog.csdn.net/weixin_44353507/article/details/113596584',0,0,1,'2022-05-18 12:07:01',NULL),(89,1,NULL,'','云e办项目总结','\n# <center>云e办项目总结\n## 前言\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\n## 项目截图\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bd834fb89b70fbedb46816144282a1f.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\n## 功能模块\n- 员工资料：基本资料、高级资料\n- 人事管理（尚未开发）\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\n- 统计管理（尚未开发）\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\n- websocket在线聊天\n## 项目技术栈\n### 后端技术栈\n1. Spring Boot\n2. Spring Security\n3. Mybatis+Mybatis-Plus\n4. Redis\n5. RabbitMQ\n6. WebSocket\n7. 阿里云oss\n8. mail\n9. ...\n\n### 前端技术栈\n1. Vue\n2. ElementUI\n3. axios\n4. vue-router\n5. Vuex\n6. WebSocket\n7. vue-cli4\n8. ...\n\n## 项目源码\ngitee：https://gitee.com/icatw/cloudEOffice\ngithub：https://github.com/icatw/cloudEOffice\n\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\n',1,'',0,1,3,'2022-05-21 12:34:03','2022-05-23 16:18:06'),(90,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png','云e办项目总结','\n# <center>云e办项目总结\n## 前言\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\n## 项目截图\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bd834fb89b70fbedb46816144282a1f.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\n## 功能模块\n- 员工资料：基本资料、高级资料\n- 人事管理（尚未开发）\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\n- 统计管理（尚未开发）\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\n- websocket在线聊天\n## 项目技术栈\n### 后端技术栈\n1. Spring Boot\n2. Spring Security\n3. Mybatis+Mybatis-Plus\n4. Redis\n5. RabbitMQ\n6. WebSocket\n7. 阿里云oss\n8. mail\n9. ...\n\n### 前端技术栈\n1. Vue\n2. ElementUI\n3. axios\n4. vue-router\n5. Vuex\n6. WebSocket\n7. vue-cli4\n8. ...\n\n## 项目源码\ngitee：https://gitee.com/icatw/cloudEOffice\ngithub：https://github.com/icatw/cloudEOffice\n\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\n',1,'',0,1,1,'2022-05-21 12:38:59','2022-05-23 16:18:06'),(91,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png','云e办项目总结','\n# <center>云e办项目总结\n## 前言\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\n## 项目截图\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/014a015e70db8fedb3a6352bdc4cc22a.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\n## 功能模块\n- 员工资料：基本资料、高级资料\n- 人事管理（尚未开发）\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\n- 统计管理（尚未开发）\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\n- websocket在线聊天\n## 项目技术栈\n### 后端技术栈\n1. Spring Boot\n2. Spring Security\n3. Mybatis+Mybatis-Plus\n4. Redis\n5. RabbitMQ\n6. WebSocket\n7. 阿里云oss\n8. mail\n9. ...\n\n### 前端技术栈\n1. Vue\n2. ElementUI\n3. axios\n4. vue-router\n5. Vuex\n6. WebSocket\n7. vue-cli4\n8. ...\n\n## 项目源码\ngitee：https://gitee.com/icatw/cloudEOffice\ngithub：https://github.com/icatw/cloudEOffice\n\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\n',1,'',0,1,1,'2022-05-21 12:51:57','2022-05-23 16:18:06'),(92,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png','云e办项目总结','\n# <center>云e办项目总结\n## 前言\n本项目基于b站的云e办项目，视频链接：https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web ，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\n## 项目截图\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/014a015e70db8fedb3a6352bdc4cc22a.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\n## 功能模块\n- 员工资料：基本资料、高级资料\n- 人事管理（尚未开发）\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\n- 统计管理（尚未开发）\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\n- websocket在线聊天\n## 项目技术栈\n### 后端技术栈\n1. Spring Boot\n2. Spring Security\n3. Mybatis+Mybatis-Plus\n4. Redis\n5. RabbitMQ\n6. WebSocket\n7. 阿里云oss\n8. mail\n9. ...\n\n### 前端技术栈\n1. Vue\n2. ElementUI\n3. axios\n4. vue-router\n5. Vuex\n6. WebSocket\n7. vue-cli4\n8. ...\n\n## 项目源码\ngitee：https://gitee.com/icatw/cloudEOffice\ngithub：https://github.com/icatw/cloudEOffice\n\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\n',1,'',0,0,1,'2022-05-21 12:53:05','2022-05-23 22:57:14'),(93,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d06d1116d46a3b159734db29dc7e9f6b.png','使用PicGo+阿里云oss+Typora搭建图床','## 使用PicGo+阿里云oss+Typora搭建图床\n\n### 阿里云开通oss服务\n\nhttps://oss.console.aliyun.com/\n\n- 登陆注册阿里云\n- 搜索oss，并且开通\n- 创建Bucket（注意读写权限选择公共读，不然无法显示oss图片）\n\n![image-20220522193238267](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221932391.png)\n\n![image-20220522194541527](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221945613.png)\n\n### 阿里云创建AccessKey子用户\n- 入口为：右上角头像 ->AccessKey管理 -> 开始使用子用户AccessKey\n\n![image-20220522195724210](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221957325.png)\n\n- 勾选Open API 调用访问\n\n![image-20220522200120519](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222001631.png)\n\n- 添加管理对象存储服务（OSS）权限\n\n![](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222002347.png)\n\n- **之后一定要复制下来用户KeyId和KeySecret**（关闭窗口之后无法查看）\n\n### 配置PicGo\n\nPicGo官网：https://picgo.github.io/PicGo-Doc/zh/guide/\n\n- 下载PicGo https://github.com/Molunerfinn/PicGo/releases\n- 配置阿里云oss图床\n\n![image-20220522195341532](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221953599.png)\n\n> 前两个设置为刚刚复制下来的阿里云AccessKey信息\n>\n> 存储空间名设置为 oss的bucket名字\n>\n> 确认存储空间设置为 oss的Endpoint前缀，例如：杭州： oss-cn-hangzhou\n>\n> 指定存储路径设置为 img/  ，一定要加/\n\n### Typora设置\n\n按照下图修改配置即可\n\n![image-20220522200757258](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222007340.png)\n\n完成之后需要重启PicGo和Typora！！\n\n### 可能出现的问题\n\n假如上传图片时出错请修改PicGo配置，如下图\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222009908.png\" alt=\"image-20220522200939845\" style=\"zoom:67%;\" />\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222009195.png\" alt=\"image-20220522200953142\" style=\"zoom:67%;\" />\n\n开启时间戳重命名\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222010719.png\" alt=\"image-20220522201042661\" style=\"zoom:67%;\" />\n\n之后重启测试即可\n\n![image-20220522201114370](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222011444.png)\n\n看到这个结果就可以愉快的使用Typora写博客啦！！',1,'',0,0,1,'2022-05-22 20:14:15',NULL),(94,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e27525d8f199eb6a037ab70e4d29edd2.png','SpringSecurity从入门到精通','# SpringSecurity从入门到精通\n\n## 课程介绍\n\n![image-20211219121555979](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231606106.png)\n\n## 0. 简介\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n② 创建启动类\n\n~~~~java\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n\n![image-20211215094003288](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607396.png)\n\n### 2.2 原理初探\n\n​	想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\n\n\n\n#### 2.2.1 SpringSecurity完整流程\n\n​	SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\n\n![image-20211214144425527](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607397.png)\n\n​	图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\n\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\n\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\n\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\n\n​	\n\n​	我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\n\n![image-20211214145824903](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607398.png)\n\n\n\n\n\n#### 2.2.2 认证流程详解\n\n![image-20211214151515385](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607399.png)\n\n概念速查:\n\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\n\nAuthenticationManager接口：定义了认证Authentication的方法 \n\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\n\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\n\n\n\n\n\n### 2.3 解决问题\n\n#### 2.3.1 思路分析\n\n登录\n\n​	①自定义登录接口  \n\n​				调用ProviderManager的方法进行认证 如果认证通过生成jwt\n\n​				把用户信息存入redis中\n\n​	②自定义UserDetailsService \n\n​				在这个实现类中去查询数据库\n\n校验：\n\n​	①定义Jwt认证过滤器\n\n​				获取token\n\n​				解析token获取其中的userid\n\n​				从redis中获取用户信息\n\n​				存入SecurityContextHolder\n\n#### 2.3.2 准备工作\n\n①添加依赖\n\n~~~~xml\n        <!--redis依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        <!--fastjson依赖-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.33</version>\n        </dependency>\n        <!--jwt依赖-->\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt</artifactId>\n            <version>0.9.0</version>\n        </dependency>\n~~~~\n\n② 添加Redis相关配置\n\n~~~~java\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\n{\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n    private Class<T> clazz;\n\n    static\n    {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    }\n\n    public FastJsonRedisSerializer(Class<T> clazz)\n    {\n        super();\n        this.clazz = clazz;\n    }\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    {\n        if (t == null)\n        {\n            return new byte[0];\n        }\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    }\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    {\n        if (bytes == null || bytes.length <= 0)\n        {\n            return null;\n        }\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    }\n\n\n    protected JavaType getJavaType(Class<?> clazz)\n    {\n        return TypeFactory.defaultInstance().constructType(clazz);\n    }\n}\n~~~~\n\n~~~~java\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    @SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\n    {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n~~~~\n\n③ 响应类\n\n~~~~java\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult<T> {\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public ResponseResult(Integer code, T data) {\n        this.code = code;\n        this.data = data;\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public void setData(T data) {\n        this.data = data;\n    }\n\n    public ResponseResult(Integer code, String msg, T data) {\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    }\n}\n~~~~\n\n④工具类\n\n~~~~java\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil {\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = \"sangeng\";\n\n    public static String getUUID(){\n        String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        return token;\n    }\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) {\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null){\n            ttlMillis=JwtUtil.JWT_TTL;\n        }\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(\"sg\")     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    }\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\";\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    }\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() {\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\n        return key;\n    }\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception {\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    }\n\n\n}\n~~~~\n\n~~~~java\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n@Component\npublic class RedisCache\n{\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public <T> void setCacheObject(final String key, final T value)\n    {\n        redisTemplate.opsForValue().set(key, value);\n    }\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    {\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    {\n        return expire(key, timeout, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    {\n        return redisTemplate.expire(key, timeout, unit);\n    }\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> T getCacheObject(final String key)\n    {\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    }\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    {\n        return redisTemplate.delete(key);\n    }\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    {\n        return redisTemplate.delete(collection);\n    }\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public <T> long setCacheList(final String key, final List<T> dataList)\n    {\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    }\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> List<T> getCacheList(final String key)\n    {\n        return redisTemplate.opsForList().range(key, 0, -1);\n    }\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\n    {\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\n        Iterator<T> it = dataSet.iterator();\n        while (it.hasNext())\n        {\n            setOperation.add(it.next());\n        }\n        return setOperation;\n    }\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public <T> Set<T> getCacheSet(final String key)\n    {\n        return redisTemplate.opsForSet().members(key);\n    }\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\n    {\n        if (dataMap != null) {\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        }\n    }\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public <T> Map<String, T> getCacheMap(final String key)\n    {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\n    {\n        redisTemplate.opsForHash().put(key, hKey, value);\n    }\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public <T> T getCacheMapValue(final String key, final String hKey)\n    {\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    }\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    {\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    }\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\n    {\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    }\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection<String> keys(final String pattern)\n    {\n        return redisTemplate.keys(pattern);\n    }\n}\n~~~~\n\n~~~~java\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n{\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) {\n        try\n        {\n            response.setStatus(200);\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            response.getWriter().print(string);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n~~~~\n\n⑤实体类\n\n~~~~java\nimport java.io.Serializable;\nimport java.util.Date;\n\n\n/**\n * 用户表(User)实体类\n *\n * @author 三更\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n    private static final long serialVersionUID = -40356785423868312L;\n    \n    /**\n    * 主键\n    */\n    private Long id;\n    /**\n    * 用户名\n    */\n    private String userName;\n    /**\n    * 昵称\n    */\n    private String nickName;\n    /**\n    * 密码\n    */\n    private String password;\n    /**\n    * 账号状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 邮箱\n    */\n    private String email;\n    /**\n    * 手机号\n    */\n    private String phonenumber;\n    /**\n    * 用户性别（0男，1女，2未知）\n    */\n    private String sex;\n    /**\n    * 头像\n    */\n    private String avatar;\n    /**\n    * 用户类型（0管理员，1普通用户）\n    */\n    private String userType;\n    /**\n    * 创建人的用户id\n    */\n    private Long createBy;\n    /**\n    * 创建时间\n    */\n    private Date createTime;\n    /**\n    * 更新人\n    */\n    private Long updateBy;\n    /**\n    * 更新时间\n    */\n    private Date updateTime;\n    /**\n    * 删除标志（0代表未删除，1代表已删除）\n    */\n    private Integer delFlag;\n}\n~~~~\n\n\n\n#### 2.3.3 实现\n\n##### 2.3.3.1 数据库校验用户\n\n​	从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\n\n###### 准备工作\n\n​	我们先创建一个用户表， 建表语句如下：\n\n~~~~mysql\nCREATE TABLE `sys_user` (\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\n~~~~\n\n​		引入MybatisPuls和mysql驱动的依赖\n\n~~~~xml\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.4.3</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n~~~~\n\n​		配置数据库信息\n\n~~~~yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n~~~~\n\n​		定义Mapper接口\n\n~~~~java\npublic interface UserMapper extends BaseMapper<User> {\n}\n~~~~\n\n​		修改User实体类\n\n~~~~java\n类名上加@TableName(value = \"sys_user\") ,id字段上加 @TableId\n~~~~\n\n​		配置Mapper扫描\n\n~~~~java\n@SpringBootApplication\n@MapperScan(\"com.sangeng.mapper\")\npublic class SimpleSecurityApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\n        System.out.println(run);\n    }\n}\n~~~~\n\n​		添加junit依赖\n\n~~~~java\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n        </dependency>\n~~~~\n\n​	   测试MP是否能正常使用\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@SpringBootTest\npublic class MapperTest {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void testUserMapper(){\n        List<User> users = userMapper.selectList(null);\n        System.out.println(users);\n    }\n}\n~~~~\n\n\n\n###### 核心代码实现\n\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        //根据用户名查询用户信息\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        //如果查询不到数据就通过抛出异常来给出提示\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        \n        //封装成UserDetails对象返回 \n        return new LoginUser(user);\n    }\n}\n~~~~\n\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\n\n```java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private User user;\n\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUserName();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n```\n\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如\n\n![image-20211216123945882](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607400.png)\n\n这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。\n\n\n\n##### 2.3.3.2 密码加密存储\n\n​	实际项目中我们不会把密码明文存储在数据库中。\n\n​	默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\n\n​	我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\n\n​	我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\n\n​	我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n}\n~~~~\n\n##### 2.3.3.3 登陆接口\n\n​	接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\n\n​	在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\n\n​	认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\n\n~~~~java\n@RestController\npublic class LoginController {\n\n    @Autowired\n    private LoginServcie loginServcie;\n\n    @PostMapping(\"/user/login\")\n    public ResponseResult login(@RequestBody User user){\n        return loginServcie.login(user);\n    }\n}\n\n~~~~\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n~~~~\n\n​	\n\n~~~~java\n@Service\npublic class LoginServiceImpl implements LoginServcie {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap<String,String> map = new HashMap<>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    }\n}\n\n~~~~\n\n\n\n##### 2.3.3.4 认证过滤器\n\n​	我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\n\n​	使用userid去redis中获取对应的LoginUser对象。\n\n​	然后封装Authentication对象存入SecurityContextHolder\n\n\n\n~~~~java\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        //获取token\n        String token = request.getHeader(\"token\");\n        if (!StringUtils.hasText(token)) {\n            //放行\n            filterChain.doFilter(request, response);\n            return;\n        }\n        //解析token\n        String userid;\n        try {\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"token非法\");\n        }\n        //从redis中获取用户信息\n        String redisKey = \"login:\" + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser)){\n            throw new RuntimeException(\"用户未登录\");\n        }\n        //存入SecurityContextHolder\n        //TODO 获取权限信息封装到Authentication中\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    }\n}\n~~~~\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n\n    @Autowired\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //把token校验过滤器添加到过滤器链中\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n\n~~~~\n\n\n\n##### 2.3.3.5 退出登陆\n\n​	我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class LoginServiceImpl implements LoginServcie {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap<String,String> map = new HashMap<>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    }\n\n    @Override\n    public ResponseResult logout() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        Long userid = loginUser.getUser().getId();\n        redisCache.deleteObject(\"login:\"+userid);\n        return new ResponseResult(200,\"退出成功\");\n    }\n}\n\n~~~~\n\n\n\n\n\n## 3. 授权\n\n### 3.0 权限系统的作用\n\n​	例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\n\n​	总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\n\n​	我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\n\n​	所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\n\n​	\n\n### 3.1 授权基本流程\n\n​	在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\n\n​	所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\n\n​	然后设置我们的资源所需要的权限即可。\n\n### 3.2 授权实现\n\n#### 3.2.1 限制访问资源所需权限\n\n​	SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\n\n​	但是要使用它我们需要先开启相关配置。\n\n~~~~java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n~~~~\n\n​	然后就可以使用对应的注解。@PreAuthorize\n\n~~~~java\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    @PreAuthorize(\"hasAuthority(\'test\')\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n~~~~\n\n#### 3.2.2 封装权限信息\n\n​	我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\n\n​	我们先直接把权限信息写死封装到UserDetails中进行测试。\n\n​	我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\n\n~~~~java\npackage com.sangeng.domain;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Data\n@NoArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private User user;\n        \n    //存储权限信息\n    private List<String> permissions;\n    \n    \n    public LoginUser(User user,List<String> permissions) {\n        this.user = user;\n        this.permissions = permissions;\n    }\n\n\n    //存储SpringSecurity所需要的权限信息的集合\n    @JSONField(serialize = false)\n    private List<GrantedAuthority> authorities;\n\n    @Override\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\n        if(authorities!=null){\n            return authorities;\n        }\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\n        authorities = permissions.stream().\n                map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUserName();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n~~~~\n\n​		LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\n\n~~~~java\npackage com.sangeng.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\nimport com.sangeng.domain.LoginUser;\nimport com.sangeng.domain.User;\nimport com.sangeng.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        List<String> list = new ArrayList<>(Arrays.asList(\"test\"));\n        return new LoginUser(user,list);\n    }\n}\n\n~~~~\n\n\n\n#### 3.2.3 从数据库查询权限信息\n\n##### 3.2.3.1 RBAC权限模型\n\n​	RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\n\n​	![image-20211222110249727](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607401.png)\n\n##### 3.2.3.2 准备工作\n\n~~~~sql\n\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\n\nUSE `sg_security`;\n\n/*Table structure for table `sys_menu` */\n\nDROP TABLE IF EXISTS `sys_menu`;\n\nCREATE TABLE `sys_menu` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\n  `create_by` bigint(20) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(20) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\n\n/*Table structure for table `sys_role` */\n\nDROP TABLE IF EXISTS `sys_role`;\n\nCREATE TABLE `sys_role` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) DEFAULT NULL,\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\n  `create_by` bigint(200) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(200) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\n\n/*Table structure for table `sys_role_menu` */\n\nDROP TABLE IF EXISTS `sys_role_menu`;\n\nCREATE TABLE `sys_role_menu` (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\n  PRIMARY KEY (`role_id`,`menu_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n/*Table structure for table `sys_user` */\n\nDROP TABLE IF EXISTS `sys_user`;\n\nCREATE TABLE `sys_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\n\n/*Table structure for table `sys_user_role` */\n\nDROP TABLE IF EXISTS `sys_user_role`;\n\nCREATE TABLE `sys_user_role` (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\n  PRIMARY KEY (`user_id`,`role_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n~~~~\n\n~~~~mysql\nSELECT \n	DISTINCT m.`perms`\nFROM\n	sys_user_role ur\n	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\n	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\n	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\nWHERE\n	user_id = 2\n	AND r.`status` = 0\n	AND m.`status` = 0\n~~~~\n\n\n\n\n\n\n\n~~~~java\npackage com.sangeng.domain;\n\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * 菜单表(Menu)实体类\n *\n * @author makejava\n * @since 2021-11-24 15:30:08\n */\n@TableName(value=\"sys_menu\")\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class Menu implements Serializable {\n    private static final long serialVersionUID = -54979041104113736L;\n    \n        @TableId\n    private Long id;\n    /**\n    * 菜单名\n    */\n    private String menuName;\n    /**\n    * 路由地址\n    */\n    private String path;\n    /**\n    * 组件路径\n    */\n    private String component;\n    /**\n    * 菜单状态（0显示 1隐藏）\n    */\n    private String visible;\n    /**\n    * 菜单状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 权限标识\n    */\n    private String perms;\n    /**\n    * 菜单图标\n    */\n    private String icon;\n    \n    private Long createBy;\n    \n    private Date createTime;\n    \n    private Long updateBy;\n    \n    private Date updateTime;\n    /**\n    * 是否删除（0未删除 1已删除）\n    */\n    private Integer delFlag;\n    /**\n    * 备注\n    */\n    private String remark;\n}\n~~~~\n\n\n\n##### 3.2.3.3 代码实现\n\n​	我们只需要根据用户id去查询到其所对应的权限信息即可。\n\n​	所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\n\n~~~~java\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.sangeng.domain.Menu;\n\nimport java.util.List;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\npublic interface MenuMapper extends BaseMapper<Menu> {\n    List<String> selectPermsByUserId(Long id);\n}\n~~~~\n\n​	尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\n\n~~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.sangeng.mapper.MenuMapper\">\n\n\n    <select id=\"selectPermsByUserId\" resultType=\"java.lang.String\">\n        SELECT\n            DISTINCT m.`perms`\n        FROM\n            sys_user_role ur\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\n        WHERE\n            user_id = #{userid}\n            AND r.`status` = 0\n            AND m.`status` = 0\n    </select>\n</mapper>\n~~~~\n\n​	在application.yml中配置mapperXML文件的位置\n\n~~~~yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath*:/mapper/**/*.xml \n\n~~~~\n\n\n\n​	然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private MenuMapper menuMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\n//        //测试写法\n//        List<String> list = new ArrayList<>(Arrays.asList(\"test\"));\n        return new LoginUser(user,permissionKeyList);\n    }\n}\n~~~~\n\n\n\n\n\n## 4. 自定义失败处理\n\n​	我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\n\n​	在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\n\n​	如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\n\n​	如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\n\n​	所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\n\n\n\n①自定义实现类\n\n~~~~java\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \"权限不足\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n\n    }\n}\n\n~~~~\n\n~~~~java\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \"认证失败请重新登录\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    }\n}\n\n~~~~\n\n\n\n\n\n②配置给SpringSecurity\n\n​	\n\n​	先注入对应的处理器\n\n~~~~java\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n~~~~\n\n​	然后我们可以使用HttpSecurity对象的方法去配置。\n\n~~~~java\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\n                accessDeniedHandler(accessDeniedHandler);\n~~~~\n\n\n\n## 5. 跨域\n\n​	浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \n\n​	前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\n\n​	所以我们就要处理一下，让前端能进行跨域请求。\n\n①先对SpringBoot配置，运行跨域请求\n\n~~~~java\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n      // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(3600);\n    }\n}\n~~~~\n\n②开启SpringSecurity的跨域访问\n\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\n\n~~~~java\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    }\n\n~~~~\n\n\n\n\n\n## 6. 遗留小问题\n\n### 其它权限校验方法\n\n​	我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\n\n​    \n\n​	这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\n\n​	hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\n\n​	它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\n\n\n\n​	hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\n\n~~~~java\n    @PreAuthorize(\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n​	hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n~~~~java\n    @PreAuthorize(\"hasRole(\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n​	hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n~~~~java\n    @PreAuthorize(\"hasAnyRole(\'admin\',\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n\n\n### 自定义权限校验方法\n\n​	我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\n\n~~~~java\n@Component(\"ex\")\npublic class SGExpressionRoot {\n\n    public boolean hasAuthority(String authority){\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List<String> permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    }\n}\n~~~~\n\n​	 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\n\n~~~~java\n    @RequestMapping(\"/hello\")\n    @PreAuthorize(\"@ex.hasAuthority(\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n### 基于配置的权限控制\n\n​	我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\n\n~~~~java\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                .antMatchers(\"/testCors\").hasAuthority(\"system:dept:list222\")\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    }\n~~~~\n\n\n\n\n\n\n\n### CSRF\n\n​	CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\n\n​	https://blog.csdn.net/freeking101/article/details/86537087\n\n​	SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\n\n​	我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\n\n\n\n\n\n### 认证成功处理器\n\n​	实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\n\n​	我们也可以自己去自定义成功处理器进行成功后的相应处理。\n\n~~~~java\n@Component\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        System.out.println(\"认证成功了\");\n    }\n}\n\n~~~~\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin().successHandler(successHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n\n~~~~\n\n\n\n### 认证失败处理器\n\n​	实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\n\n​	我们也可以自己去自定义失败处理器进行失败后的相应处理。\n\n~~~~java\n@Component\npublic class SGFailureHandler implements AuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        System.out.println(\"认证失败了\");\n    }\n}\n~~~~\n\n\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n\n~~~~\n\n\n\n### 登出成功处理器\n\n~~~~java\n@Component\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        System.out.println(\"注销成功\");\n    }\n}\n\n~~~~\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Autowired\n    private LogoutSuccessHandler logoutSuccessHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.logout()\n                //配置注销成功处理器\n                .logoutSuccessHandler(logoutSuccessHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n~~~~\n\n\n\n\n\n### 其他认证方案畅想\n\n\n\n\n\n## 7. 源码讲解\n\n​	\n> 转自b站三更草堂的springsecurity教程，资料源码地址： [资料地址](https://gitee.com/icatw/SpringSecurity)\n',1,'',0,0,1,'2022-05-23 16:16:28','2022-05-23 16:17:51'),(95,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f1c14ed0da37b3391cac387a88d64a66.jpg','docker安装mysql8.0','# docker安装mysql8.0\n\n> 这里使用虚拟机安装测试\n\n## docker中下载mysql最新版\n\n``` shell\ndocker pull mysql\n```\n\n![image-20220523221026511](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232210963.png)\n\n## 启动\n\n``` shell\ndocker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n```\n\n命令说明：\n\n- --name： 指定容器名字（名称唯一）\n- -p：指定容器暴露端口\n- -d：后台运行容器\n\n启动成功之后可通过`docker ps`命令查看\n\n![image-20220523222137904](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232221222.png)\n\n## 进入容器\n\n```shell\ndocker exec -it mysql bash\n```\n\n![image-20220523222311324](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232223624.png)\n\n登录mysql\n\n```sql\nmysql -u root -p\n```\n\n之后输入自己的密码：eg：123456（**Linux命令行是看不到自己输入的密码的**）\n\n![image-20220523222600694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232226997.png)\n\n登录mysql成功之后就可以正常的使用sql命令啦\n\n## 退出容器\n\n- 先使用`exit`退出mysql\n\n- 再使用一次`exit`退出mysql容器\n\n![image-20220523223110417](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232231715.png)\n\n## 本地测试连接虚拟机mysql\n\n- 打开Navicat\n\n- 新建mysql连接，左上角-> 连接，选择MySQL\n\n  ![image-20220523223209937](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232232005.png)\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232233950.png\" alt=\"image-20220523223328888\" style=\"zoom: 50%;\" />\n\n- 配置连接信息\n  - 连接名：自己定义\n  - 主机：虚拟机ip\n  - 端口号：默认3306\n  - 用户名：默认root\n  - 密码：mysql密码\n- 测试连接\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232235639.png\" alt=\"image-20220523223521571\" style=\"zoom:50%;\" />\n\n## 成功！\n\n![image-20220523223732358](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232237390.png)\n\n到此就可以在本机操作虚拟机中docker的mysql了\n\n',1,'',0,0,1,'2022-05-23 22:48:35','2022-05-23 22:49:53'),(96,1,NULL,'','MySQL学习【基础篇】','# MySQL学习基础篇\n\n## 1. SQL\n\n**全称 Structured Query Language，结构化查询语言**。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。\n\n### 1.1 SQL通用语法\n\n- SQL语句可以单行或者多行书写，以分号结尾。\n- SQL语句可以使用空格/缩进来增强语句的可读性。\n- MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n- 注释\n    - 单行注释：-- 注释内容 或 # 注释内容\n    - 多行注释： /* 注释内容 */\n\n### 1.2 SQL分类\n\nSQL语句，根据其功能，主要分为四类：**DDL、DML、DQL、DCL**。\n\n| 分类 | 全称                        | 说明                                                    |\n| ---- | --------------------------- | :------------------------------------------------------ |\n| DDL  | Data Definition Language    | 数据定义语言，用来定义数据库对象(数据库，表， 字段)     |\n| DML  | Data Manipuulation Language | 数据操作语言，用来对数据库表中的数据进行增删改          |\n| DQL  | Data Query Language         | 数据查询语言，用来查询数据库中表的记录                  |\n| DCL  | Data Control Language       | 数据控制语言，用来创建数据库用户、控制数据库的 访问权限 |\n\n### 1.3 DDL\n\n> **Data Definition Language，数据定义语言，用来定义数据库对象（数据库、表、字段）**\n\n#### 1.3.1 数据库操作\n\n这里我们直接使用可视化数据库工具Navicat演示命令\n\n- 查询所有数据库\n\n``` sql\nshow databases;\n```\n\n![image-20220523234102071](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232341162.png)\n\n- 查询当前数据库\n\n``` sql\nselect database()\n```\n\n- 创建数据库\n\n``` sql\ncreate database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;\n```\n\n>  注：[ ] 中的值为可选项，default代表有默认值\n\n案例：\n\nA. 创建一个icatw数据库，使用数据库默认的字符集。\n\n``` sql\nCREATE DATABASE icatw;\n```\n\n![image-20220523234756349](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232347399.png)\n\n在同一个数据库服务器中，数据库名不可重复，必须唯一，否则将会报错。\n\n![image-20220523234950307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232349389.png)\n\n可以通过 `` if not exists``（如果不存在）参数来解决这个问题，只有是当数据库名不存在时，才会进行创建。\n\n``` sql\nCREATE DATABASE IF NOT EXISTS icatw;\n```\n\n![image-20220523235235940](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232352985.png)\n\nB.创建一个icat数据库，并且指定字符集\n\n``` sql\n-- 创建icat数据库并指定utf8mb4为默认数据库\nCREATE DATABASE icat DEFAULT CHARSET utf8mb4;\n```\n\nutf8mb4比utf8支持更多字符，\n\n**utf8mb4支持最大4个字节的字符，而utf8最大只支持3个字节的字符，现在一般都使用utf8mb4作为mysql默认字符集**\n\n- 删除数据库\n\n``` sql\n-- 删除数据库icat(如果存在)\nDROP DATABASE IF EXISTS icat;\n```\n\n如果不加上 if exists 的话，数据库不存在则会报错;\n\n- 切换数据库\n\n``` sql\nUSE icatw;\n```\n\n当我们需要操作某个数据库下的表时必须先切换到对应数据库\n\n#### 1.3.2 表操作\n\n对表的操作需要先使用`USE 数据库表`切换到对应数据库\n\n##### 1.3.2.1 表操作-查询创建\n\n1）. 查询当前数据库所有表\n\n查询表需要先使用 `USE 数据库名`切换数据库\n\n例:\n\n``` sql\n-- 查询当前数据库下的所有表\nUSE sys;\nSHOW TABLES;\n```\n\n![image-20220524084459677](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240845244.png)\n\n2）. 查看指定表结构\n\n``` sql\ndesc 表名\n```\n\n3）. 查询指定表的建表语句\n\n``` sql\n-- 查询指定表的建表语句\nSHOW CREATE TABLE sys_config;\n```\n\n![image-20220524085039027](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240850135.png)\n\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\n\n4）. 创建表结构\n\n``` sql\nCREATE TABLE 表名(\n字段1 字段1类型 [ COMMENT 字段1注释 ],\n字段2 字段2类型 [COMMENT 字段2注释 ],\n字段3 字段3类型 [COMMENT 字段3注释 ],\n......\n字段n 字段n类型 [COMMENT 字段n注释 ]\n) [ COMMENT 表注释 ] ;\n\n```\n\n例: 创建一张表tb_user，对应的结构如下\n\n|  id  |   name   | age  | gender |\n| :--: | :------: | :--: | :----: |\n|  1   |  令狐冲  |  28  |   男   |\n|  2   |  风清扬  |  32  |   男   |\n|  3   | 东方不败 |  34  |   男   |\n\n那么建表语句为：\n\n``` sql\n-- 创建表结构\nUSE icatw;\nCREATE TABLE tb_user(\nid INT COMMENT 主键id,\nname VARCHAR(50) COMMENT 名字,\nage INT COMMENT 年龄,\ngender VARCHAR(1) 性别\n)COMMENT 用户表 ;\n```\n\n##### 1.3.2.2 表操作-数据类型\n\nMySQL中的数据类型有很多，主要分为三类：**数值类型、字符串类型、日期时间类型**\n\n1）. 数值类型\n\n| 类型        | 大小   | 有符号(SIGNED)范围                                     | 无符号(UNSIGNED)范围                                       | 描述                  |\n| ----------- | ------ | ------------------------------------------------------ | ---------------------------------------------------------- | --------------------- |\n| TINYINT     | 1byte  | (-128，127)                                            | (0，255)                                                   | 小整 数值             |\n| SMALLINT    | 2bytes | (-32768，32767)                                        | (0，65535)                                                 | 大整 数值             |\n| MEDIUMINT   | 3bytes | (-8388608，8388607)                                    | (0，16777215)                                              | 大整 数值             |\n| INT/INTEGER | 4bytes | (-2147483648， 2147483647)                             | (0，4294967295)                                            | 大整 数值             |\n| BIGINT      | 8bytes | (-2^63，2^63-1)                                        | (0，2^64-1)                                                | 极大 整数 值          |\n| FLOAT       | 4bytes | (-3.402823466 E+38， 3.402823466351 E+38)              | 0 和 (1.175494351 E38，3.402823466 E+38)                   | 单精 度浮 点数 值     |\n| DOUBLE      | 8bytes | (-1.7976931348623157 E+308， 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308) | 双精 度浮 点数 值     |\n| DECIMAL     |        | 依赖于M(精度)和D(标度) 的值                            | 依赖于M(精度)和D(标度)的 值                                | 小数 值(精 确定 点数) |\n\n``` tex\n如:\n1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大\nage tinyint unsigned\n2). 分数 -- 总分100分, 最多出现一位小数\nscore double(4,1)\n通常使用DECIMAL 存储货币、钱\n```\n\n2）. 字符串类型\n\n|    类型  |   大小   | 描述 |\n| ---- | ---- | ---- |\n| CHAR | 0-255 bytes | 定长字符串(需要指定长度) |\n| VARCHAR | 0-65535 bytes | 变长字符串(需要指定长度) |\n| TINYBLOB | 0-255 bytes | 不超过255个字符的二进制数据 |\n| TINYTEXT | 0-255 bytes | 短文本字符串 |\n| BLOB | 0-65535 bytes | 二进制形式的长文本数据 |\n| TEXT | 0-65535 bytes | 长文本数据 |\n| MEDIUMBLOB | 0-16777215 bytes | 二进制形式的中等长度文本数据 |\n| MEDIUMTEXT | 0-16777215 bytes | 中等长度文本数据 |\n| LONGBLOB | 0-4 294 967 295 bytes | 二进制形式的极大文本数据 |\n| LONGTEXT | 0-4 294 967 295 bytes | 极大文本数据 |\n\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。\n\n``` tex\n如：\n1). 用户名 username ------> 长度不定, 最长不会超过50\nusername varchar(50)\n2). 性别 gender ---------> 存储值, 不是男,就是女\ngender char(1)\n3). 手机号 phone --------> 固定长度为11\nphone char(11)\n\n```\n\n3） . 日期时间类型\n\n| 类型      | 大 小 | 范围                                       | 格式                | 描述                      |\n| --------- | ----- | ------------------------------------------ | ------------------- | ------------------------- |\n| DATE      | 3     | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                    |\n| TIME      | 3     | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续 时间         |\n| YEAR      | 1     | 1901 至 2155                               | YYYY                | 年份值                    |\n| DATETIME  | 8     | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值         |\n| TIMESTAMP | 4     | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值，时间戳 |\n\n``` tex\n如:\n    1). 生日字段 birthday\n    birthday date\n    2). 创建时间 createtime\n    createtime datetime\n```\n\n##### 1.3.2.3 表操作-案例\n\n> 设计一张员工信息表，要求如下：\n>\n> 1. 编号（纯数字）\n> 2. 员工工号 (字符串类型，长度不超过10位)\n> 3. 员工姓名（字符串类型，长度不超过10位） \n> 4. 性别（男/女，存储一个汉字） \n> 5. 年龄（正常人年龄，不可能存储负数） \n> 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符） \n> 7. 入职时间（取值年月日即可）\n\n对应的建表语句如下：\n\n``` sql\ncreate table emp(\n    id int comment \'编号\',\n    workno varchar(10) comment \'工号\',\n    name varchar(10) comment \'姓名\',\n    gender char(1) comment \'性别\',\n    age tinyint unsigned comment \'年龄\',\n    idcard char(18) comment \'身份证号\',\n    entrydate date comment \'入职时间\'\n) comment \'员工表\';\n```\n\n建表之后可通过 `desc emp`查看员工表结构\n\n![image-20220524093825055](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240938173.png)\n\n至此，员工表就已经创建好了，当我们指定了字段的最大长度之后，超出最大长度将会报错。\n\n##### 1.3.2.4 表操作-修改\n\n1）. 添加字段\n\n``` sql\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\n```\n\n案例:\n\n为emp表增加一个新的字段\"昵称\"为nickname，类型为varchar(20)\n\n``` sql\n-- 添加字段\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT \'昵称\';\n```\n\n2）. 修改数据类型\n\n``` sql\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)\n```\n\n3）. 修改字段名和字段类型\n\n``` sql\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];\n```\n\n案例:\n\n将emp表的nickname字段修改为username,类型为varchar(30)\n\n``` sql\n-- 将emp表的nickname字段修改为username,类型为varchar(30)\nALTER TABLE emp CHANGE nickname username VARCHAR(30) COMMENT \'用户名\';\n```\n\n4）. 删除字段\n\n``` sql\nALTER TABLE 表名 DROP 字段名;\n```\n\n``` sql\n-- 删除emp表中的username\nALTER TABLE emp DROP username;\n```\n\n5）. 修改表名\n\n``` sql\nALTER TABLE 表名 RENAME TO 新表名;\n```\n\n案例:\n\n将emp表的表名修改为employee\n\n``` sql\n-- 修改表名ALTER TABLE 表名 RENAME TO 新表名;\nALTER  TABLE emp RENAME TO employee;\n```\n\n**总结:**\n\n​	**对表的修改操作通用格式为**:` ALTER TABLE 表名 操作名(ADD,MODIFY,CHANGE,DROP,RENAME TO)`\n\n##### 1.3.2.5 表操作-删除\n\n1）. 删除表\n\n``` sql\nDROP TABLE [IF EXISTS] 表名;\n```\n\n可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。\n\n案例: \n\n如果tb_user表存在，则删除tb_user表\n\n``` sql\nDROP TABLE IF EXISTS tb_user;\n```\n\n2）. 删除指定表，并重新创建表\n\n``` sql\nTRUNCATE TABLE 表名;\n```\n\n> 我的理解是 相当于清空数据，新建的表结构并不会发生变化\n\n### 1.4 图形化界面工具\n\nidea、Navicat\n\n这里我们使用idea的自带的数据库操作工具学习\n\n### 1.5 DML\n\n>  **DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作**。\n\n- 添加数据（INSERT） \n- 修改数据（UPDATE） \n- 删除数据（DELETE）\n\n#### 1.5.1 添加数据\n\n1）. 给指定字段添加数据\n\n``` sql\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\n```\n\n案例：给employee表所有的字段添加数据 ；\n\n```sql\n# 插入数据\ninsert into employee (id, workno, name, gender, age, idcard, entrydate)\nvalues (1,\'1\',\'icatw\',\'男\',18,\'431088200205180463\',\'2002-05-22\');\n```\n\n插入数据完成之后有两种方式查询数据库的数据\n\nA. 方式一\n\n在表名上双击，就可以看到这张表的数据。\n\n![image-20220524124505124](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205241245329.png)\n\nB. 方式二\n\n直接使用查询的SQL语句\n\n``` sql\nselect * from employee;\n```\n\n2）. 给全部字段添加数据\n\n``` sql\nINSERT INTO 表名 VALUES (值1, 值2, ...);\n```\n\n案例：给employee表的所有字段添加数据\n\n``` sql\n# 给所有字段添加数据\ninsert into employee values (2, \'2\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'2005-01-01\');\n```\n\n3）. 批量添加数据\n\n``` sql\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\n```\n\n``` sql\nINSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\n```\n\n案例：批量插入数据到employee表\n\n``` sql\ninsert into employee values(3,\'3\',\'韦一笑\',\'男\',38,\'123456789012345670\',\'2005-01-01\'),(4,\'4\',\'赵敏\',\'女\',18,\'123456789012345670\',\'2005-01-01\');\n\n```\n\n> 注意事项：\n>\n> - 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n> - 字符串和日期型数据应该包含在引号中。\n> - 插入的数据大小，应该在字段的规定范围内，不能超过最大值。\n\n#### 1.5.2 修改数据\n\n修改数据的具体语法为：\n\n```sql\nUPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;\n```\n\n**如果不指定where条件将修改所有行**\n\n案例：\n\nA. 修改id为1的数据，将那么修改为icatw2\n\n``` sql\nupdate employee set name=\'icatw2\' where id=1;\n```\n\nB. 修改id为1的数据，将name修改为小昭，gender修改为女\n\n``` sql\nupdate employee set name=\'小昭\' ,gender=\'女\' where id=1;\n```\n\nC. 将所有员工的入职日期修改为2008-01-01\n\n``` sql\nupdate employee set entrydate=\'2008-01-01\'\n```\n\n> 注意事项：\n>\n> ​		**修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。**\n\n#### 1.5.3 删除数据\n\n语法：\n\n``` sql\ndelete from 表名 [where 条件];\n```\n\n案例：\n\nA. 删除gender为女的员工\n\n``` sql\ndelete from employee where gender=\'女\';\n```\n\nB. 删除所有员工\n\n``` sql\ndelete from employee\n```\n\n> 注意事项: \n>\n> - DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。\n> - DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n> - 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击 Execute即可。\n\n\n\n### 1.6 DDL\n\n> **DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。** \n\n查询关键字: **SELECT** \n\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站， 在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\n\n首先我们准备数据\n\n``` sql\n# 添加数据\ndrop table if exists employee;\ncreate table emp\n(\n    id          int comment \'编号\',\n    workno      varchar(10) comment \'工号\',\n    name        varchar(10) comment \'姓名\',\n    gender      char(1) comment \'性别\',\n    age         tinyint unsigned comment \'年龄\',\n    idcard      char(18) comment \'身份证号\',\n    workaddress varchar(50) comment \'工作地址\',\n    entrydate   date comment \'入职时间\'\n) comment \'员工表\';\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (1, \'00001\', \'柳岩666\', \'女\', 20, \'123456789012345678\', \'北京\', \'2000-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (2, \'00002\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'北京\', \'2005-09-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (3, \'00003\', \'韦一笑\', \'男\', 38, \'123456789712345670\', \'上海\', \'2005-08-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (4, \'00004\', \'赵敏\', \'女\', 18, \'123456757123845670\', \'北京\', \'2009-12-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (5, \'00005\', \'小昭\', \'女\', 16, \'123456769012345678\', \'上海\', \'2007-07-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (6, \'00006\', \'杨逍\', \'男\', 28, \'12345678931234567X\', \'北京\', \'2006-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (7, \'00007\', \'范瑶\', \'男\', 40, \'123456789212345670\', \'北京\', \'2005-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (8, \'00008\', \'黛绮丝\', \'女\', 38, \'123456157123645670\', \'天津\', \'2015-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (9, \'00009\', \'范凉凉\', \'女\', 45, \'123156789012345678\', \'北京\', \'2010-04-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (10, \'00010\', \'陈友谅\', \'男\', 53, \'123456789012345670\', \'上海\', \'2011-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (11, \'00011\', \'张士诚\', \'男\', 55, \'123567897123465670\', \'江苏\', \'2015-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (12, \'00012\', \'常遇春\', \'男\', 32, \'123446757152345670\', \'北京\', \'2004-02-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (13, \'00013\', \'张三丰\', \'男\', 88, \'123656789012345678\', \'江苏\', \'2020-11-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (14, \'00014\', \'灭绝\', \'女\', 65, \'123456719012345670\', \'西安\', \'2019-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (15, \'00015\', \'胡青牛\', \'男\', 70, \'12345674971234567X\', \'西安\', \'2018-04-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (16, \'00016\', \'周芷若\', \'女\', 18, null, \'北京\', \'2012-06-01\');\n\n```\n\n#### 1.6.1 基本语法\n\nDDL查询语句，语法结构如下：\n\n``` sql\nSELECT\n字段列表\nFROM\n表名列表\nWHERE\n条件列表\nGROUP BY\n分组字段列表\nHAVING\n分组后条件列表\nORDER BY\n排序字段列表\nLIMIT\n分页参数\n\n```\n\n大致可以拆分为以下几个部分：\n\n- 基本查询（不带任何条件） \n- 条件查询（WHERE） \n- 聚合函数（count、max、min、avg、sum） \n- 分组查询（group by） \n- 排序查询（order by） \n- 分页查询（limit）\n\n#### 1.6.2基本查询\n\n在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：\n\n1）. 查询多个字段\n\n``` sql\nselect 字段1,字段2,字段3 ... from 表名;\n```\n\n``` sql\nSELECT * FROM 表名 ;\n```\n\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\n\n2）. 字段设置别名\n\n``` sql\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;\n```\n\n``` sql\n# as 也可省略\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\n```\n\n3）. 去除重复记录\n\n``` sql\nselect distinct 字段列表 from 表名;\n```\n\n案例：\n\nA. 查询指定字段 name，workno，age并返回\n\n``` sql\nselect name,workno,age from emp;\n```\n\nB. 查询返回所有字段\n\n``` sql\nselect id,workno,name,gender,age,idcard,workaddress,entrydate from emp;\n```\n\n``` sql\nselect * from emp;\n```\n\nC. 查询所有员工的工作地址，起别名\n\n``` sql\nselect workaddress as \'工作地址\' from emp;\n```\n\n``` sql\n-- as可以省略\nselect workaddress \'工作地址\' from emp;\n```\n\nD. 查询公司员工的上班地址有哪些（去重）\n\n``` sql\nselect distinct workaddress \'工作地址\' from emp;\n```\n\n#### 1.6.3 条件查询\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 where 条件列表;\n```\n\n2）. 条件\n\n常用的比较运算符如下：\n\n| 比较运算符          | 功能                                     |\n| ------------------- | ---------------------------------------- |\n| >                   | 大于                                     |\n| >=                  | 大于等于                                 |\n| <                   | 小于                                     |\n| <=                  | 小于等于                                 |\n| =                   | 等于                                     |\n| <> 或 !=            | 不等于                                   |\n| BETWEEN ... AND ... | 在某个范围之内(含最小、最大值)           |\n| IN(...)             | 在in之后的列表中的值，多选一             |\n| LIKE 占位符         | 模糊匹配(_匹配单个字符, %匹配任意个字符) |\n| IS NULL             | 是NULL                                   |\n\n常用的逻辑运算符如下：\n\n|逻辑运算符|功能|\n|----|----|\n|AND 或 &&|并且 (多个条件同时成立)|\n|OR 或 \\|\\||或者 (多个条件任意一个成立)|\n|NOT 或 !|非 , 不是|\n\n案例：\n\nA. 查询年龄等于88的员工\n\n``` sql\nselect * from emp where age=88;\n```\n\nB. 查询年龄小于20的员工信息\n\n``` sql\nselect * from emp where age<20;\n```\n\nC. 查询年龄小于等于20的员工信息\n\n``` sql\nselect * from emp where age<=20;\n```\n\nD. 查询没有身份证号的员工信息\n\n``` sql\nselect * from emp where idcard is null;\n```\n\nE. 查询有身份证号的员工信息\n\n``` sql\nselect * from emp where idcard is not null;\n```\n\nF. 查询年龄不等于88的员工信息\n\n``` sql\nselect * from emp where age!=88;\n```\n\n``` sql\nselect * from emp where age<>88;\n```\n\nG. 查询年龄在15岁（包含）到20岁（包含）之间的员工信息\n\n``` sql\nselect * from emp where age >=15 and age <= 20;\nselect * from emp where age>=15 && age <=20;\nselect * from emp where age between 15 and 20;\n```\n\nH. 查询性别为女 且年龄小于25的员工信息\n\n``` sql\nselect * from emp where gender =\'女\' and age<25;\n```\n\nI. 查询年龄等于18或20或40的员工信息\n\n``` sql\nselect * from emp where age =18 or age =20 or age =40;\nselect * from emp where age in(18,20,40)\n```\n\nJ. 查询姓名为两个字的员工信息 _ %\n\n``` sql\nselect * from emp where name like \'__\'\n```\n\nK. 查询身份证号最后以为是x的员工信息\n\n``` sql\nselect * from emp where idcard like \'%x\';\nselect * from emp where idcard like \'_________________x\';\n```\n\n#### 1.6.4 聚合函数\n\n1）. 介绍\n\n将一列数据作为一个整体，进行纵向计算。\n\n2）. 常见的聚合函数\n\n| 函数  | 功能     |\n| ----- | -------- |\n| count | 统计数量 |\n| max   | 最大值   |\n| min   | 最小值   |\n| avg   | 平均值   |\n| sum   | 求和     |\n\n3）. 语法\n\n``` sql\nselect 聚合函数（字段列表） from 表名;\n```\n\n> 注意：null值是不参与所有聚合函数运算的。\n\n案例：\n\nA. 统计该企业员工数量\n\n``` sql\nselect count(*) from emp; -- 统计的是总记录数,也就是记录行数\nselect count(idcard) from emp; -- 统计的是idcard字段不为null的记录数\n```\n\n对于count聚合函数，统计符合条件的总记录数，还可以通过count（数字/字符串）的形式进行统计查询，比如：\n\n``` sql\nselect count(1) from emp;\n-- 效果等于 select count(*) from emp;\n```\n\nB. 统计该企业员工的平均年龄\n\n``` sql\nselect avg(age) from emp;\n```\n\nC. 统计该企业员工的最大年龄\n\n``` sql\nselect max(age) from emp;\n```\n\nD. 统计该企业员工的最小年龄\n\n``` sql\nselect min(age) from emp;\n```\n\nE. 统计西安地区员工的年龄之和\n\n``` sql\nselect sum(age) from emp where wordaddress=\'西安\';\n```\n\n#### 1.6.5 分组查询\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\n```\n\n2）. where与having区别\n\n- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n- 判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n> 注意事项：\n>\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n> - 执行顺序: where > 聚合函数 > having 。\n> - 支持多字段分组, 具体语法为 : group by columnA,columnB\n\n案例：\n\nA. 根据性别分组，统计男性员工和女性员工的数量\n\n``` sql\nselect gender,count(*) from emp group by gender;\n```\n\n![image-20220525150636926](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251506016.png)\n\nB. 根据性别分组，统计男性员工和女性员工的平均年龄\n\n``` sql\nselect gender,avg(age) from emp group by gender;\n```\n\n![image-20220525150757361](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251507435.png)\n\nC. 查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址\n\n``` sql\nselect workaddress, count(*) address_count\nfrom emp\nwhere age < 45\ngroup by workaddress\nhaving address_count >= 3;\n```\n\n![image-20220525151427330](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251514414.png)\n\nD. 统计各个工作地址上班的男性及女性员工的数量\n\n``` sql\nselect workaddress \'地区\', gender \'性别\', count(*) \'数量\'\nfrom emp\ngroup by gender, workaddress;\n```\n\n#### 1.6.6 排序查询\n\n排序是日常开发只能够非常常见的一个操作，分为升序和降序排序\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;\n```\n\n2）. 排序方式\n\n- ASC：升序（默认值）\n- DESC：降序\n\n> 注意事项\n>\n> - 如果是升序, 可以不指定排序方式ASC ; \n> - 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n\n案例：\n\nA. 根据年龄对公司的员工进行升序排序\n\n``` sql\nselect * from emp order by age asc;\nselect * from emp order by age;\n```\n\nB. 根据入职时间，对员工进行降序排序\n\n``` sql\nselect * from emp order by entry date desc;\n```\n\nC. 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序\n\n``` sql\nselect * from emp order by age asc , entrydate desc;\n```\n\n#### 1.6.7 分页查询\n\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台 都需要借助于数据库的分页操作。\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 limit 起始索引 , 查询记录数;\n```\n\n> 注意事项: \n>\n> - **起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数**。 \n> - 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 \n> - 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10\n\n案例：\n\nA. 查询第一页员工数据，每页显示十条记录\n\n``` sql\n-- 起始索引为 （查询页码）-1*每页显示记录数\nselect * from emp limit 0,10;\n-- 查询的为第一页数据，起始索引可以省略\nselect * from emp limit 10;\n```\n\nB. 查询第二页员工数据，每页展示10条记录\n\n--------> (页码-1)*页展示记录数\n\n``` sql\n-- 需要查询的为第二页员工数据\n-- 起始索引等于 （查询页码-1）*每页显示记录数\n-- 因此，此处起始索引为（2-1）*10\nselect * from emp limit 10,10;\n```\n\n#### 1.6.8 案例\n\n1）. 查询年龄为20,21,22,23岁的员工信息。\n\n``` sql\nselect * from emp where age in(20,21,22,23);\n```\n\n2）. 查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\n\n``` sql\n#  查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\nselect *\nfrom emp\nwhere gender = \'男\'\n  and age between 20 and 40\n  and name like \'___\';\n```\n\n3）. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\n\n``` sql\n# 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\nselect gender, count(*)\nfrom emp\nwhere age < 60\ngroup by gender;\n```\n\n4）. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按 入职时间降序排序。\n\n``` sql\nselect name, age\nfrom emp\nwhere age <= 35\norder by age, entrydate desc;\n```\n\n5）.  查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。\n\n``` sql\nselect *\nfrom emp\nwhere gender = \'男\'\n  and age between 20 and 40\norder by age, entrydate desc\nlimit 5;\n```\n\n#### 1.6.9 执行顺序\n\n![image-20220525154935887](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251549982.png)\n\n**DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...**\n\n### 1.7 DCL\n\n> DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。\n\n![image-20220525155152013](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251551105.png)\n\n#### 1.7.1 管理用户\n\n1）. 查询用户\n\n``` sql\nselect * from mysql.user;\n```\n\n查询结果如下：\n\n![image-20220525155335839](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251619656.png)\n\n**其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户**\n\n2）. 创建用户\n\n``` sql\ncreate user \'用户名\'@\'主机名\' identified by \'密码\';\n```\n\n3）. 修改用户密码\n\n``` sql\nalter user \'用户名\'@\'主机名\' identified with mysql_native_password by \'新密码\';\n```\n\n4）. 删除用户\n\n``` sql\ndrop user \'用户名\'@\'主机名\';\n```\n\n> 注意事项: \n>\n> - 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n> - 主机名可以使用 % 通配。 \n> - 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。\n\n案例：\n\nA. 创建用户icat, 只能够在当前主机localhost访问, 密码123456;\n\n``` sql\ncreate user \'icat\'@\'localhost\' identified by \'123456\';\n```\n\nB. 创建用户icatw, 可以在任意主机访问该数据库, 密码123456;\n\n``` sql\ncreate user \'icatw\'@\'%\' identified by \'123456\';\n```\n\nC. 修改用户icatw的访问密码为1234;\n\n``` sql\nalter user \'icatw\'@\'%\' identified with mysql_native_password by \'1234\';\n```\n\nD. 删除 icat@localhost 用户\n\n``` sql\ndrop user \'icat\'@\'localhost\';\n```\n\n#### 1.7.2 权限控制\n\nMySQL中定义了很多种权限，但是常用的就以下几种：\n\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| ALL, ALL PRIVILEGES | 所有权限           |\n| SELECT              | 查询数据           |\n| INSERT              | 插入数据           |\n| UPDATE              | 修改数据           |\n| DELETE              | 删除数据           |\n| ALTER               | 修改表             |\n| DROP                | 删除数据库/表/视图 |\n| CREATE              | 创建数据库/表      |\n\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html)。\n\n1）. 查询权限\n\n``` sql\nSHOW GRANTS FOR \'用户名\'@\'主机名\' ;\n```\n\n2）. 授予权限\n\n``` sql\nGRANT 权限列表 ON 数据库名.表名 TO \'用户名\'@\'主机名\';\n```\n\n3）. 撤销权限\n\n``` sql\nREVOKE 权限列表 ON 数据库名.表名 FROM \'用户名\'@\'主机名\';\n```\n\n> 注意事项： \n>\n> - 多个权限之间，使用逗号分隔 \n> - 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\n\n案例: \n\nA. 查询 \'heima\'@\'%\' 用户的权限\n\n``` sql\nshow grants for \'heima\'@\'%\';\n```\n\nB. 授予 \'heima\'@\'%\' 用户itcast数据库所有表的所有操作权限\n\n``` sql\ngrant all on itcast.* to \'heima\'@\'%\'\n```\n\nC. 撤销 \'heima\'@\'%\' 用户的itcast数据库的所有权限\n\n``` sql\nrevoke all on itcast.* from \'heima\'@\'%\';\n```\n\n\n\n## 2. 函数\n\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那 么，函数到底在哪儿使用呢？ 我们先来看两个场景：\n\n![image-20220525162834366](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251628459.png)\n\n1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能 够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计 算出天数呢？ \n\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的 分数值，如98/75，如何快速判定分数的等级呢？ 其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。\n\n其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。 \n\nMySQL中的函数主要分为以下四类： **字符串函数、数值函数、日期函数、流程函数。**\n\n### 2.1 字符串函数\n\nMySQL中内置了很多字符串函数，常用的几个如下：\n\n| 函数                     | 功能                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串               |\n| LOWER(str)               | 将字符串str全部转为小写                                    |\n| UPPER(str)               | 将字符串str全部转为大写                                    |\n| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 |\n| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 |\n| TRIM(str)                | 去掉字符串头部和尾部的空格                                 |\n| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串            |\n\n演示如下：\n\nA. concat：字符串拼接\n\n``` sql\nselect concat(\'Hello\' , \' MySQL\');\n```\n\n结果如下：\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251651650.png\" alt=\"image-20220525165104555\" style=\"zoom:67%;\" />\n\nB. lower : 全部转小写\n\n``` sql\nselect lower(\'Hello\');\n```\n\n![image-20220525165228376](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251652464.png)\n\nC. upper : 全部转大写\n\n``` sql\nselect upper(\'Hello\');\n```\n\n![image-20220525165323592](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251653679.png)\n\nD.  lpad : 左填充\n\n``` sql\nselect lpad(\'01\', 5, \'-\');\n```\n\n![image-20220525165433666](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251654755.png)\n\nE. rpad : 右填充\n\n``` sql\nselect rpad(\'01\', 5, \'-\');\n```\n\n![image-20220525165713762](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251657320.png)\n\nF. trim : 去除空格\n\n``` sql\nselect trim(\' Hello MySQL \');\n```\n\nG. substring : 截取子字符串\n\n``` sql\nselect substring(\'Hello MySQL\',1,5);\n```\n\n案例：\n\n![image-20220525174936078](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251749181.png)\n\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员 工的工号应该为00001。\n\n``` sql\nupdate emp set workno = lpad(workno, 5, \'0\');\n```\n\n处理完毕后, 具体的数据为:\n\n![image-20220525175223093](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251752289.png)\n\n### 2.2 数值函数\n\n常见的数值函数如下：\n\n| 函数       | 功能                               |\n| ---------- | ---------------------------------- |\n| CEIL(x)    | 向上取整                           |\n| FLOOR(x)   | 向下取整                           |\n| MOD(x,y)   | 返回x/y的模                        |\n| RAND()     | 返回0~1内的随机数                  |\n| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |\n\n演示如下：\n\nA. ceil：向上取整\n\n``` sql\nselect ceil(1.1);\n```\n\nB. floor：向下取整\n\n``` sql\nselect floor(1.9)\n```\n\nC. mod：取模\n\n``` sql\nselect mod(7,4);\n```\n\nD. rand：获取随机数\n\n``` sql\nselect rand();\n```\n\nE. round：四舍五入\n\n``` sql\nselect round(2.344,2);\n```\n\n案例： \n\n通过数据库的函数，生成一个六位数的随机验证码。\n\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础 上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\n\n``` sql\nselect lpad(round(rand()*1000000 , 0), 6, \'0\');\n```\n\n### 2.3 日期函数\n\n常见的日期函数如下：\n\n| 函数                               | 功能                                               |\n| ---------------------------------- | -------------------------------------------------- |\n| CURDATE()                          | 返回当前日期                                       |\n| CURTIME()                          | 返回当前时间                                       |\n| NOW()                              | 返回当前日期和时间                                 |\n| YEAR(date)                         | 获取指定date的年份                                 |\n| MONTH(date)                        | 获取指定date的月份                                 |\n| DAY(date)                          | 获取指定date的日期                                 |\n| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的 时间值 |\n| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天 数      |\n\n演示如下：\n\nA. curdate：当前日期\n\n``` sql\nselect curdate();\n```\n\nB. curtime：当前时间\n\n``` SQL\nselect curtime();\n```\n\nC. now：当前日期和时间\n\n``` sql\nselect now();\n```\n\nD. YEAR , MONTH , DAY：当前年、月、日\n\n``` sql\nselect YEAR(now());\nselect MONTH(now());\nselect DAY(now());\n```\n\nE. date_add：增加指定的时间间隔\n\n``` sql\nselect date_add(now(), INTERVAL 70 YEAR );\n```\n\nF. datediff：获取两个日期相差的天数\n\n``` sql\nselect datediff(\'2021-10-01\', \'2021-12-01\');\n```\n\n案例： \n\n查询所有员工的入职天数，并根据入职天数倒序排序。 \n\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\n\n``` sql\nselect name, datediff(curdate(), entrydate) as \'entrydays\' from emp order by entrydays desc;\n\n```\n\n### 2.4 流程函数\n\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n| 函数                                                         | 功能                                                       |\n| ------------------------------------------------------------ | ---------------------------------------------------------- |\n| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回 f                       |\n| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则 返回value2              |\n| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |\n| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |\n演示如下：\n\nA. if\n\n``` sql\nselect if(false, \'Ok\', \'Error\');\n```\n\nB. ifnull \n\n``` sql\nselect ifnull(\'Ok\',\'Default\');\nselect ifnull(\'\',\'Default\');\n-- 只有这个才会输出default\nselect ifnull(null,\'Default\');\n```\n\nC. case when then else end\n\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----> 一线城市 , 其他 ----> 二线城市)\n\n``` sql\nselect name,\n       (case workaddress\n            when \'北京\' then \'一线城市\'\n            when \'上海\' then \'一线城市\'\n            else\n                \'二线城市\' end) as \'工作地址\'\nfrom emp;\n```\n\n案例：\n\n将学生表按成绩分类\n\n首先，准备数据\n\n``` sql\ncreate table score\n(\n    id      int comment \'ID\',\n    name    varchar(20) comment \'姓名\',\n    math    int comment \'数学\',\n    english int comment \'英语\',\n    chinese int comment \'语文\'\n) comment \'学员成绩表\';\ninsert into score(id, name, math, english, chinese)\nVALUES (1, \'Tom\', 67, 88, 95),\n       (2, \'Rose\', 23, 66, 90),\n       (3, \'Jack\', 56, 98, 76);\n\n```\n\n具体SQL如下\n\n``` sql\nselect id,\n       name,\n       (case when math >= 85 then \'优秀\' when math >= 60 then \'及格\' else \'不及格\' end)\n                \'数学\',\n       (case\n            when english >= 85 then \'优秀\'\n            when english >= 60 then \'及格\'\n            else \'不及格\'\n           end) \'英语\',\n       (case\n            when chinese >= 85 then \'优秀\'\n            when chinese >= 60 then \'及格\'\n            else \'不及格\'\n           end) \'语文\'\nfrom score;\n```\n\n![image-20220525181610736](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251816834.png)\n\nMySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景， 思考一下需要用到什么样的函数来实现? \n\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------> \n\n答案: datediff \n\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------> \n\n答案: case ... when ...\n\n## 3. 约束\n\n### 3.1 概述\n\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n目的：保证数据库中数据的正确、有效性和完整性。\n\n分类：\n\n| 约束                      | 描述                                                      | 关键字      |\n| ------------------------- | --------------------------------------------------------- | ----------- |\n| 非空约束                  | 限制该字段的数据不能为null                                | NOT NULL    |\n| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                    | UNIQUE      |\n| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                  | PRIMARY KEY |\n| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值            | DEFAULT     |\n| 检查约束(8.0.16版本 之后) | 保证字段值满足某一个条件                                  | CHECK       |\n| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致 性和完整性 | FOREIGN KEY |\n\n> 注意：**约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。**\n\n### 3.2 约束演示\n\n案例需求： 根据需求，完成表结构的创建。需求如下：\n\n| 字段名 | 字段含 义   | 字段类型    | 约束条件                   | 约束关键字                  |\n| ------ | ----------- | ----------- | -------------------------- | --------------------------- |\n| id     | ID唯一 标识 | int         | 主键，并且自动增长         | PRIMARY KEY, AUTO_INCREMENT |\n| name   | 姓名        | varchar(10) | 不为空，并且唯一           | NOT NULL , UNIQUE           |\n| age    | 年龄        | int         | 大于0，并且小于等 于120    | CHECK                       |\n| status | 状态        | char(1)     | 如果没有指定该值， 默认为1 | DEFAULT                     |\n| gender | 性别        | char(1)     | 无                         |                             |\n\n对应的建表语句为：\n\n``` sql\nCREATE TABLE tb_user\n(\n    id     int AUTO_INCREMENT PRIMARY KEY COMMENT \'ID唯一标识\',\n    name   varchar(10) NOT NULL UNIQUE COMMENT \'姓名\',\n    age    int check (age > 0 && age <= 120) COMMENT \'年龄\',\n    status char(1) default \'1\' COMMENT \'状态\',\n    gender char(1) COMMENT \'性别\'\n);\n```\n\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。\n\n### 3.3 外键约束\n\n#### 3.3.1 介绍\n\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\n\n准备数据\n\n``` sql\ncreate table dept\n(\n    id   int auto_increment comment \'ID\' primary key,\n    name varchar(50) not null comment \'部门名称\'\n) comment \'部门表\';\nINSERT INTO dept (id, name)\nVALUES (1, \'研发部\'),\n       (2, \'市场部\'),\n       (3, \'财务部\'),\n       (4,\n        \'销售部\'),\n       (5, \'总经办\');\ndrop table if exists icatw.emp;\ncreate table emp\n(\n    id        int auto_increment comment \'ID\' primary key,\n    name      varchar(50) not null comment \'姓名\',\n    age       int comment \'年龄\',\n    job       varchar(20) comment \'职位\',\n    salary    int comment \'薪资\',\n    entrydate date comment \'入职时间\',\n    managerid int comment \'直属领导ID\',\n    dept_id   int comment \'部门ID\'\n) comment \'员工表\';\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\n       (2, \'张无忌\', 20,\n        \'项目经理\', 12500, \'2005-12-05\', 1, 1),\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1);\n\n```\n\n\n\n#### 3.3.2 语法\n\n1）. 添加外键\n\n``` sql\nCREATE TABLE 表名(\n字段名 数据类型,\n...\n[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)\n);\n```\n\n``` sql\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)\nREFERENCES 主表 (主表列名) ;\n```\n\n案例：\n\n为emp表的dept_id字段添加外键约束，关联dept表的主键id。\n\n``` sql\nalter table emp\n    add constraint fk foreign key (dept_id) references dept (id);\n```\n\n![image-20220525212454577](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252124722.png)\n\n**当添加外键约束之后，不能直接删除父表的记录，需要先删除子表所关联数据，否则会报错。**\n\n2）. 删除外键\n\n``` sql\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n```\n\n案例：\n\n删除emp表的外键fk。\n\n``` sql\nalter table emp\n    drop foreign key fk;\n```\n\n#### 3.3.3 删除/更新行为\n\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:\n\n| 行为        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为 |\n| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为 |\n| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。 |\n| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。 |\n| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)  |\n\n具体语法为：\n\n``` sql\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\n主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;\n```\n\n## 4. 多表查询\n\n### 4.1 多表关系\n\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n- 一对多(多对一) \n- 多对多 \n- 一对一\n\n#### 4.1.1 一对多\n\n- 案例：部门与员工的关系\n- 关系：一个部门对应多名员工，一个员工对应一个部门\n- 实现：在多的一方建立外键，指向另一方的主键\n\n![image-20220525213949714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252139778.png)\n\n#### 4.1.2 多对多\n\n- 案例：学生与课程的关系\n- 关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n- 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n![image-20220525214004144](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252140207.png)\n\n对应的SQL脚本：\n\n``` sql\ncreate table student\n(\n    id   int auto_increment primary key comment \'主键ID\',\n    name varchar(10) comment \'姓名\',\n    no   varchar(10) comment \'学号\'\n) comment \'学生表\';\ninsert into student\nvalues (null, \'黛绮丝\', \'2000100101\'),\n       (null, \'谢逊\',\n        \'2000100102\'),\n       (null, \'殷天正\', \'2000100103\'),\n       (null, \'韦一笑\', \'2000100104\');\ncreate table course\n(\n    id   int auto_increment primary key comment \'主键ID\',\n    name varchar(10) comment \'课程名称\'\n) comment \'课程表\';\ninsert into course\nvalues (null, \'Java\'),\n       (null, \'PHP\'),\n       (null, \'MySQL\'),\n       (null, \'Hadoop\');\n\ncreate table student_course\n(\n    id        int auto_increment comment \'主键\' primary key,\n    studentid int not null comment \'学生ID\',\n    courseid  int not null comment \'课程ID\',\n    constraint fk_courseid foreign key (courseid) references course (id),\n    constraint fk_studentid foreign key (studentid) references student (id)\n) comment \'学生课程中间表\';\ninsert into student_course\nvalues (null, 1, 1),\n       (null, 1, 2),\n       (null, 1, 3),\n       (null, 2, 2),\n       (null, 2, 3),\n       (null, 3, 4);\n```\n\n#### 4.1.3 一对一\n\n- 案例：用户与用户详情的关系\n- 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n- 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n\n![image-20220525214650949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252146016.png)\n\n对应的SQL脚本：\n\n``` sql\ncreate table if not exists tb_user\n(\n    id     int auto_increment primary key comment \'主键ID\',\n    name   varchar(10) comment \'姓名\',\n    age    int comment \'年龄\',\n    gender char(1) comment \'1: 男 , 2: 女\',\n    phone  char(11) comment \'手机号\'\n) comment \'用户基本信息表\';\ncreate table if not exists tb_user_edu\n(\n    id            int auto_increment primary key comment \'主键ID\',\n    degree        varchar(20) comment \'学历\',\n    major         varchar(50) comment \'专业\',\n    primaryschool varchar(50) comment \'小学\',\n    middleschool  varchar(50) comment \'中学\',\n\n    university    varchar(50) comment \'大学\',\n    userid        int unique comment \'用户ID\',\n    constraint fk_userid foreign key (userid) references tb_user (id)\n) comment \'用户教育信息表\';\ninsert into tb_user(id, name, age, gender, phone)\nvalues (null, \'黄渤\', 45, \'1\', \'18800001111\'),\n       (null, \'冰冰\', 35, \'2\', \'18800002222\'),\n       (null, \'码云\', 55, \'1\', \'18800008888\'),\n       (null, \'李彦宏\', 50, \'1\', \'18800009999\');\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,\n                        university, userid)\nvalues (null, \'本科\', \'舞蹈\', \'静安区第一小学\', \'静安区第一中学\', \'北京舞蹈学院\', 1),\n       (null, \'硕士\', \'表演\', \'朝阳区第一小学\', \'朝阳区第一中学\', \'北京电影学院\', 2),\n       (null, \'本科\', \'英语\', \'杭州市第一小学\', \'杭州市第一中学\', \'杭州师范大学\', 3),\n       (null, \'本科\', \'应用数学\', \'阳泉第一小学\', \'阳泉区第一中学\', \'清华大学\', 4);\n```\n\n### 4.2 多表查询概述\n\n#### 4.2.1 数据准备\n\n1）. 删除之前emp，dept表的测试数据\n\n2）. 执行如下脚本，创建emp表与dept表并插入测试数据\n\n``` sql\n-- 创建dept表，并插入数据\ndrop table if exists dept;\ncreate table dept\n(\n    id   int auto_increment comment \'ID\' primary key,\n    name varchar(50) not null comment \'部门名称\'\n) comment \'部门表\';\nINSERT INTO dept (id, name)\nVALUES (1, \'研发部\'),\n       (2, \'市场部\'),\n       (3, \'财务部\'),\n       (4,\n        \'销售部\'),\n       (5, \'总经办\'),\n       (6, \'人事部\');\n-- 创建emp表，并插入数据\ndrop table if exists emp;\ncreate table emp\n(\n    id        int auto_increment comment \'ID\' primary key,\n    name      varchar(50) not null comment \'姓名\',\n    age       int comment \'年龄\',\n    job       varchar(20) comment \'职位\',\n    salary    int comment \'薪资\',\n    entrydate date comment \'入职时间\',\n    managerid int comment \'直属领导ID\',\n    dept_id   int comment \'部门ID\'\n) comment \'员工表\';\n-- 添加外键\nalter table emp\n    add constraint fk_emp_dept_id foreign key (dept_id) references\n        dept (id);\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\n       (2, \'张无忌\', 20, \'项目经理\', 12500, \'2005-12-05\', 1, 1),\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1),\n       (7, \'灭绝\', 60, \'财务总监\', 8500, \'2002-09-12\', 1, 3),\n       (8, \'周芷若\', 19, \'会计\', 48000, \'2006-06-02\', 7, 3),\n       (9, \'丁敏君\', 23, \'出纳\', 5250, \'2009-05-13\', 7, 3),\n       (10, \'赵敏\', 20, \'市场部总监\', 12500, \'2004-10-12\', 1, 2),\n       (11, \'鹿杖客\', 56, \'职员\', 3750, \'2006-10-03\', 10, 2),\n       (12, \'鹤笔翁\', 19, \'职员\', 3750, \'2007-05-09\', 10, 2),\n       (13, \'方东白\', 19, \'职员\', 5500, \'2009-02-12\', 10, 2),\n       (14, \'张三丰\', 88, \'销售总监\', 14000, \'2004-10-12\', 1, 4),\n       (15, \'俞莲舟\', 38, \'销售\', 4600, \'2004-10-12\', 14, 4),\n       (16, \'宋远桥\', 40, \'销售\', 4600, \'2004-10-12\', 14, 4),\n       (17, \'陈友谅\', 42, null, 2000, \'2011-10-12\', 1, null);\n```\n\ndept表共6条记录，emp表共17条记录。\n\n#### 4.2.2 概述\n\n多表查询就是指从多张表中查询数据。\n\n原来查询单表数据，执行的SQL形式为：select * from emp; \n\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，\n\n如： `select * from emp , dept` ; 具体的执行结果如下:\n\n![image-20220526085113395](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260851744.png)\n\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。\n\n**笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。**\n\n![image-20220526085212058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260853700.png)\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\n![image-20220526085430499](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260854637.png)\n\n![image-20220526085521044](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260855198.png)\n\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\n\n``` sql\nselect *\nfrom icatw.emp,\n     icatw.dept\nwhere emp.dept_id = dept.id;\n```\n\n![image-20220526085719946](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260857204.png)\n\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。\n\n#### 4.2.3 分类\n\n- 连接查询\n  - 内连接：相当于查询A、B交集部分数据 \n  - 外连接： \n  - 左外连接：查询左表所有数据，以及两张表交集部分数据 \n  - 右外连接：查询右表所有数据，以及两张表交集部分数据 \n  - 自连接：当前表与自身的连接查询，自连接必须使用表别名\n- 子查询\n\n![image-20220526090006541](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900675.png)\n\n### 4.3 内连接\n\n![image-20220526090056077](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900217.png)\n\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构\n\n1）. 隐式内连接\n\n``` sql\nselect 字段列表 from 表1 , 表2 where 条件...;\n```\n\n2）. 显式内连接\n\n``` sql\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;\n```\n\n案例：\n\nA. 查询每一个员工的姓名，及关联的部门的名称（隐式内连接）\n\n表结构：emp , dept\n\n连接条件：emp.dept_id = dept.id\n\n``` sql\nselect emp.name, dept.name\nfrom emp,\n     dept\nwhere emp.dept_id = dept.id;\n\n-- 为每一张表起别名,简化SQL编写\nselect e.name, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n![image-20220526091506843](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260915000.png)\n\nB. 查询每一个员工的姓名，及关联的部门的名称（显示内连接实现）\n\n--- INNER JOIN ... ON ...\n\n表结构：emp，dept\n\n连接条件：emp.dept_id = dept.id\n\n``` sql\nselect e.name, d.name\nfrom emp e\n         inner join dept d on e.dept_id = d.id;\n         \n-- 为每一张表起别名,简化SQL编写\nselect e.name, d.name\nfrom emp e\n         join dept d on e.dept_id = d.id;\n```\n\n> 表的别名：\n>\n> - tablea as 别名1 ,  tableb as 别名2 ;\n> -  tablea 别名1 , tableb 别名2 ;\n>\n> 注意事项：\n>\n> ​		一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\n\n### 4.4 外连接\n\n![image-20220526105436328](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261054413.png)\n\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\n\n1）. 左外连接\n\n``` sql\nselect 字段列表 from 表1 left [outer] join 表2 on 条件 ...;\n```\n\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n2）. 右外连接\n\n``` sql\nselect 字段列表 from 表1 right [outer] join 表2 on 条件...;\n```\n\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n案例: \n\nA. 查询emp表的所有数据, 和对应的部门信息 \n\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。 \n\n表结构: emp, dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.*, d.name\nfrom icatw.emp e\n         left join icatw.dept d on e.dept_id = d.id;\n\nselect e.*, d.name\nfrom emp e\n         left outer join dept d on e.dept_id = d.id;\n```\n\nB. 查询dept表的所有数据, 和对应的员工信息(右外连接)\n\n由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 \n\n表结构: emp, dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;\n\nselect d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;\n```\n\n> 注意事项：\n>\n> ​		左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n\n### 4.5 自连接\n\n#### 4.5.1 自连接查询\n\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。下面是自连接 的查询语法：\n\n``` sql\nselect 字段列表 from 表A 别名A join 表A 别名B on 条件...;\n```\n\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\n\n案例：\n\nA. 查询员工 及其 所属领导的名字 \n\n表结构: emp\n\n``` SQL\n# A. 查询员工 及其 所属领导的名字\nselect a.name \'领导名\', b.name \'员工名\'\nfrom emp a\n         join emp b on a.id = b.managerid;\n```\n\nB. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 \n\n表结构: emp a , emp b\n\n``` SQL\nselect a.name \'员工\', b.name \'领导\'\nfrom emp a\n         left join emp b on a.managerid =\n                            b.id;\n```\n\n> 注意事项: \n>\n> ​		在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底 是哪一张表的字段。\n\n#### 4.5.2 联合查询\n\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\n``` sql\nSELECT 字段列表 FROM 表A ...\nUNION [ ALL ]\nSELECT 字段列表 FROM 表B ....;\n```\n\n- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 \n- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\n\n案例: \n\nA. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. \n\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们 也可以通过union/union all来联合查询.\n\nunion all: 会有重复值\n\n``` sql\nselect *\nfrom emp\nwhere salary < 5000\nunion all\nselect *\nfrom emp\nwhere age > 50;\n```\n\n相当于\n\n``` sql\nselect * from emp where salary < 5000 or age > 50;\n```\n\n![image-20220526112549321](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261125429.png)\n\nunion 联合查询，会对查询出来的结果进行去重处理\n\n``` sql\nselect *\nfrom emp\nwhere salary < 5000\nunion\nselect *\nfrom emp\nwhere age > 50;\n```\n\n相当于\n\n``` sql\nselect distinct *\nfrom emp\nwhere salary < 5000\n   or age > 50;\n```\n\n> 注意： \n>\n> ​		如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报 错。如：\n\n![image-20220526112722744](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261127805.png)\n\n### 4.6 子查询\n\n#### 4.6.1 概述\n\n1）. 概念\n\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\n\n``` sql\nselect * from t1 where column1=(select column1 from t2); \n```\n\n子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。\n\n2）. 分类\n\n根据子查询结果不同，分为： \n\nA. 标量子查询（子查询结果为单个值） \n\nB. 列子查询(子查询结果为一列) \n\nC. 行子查询(子查询结果为一行) \n\nD. 表子查询(子查询结果为多行多列)\n\n\n\n根据子查询位置，分为： \n\nA. WHERE之后 \n\nB. FROM之后 \n\nC. SELECT之后\n\n#### 4.6.2 标量子查询\n\n子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= <> > >= < <=\n\n案例：\n\nA. 查询 \"销售部\" 的所有员工信息 \n\n完成这个需求时，我们可以将需求分解为两步： \n\n①. 查询 \"销售部\" 部门ID\n\n``` sql\nselect id\n                 from dept\n                 where name = \'销售部\';\n```\n\n②. 根据 \"销售部\" 部门ID, 查询员工信息\n\n``` sql\n# 查询 \"销售部\" 的所有员工信息\nselect *\nfrom emp\nwhere dept_id = (select id\n                 from dept\n                 where name = \'销售部\');\n```\n\n内连接：\n\n``` sql\nselect e.*\nfrom emp e\n         join dept d on e.dept_id = d.id and d.name = \'销售部\';\n```\n\nB. 查询在 \"方东白\" 入职之后的员工信息 \n\n完成这个需求时，我们可以将需求分解为两步： \n\n①. 查询 方东白 的入职日期\n\n``` sql\n# 查询在 \"方东白\" 入职之后的员工信息\nselect entrydate\nfrom emp\nwhere name = \'方东白\';\n```\n\n②. 查询指定入职日期之后入职的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere entrydate > (select entrydate\n                   from emp\n                   where name = \'方东白\');\n```\n\n#### 4.6.3 列子查询\n\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 \n\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n| 操作符 | 描述                                   |\n| ------ | -------------------------------------- |\n| IN     | 在指定的集合范围之内，多选一           |\n| NOT IN | 不在指定的集合范围之内                 |\n| ANY    | 子查询返回列表中，有任意一个满足即可   |\n| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |\n| ALL    | 子查询返回列表的所有值都必须满足       |\n\n案例：\n\nA. 查询 \"销售部\" 和 \"市场部\" 的所有员工信息\n\n分解为以下两步: \n\n①. 查询 \"销售部\" 和 \"市场部\" 的部门ID\n\n``` sql\nselect id\nfrom dept\nwhere name = \'销售部\'\n   or name = \'市场部\';\n```\n\n②. 根据部门ID, 查询员工信息\n\n``` sql\nselect *\nfrom emp\nwhere dept_id in (select id\n                  from dept\n                  where name = \'销售部\'\n                     or name = \'市场部\');\n```\n\nB. 查询比 财务部 所有人工资都高的员工信息\n\n分解为以下两步: \n\n①. 查询所有 财务部 人员工资\n\n``` sql\nselect id from dept where name = \'财务部\';\nselect salary from emp where dept_id = (select id from dept where name = \'财务部\');\n```\n\n②. 比 财务部 所有人工资都高的员工信息\n\n``` sql\nselect * from emp where salary > all ( select salary from emp where dept_id =\n(select id from dept where name = \'财务部\') );\n```\n\nC. 查询比研发部其中任意一人工资高的员工信息\n\n分解为以下两步: \n\n①. 查询研发部所有人工资\n\n``` sql\nselect salary\nfrom emp\nwhere dept_id = (select id from dept where name = \'研发部\');\n```\n\n②. 比研发部其中任意一人工资高的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere salary > any (select salary\n                    from emp\n                    where dept_id = (select id from dept where name = \'研发部\'));\n```\n\n#### 4.6.4 行子查询\n\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：= 、<> 、IN 、NOT IN\n\n案例: \n\nA. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ; \n\n这个需求同样可以拆解为两步进行:\n\n①. 查询 \"张无忌\" 的薪资及直属领导\n\n```sql\nselect salary, managerid\nfrom emp\nwhere name = \'张无忌\';\n```\n\n②. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ;\n\n``` sql\nselect *\nfrom emp\nwhere (salary, managerid) = (select salary, managerid\n                             from emp\n                             where name = \'张无忌\');\n```\n\n#### 4.6.5 表子查询\n\n子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN\n\n案例: \n\nA. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息 \n\n分解为两步执行:\n\n①. 查询 \"鹿杖客\" , \"宋远桥\" 的职位和薪资\n\n``` sql\nselect job, salary\nfrom emp\nwhere name = \'鹿杖客\'\n   or name = \'宋远桥\';\n```\n\n②. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere (job, salary) in (select job, salary\n                        from emp\n                        where name = \'鹿杖客\'\n                           or name = \'宋远桥\');\n```\n\nB. 查询入职日期是 \"2006-01-01\" 之后的员工信息 , 及其部门信息\n\n分解为两步执行: \n\n①. 入职日期是 \"2006-01-01\" 之后的员工信息\n\n``` sql\nselect *\nfrom emp where entrydate>\'2006-01-01\';\n```\n\n②. 查询这部分员工, 对应的部门信息;\n\n```sql\n-- 先查询出入职日期是 \"2006-01-01\" 之后的员工信息，再将其作为新表与部门表进行左外连接查询\nselect *\nfrom (select *\n      from emp\n      where entrydate > \'2006-01-01\') e\n         left join dept d\n                   on e.dept_id = d.id;\n```\n\n### 4.7 多表查询案例\n\n数据环境准备：\n\n``` sql\ncreate table salgrade\n(\n    grade int,\n    losal int,\n    hisal int\n) comment \'薪资等级表\';\ninsert into salgrade\nvalues (1, 0, 3000),\n       (2, 3001, 5000),\n       (3, 5001, 8000),\n       (4, 8001, 10000),\n       (5, 10001, 15000),\n       (6, 15001, 20000),\n       (7, 20001, 25000),\n       (8, 25001, 30000);\n```\n\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉 及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\n\n1）. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n表: emp , dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.name, e.age, e.job, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n2）. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接） \n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.name, e.age, e.job, d.name\nfrom emp e\n         inner join dept d on e.dept_id = d.id and e.age < 30;\n```\n\n3）. 查询拥有员工的部门ID、部门名称\n\n表：emp，dept\n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect distinct d.id, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n4）. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出 来(外连接) \n\n表: emp , dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.*, d.name\nfrom emp e\n         left join dept d on d.id = e.dept_id and e.age > 40;\n```\n\n5）. 查询所有员工的工资等级 \n\n表: emp , salgrade \n\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\n\n``` sql\nselect e.*, s.grade \'员工等级\'\nfrom emp e,\n     salgrade s\nwhere e.salary between s.losal and s.hisal;\n```\n\n6）. 查询 \"研发部\" 所有员工的信息及 工资等级 \n\n表: emp , salgrade , dept \n\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id \n\n查询条件 : dept.name = \'研发部\'\n\n``` sql\nselect e.*, d.name, s.grade\nfrom emp e,\n     dept d,\n     salgrade s\nwhere d.name = \'研发部\'\n  and e.dept_id = d.id\n  and e.salary between s.losal and s.hisal;\n```\n\n7）. 查询 \"研发部\" 员工的平均工资 \n\n表: emp , dept \n\n连接条件 : emp.dept_id = dept.id\n\n``` sql\nselect avg(e.salary)\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id\n  and d.name = \'研发部\';\n```\n\n8）. 查询工资比 \"灭绝\" 高的员工信息。 \n\n①. 查询 \"灭绝\" 的薪资\n\n``` sql\nselect salary\nfrom emp\nwhere emp.name = \'灭绝\';\n```\n\n②. 查询比她工资高的员工数据\n\n``` sql\nselect *\nfrom emp\nwhere salary > (select salary\n                from emp\n                where emp.name = \'灭绝\');\n```\n\n9）.  查询比平均薪资高的员工信息 \n\n①. 查询员工的平均薪资\n\n``` sql\nselect avg(salary)\nfrom emp;\n```\n\n②. 查询比平均薪资高的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere salary > (select avg(salary)\n                from emp);\n```\n\n10）.  查询低于本部门平均工资的员工信息 \n\n①. 查询指定部门平均薪资\n\n``` sql\nselect avg(e1.salary) from emp e1 where e1.dept_id = 1;\nselect avg(e1.salary) from emp e1 where e1.dept_id = 2;\n```\n\n②. 查询低于本部门平均工资的员工信息\n\n``` sql\nselect *\nfrom emp e2\nwhere e2.salary < (select avg(e1.salary)\n                   from emp e1\n                   where e1.dept_id = e2.dept_id);\n```\n\n11）. 查询所有的部门信息, 并统计部门的员工人数\n\n``` sql\nselect d.id, d.name, (select count(*) from emp e where e.dept_id = d.id) \'人数\'\nfrom dept d;\n```\n\n12）. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n表: student , course , student_course \n\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\n\n``` sql\nselect s.name, s.no, c.name\nfrom student s,\n     student_course sc,\n     course c\nwhere s.id = sc.studentid\n  and sc.courseid = c.id;\n```\n\n**备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条 件的记录即可。**\n\n## 5. 事务\n\n### 5.1 事务介绍\n\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 \n\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\n\n![image-20220526211221401](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112624.png)\n\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :\n\n![image-20220526211238606](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112698.png)\n\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\n\n![image-20220526211300656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113735.png)\n\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\n\n![image-20220526211317578](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113661.png)\n\n> **注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。**\n\n### 5.2 事务操作\n\n数据准备：\n\n``` sql\ndrop table if exists account;\ncreate table account\n(\n    id    int primary key AUTO_INCREMENT comment \'ID\',\n    name  varchar(10) comment \'姓名\',\n    money double(10, 2) comment \'余额\'\n) comment \'账户表\';\ninsert into account(name, money)\nVALUES (\'张三\', 2000),\n       (\'李四\', 2000);\n```\n\n#### 5.2.1 未控制事务\n\n1). 测试正常情况\n\n``` sql\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n```\n\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\n\n![image-20220526211732232](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262117323.png)\n\n2). 测试异常情况\n\n``` sql\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n出错了....\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n```\n\n我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。\n\n![image-20220526211831649](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262118725.png)\n\n#### 5.2.2 控制事务一\n\n1）. 查看/设置事务提交方式\n\n``` sql\nSELECT @@autocommit ;\nSET @@autocommit = 0 ;\n```\n\n2）. 提交事务\n\n``` sql\ncommit;\n```\n\n3）. 回滚事务\n\n``` sql\nrollback;\n```\n\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\n\n#### 5.2.3 控制事务二\n\n1）. 开启事务\n\n``` sql\nSTART TRANSACTION 或 BEGIN ;\n```\n\n2）. 提交事务\n\n``` sql\ncommit;\n```\n\n3）. 回滚事务\n\n``` sql\nROLLBACK;\n```\n\n转账案例：\n\n``` sql\n-- 开启事务\nstart transaction\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n-- 如果正常执行完毕, 则提交事务\ncommit;\n-- 如果执行过程中报错, 则回滚事务\n-- rollback;\n```\n\n### 5.3  事务四大特性（ACID）\n\n- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 \n- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 \n- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。\n- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n上述就是事务的四大特性，简称ACID。\n\n![image-20220526215911714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262159820.png)\n\n### 5.4 并发事务问题\n\n1）. 脏读：一个事务读到另外一个事务还没有提交的数据。\n\n![image-20220526220426943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204036.png)\n\n2）. 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n\n![image-20220526220450359](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204455.png)\n\n3）. 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 \"幻影\"。\n\n![image-20220526220605668](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262206753.png)\n\n### 5.5 事务隔离级别\n\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\n\n| 隔离级别                          | 脏读 | 不可重复读取 | 幻读 |\n| --------------------------------- | ---- | ------------ | ---- |\n| Read uncommitted（读未提交）      | √    | √            | √    |\n| Read committed（读已提交）        | ×    | √            | √    |\n| Repeatable Read(默认)（可重复读） | ×    | ×            | √    |\n| Serializable（串行化）            | ×    | ×            | ×    |\n\n1）. 查看事务隔离级别\n\n``` SQL\nSELECT @@TRANSACTION_ISOLATION;\n```\n\n2）. 设置事务隔离级别\n\n``` sql\nSET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |\nREAD COMMITTED | REPEATABLE READ | SERIALIZABLE }\n```\n\n> **注意：事务隔离级别越高，数据越安全，但是性能越低。**',1,'',0,0,3,'2022-05-26 22:38:54',NULL),(97,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/96d3026e9fb9c7105723943eab40d899.jpg','MySQL学习【基础篇】','# MySQL学习基础篇\n\n## 1. SQL\n\n**全称 Structured Query Language，结构化查询语言**。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。\n\n### 1.1 SQL通用语法\n\n- SQL语句可以单行或者多行书写，以分号结尾。\n- SQL语句可以使用空格/缩进来增强语句的可读性。\n- MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n- 注释\n    - 单行注释：-- 注释内容 或 # 注释内容\n    - 多行注释： /* 注释内容 */\n\n### 1.2 SQL分类\n\nSQL语句，根据其功能，主要分为四类：**DDL、DML、DQL、DCL**。\n\n| 分类 | 全称                        | 说明                                                    |\n| ---- | --------------------------- | :------------------------------------------------------ |\n| DDL  | Data Definition Language    | 数据定义语言，用来定义数据库对象(数据库，表， 字段)     |\n| DML  | Data Manipuulation Language | 数据操作语言，用来对数据库表中的数据进行增删改          |\n| DQL  | Data Query Language         | 数据查询语言，用来查询数据库中表的记录                  |\n| DCL  | Data Control Language       | 数据控制语言，用来创建数据库用户、控制数据库的 访问权限 |\n\n### 1.3 DDL\n\n> **Data Definition Language，数据定义语言，用来定义数据库对象（数据库、表、字段）**\n\n#### 1.3.1 数据库操作\n\n这里我们直接使用可视化数据库工具Navicat演示命令\n\n- 查询所有数据库\n\n``` sql\nshow databases;\n```\n\n![image-20220523234102071](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232341162.png)\n\n- 查询当前数据库\n\n``` sql\nselect database()\n```\n\n- 创建数据库\n\n``` sql\ncreate database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;\n```\n\n>  注：[ ] 中的值为可选项，default代表有默认值\n\n案例：\n\nA. 创建一个icatw数据库，使用数据库默认的字符集。\n\n``` sql\nCREATE DATABASE icatw;\n```\n\n![image-20220523234756349](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232347399.png)\n\n在同一个数据库服务器中，数据库名不可重复，必须唯一，否则将会报错。\n\n![image-20220523234950307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232349389.png)\n\n可以通过 `` if not exists``（如果不存在）参数来解决这个问题，只有是当数据库名不存在时，才会进行创建。\n\n``` sql\nCREATE DATABASE IF NOT EXISTS icatw;\n```\n\n![image-20220523235235940](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232352985.png)\n\nB.创建一个icat数据库，并且指定字符集\n\n``` sql\n-- 创建icat数据库并指定utf8mb4为默认数据库\nCREATE DATABASE icat DEFAULT CHARSET utf8mb4;\n```\n\nutf8mb4比utf8支持更多字符，\n\n**utf8mb4支持最大4个字节的字符，而utf8最大只支持3个字节的字符，现在一般都使用utf8mb4作为mysql默认字符集**\n\n- 删除数据库\n\n``` sql\n-- 删除数据库icat(如果存在)\nDROP DATABASE IF EXISTS icat;\n```\n\n如果不加上 if exists 的话，数据库不存在则会报错;\n\n- 切换数据库\n\n``` sql\nUSE icatw;\n```\n\n当我们需要操作某个数据库下的表时必须先切换到对应数据库\n\n#### 1.3.2 表操作\n\n对表的操作需要先使用`USE 数据库表`切换到对应数据库\n\n##### 1.3.2.1 表操作-查询创建\n\n1）. 查询当前数据库所有表\n\n查询表需要先使用 `USE 数据库名`切换数据库\n\n例:\n\n``` sql\n-- 查询当前数据库下的所有表\nUSE sys;\nSHOW TABLES;\n```\n\n![image-20220524084459677](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240845244.png)\n\n2）. 查看指定表结构\n\n``` sql\ndesc 表名\n```\n\n3）. 查询指定表的建表语句\n\n``` sql\n-- 查询指定表的建表语句\nSHOW CREATE TABLE sys_config;\n```\n\n![image-20220524085039027](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240850135.png)\n\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\n\n4）. 创建表结构\n\n``` sql\nCREATE TABLE 表名(\n字段1 字段1类型 [ COMMENT 字段1注释 ],\n字段2 字段2类型 [COMMENT 字段2注释 ],\n字段3 字段3类型 [COMMENT 字段3注释 ],\n......\n字段n 字段n类型 [COMMENT 字段n注释 ]\n) [ COMMENT 表注释 ] ;\n\n```\n\n例: 创建一张表tb_user，对应的结构如下\n\n|  id  |   name   | age  | gender |\n| :--: | :------: | :--: | :----: |\n|  1   |  令狐冲  |  28  |   男   |\n|  2   |  风清扬  |  32  |   男   |\n|  3   | 东方不败 |  34  |   男   |\n\n那么建表语句为：\n\n``` sql\n-- 创建表结构\nUSE icatw;\nCREATE TABLE tb_user(\nid INT COMMENT 主键id,\nname VARCHAR(50) COMMENT 名字,\nage INT COMMENT 年龄,\ngender VARCHAR(1) 性别\n)COMMENT 用户表 ;\n```\n\n##### 1.3.2.2 表操作-数据类型\n\nMySQL中的数据类型有很多，主要分为三类：**数值类型、字符串类型、日期时间类型**\n\n1）. 数值类型\n\n| 类型        | 大小   | 有符号(SIGNED)范围                                     | 无符号(UNSIGNED)范围                                       | 描述                  |\n| ----------- | ------ | ------------------------------------------------------ | ---------------------------------------------------------- | --------------------- |\n| TINYINT     | 1byte  | (-128，127)                                            | (0，255)                                                   | 小整 数值             |\n| SMALLINT    | 2bytes | (-32768，32767)                                        | (0，65535)                                                 | 大整 数值             |\n| MEDIUMINT   | 3bytes | (-8388608，8388607)                                    | (0，16777215)                                              | 大整 数值             |\n| INT/INTEGER | 4bytes | (-2147483648， 2147483647)                             | (0，4294967295)                                            | 大整 数值             |\n| BIGINT      | 8bytes | (-2^63，2^63-1)                                        | (0，2^64-1)                                                | 极大 整数 值          |\n| FLOAT       | 4bytes | (-3.402823466 E+38， 3.402823466351 E+38)              | 0 和 (1.175494351 E38，3.402823466 E+38)                   | 单精 度浮 点数 值     |\n| DOUBLE      | 8bytes | (-1.7976931348623157 E+308， 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308) | 双精 度浮 点数 值     |\n| DECIMAL     |        | 依赖于M(精度)和D(标度) 的值                            | 依赖于M(精度)和D(标度)的 值                                | 小数 值(精 确定 点数) |\n\n``` tex\n如:\n1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大\nage tinyint unsigned\n2). 分数 -- 总分100分, 最多出现一位小数\nscore double(4,1)\n通常使用DECIMAL 存储货币、钱\n```\n\n2）. 字符串类型\n\n|    类型  |   大小   | 描述 |\n| ---- | ---- | ---- |\n| CHAR | 0-255 bytes | 定长字符串(需要指定长度) |\n| VARCHAR | 0-65535 bytes | 变长字符串(需要指定长度) |\n| TINYBLOB | 0-255 bytes | 不超过255个字符的二进制数据 |\n| TINYTEXT | 0-255 bytes | 短文本字符串 |\n| BLOB | 0-65535 bytes | 二进制形式的长文本数据 |\n| TEXT | 0-65535 bytes | 长文本数据 |\n| MEDIUMBLOB | 0-16777215 bytes | 二进制形式的中等长度文本数据 |\n| MEDIUMTEXT | 0-16777215 bytes | 中等长度文本数据 |\n| LONGBLOB | 0-4 294 967 295 bytes | 二进制形式的极大文本数据 |\n| LONGTEXT | 0-4 294 967 295 bytes | 极大文本数据 |\n\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。\n\n``` tex\n如：\n1). 用户名 username ------> 长度不定, 最长不会超过50\nusername varchar(50)\n2). 性别 gender ---------> 存储值, 不是男,就是女\ngender char(1)\n3). 手机号 phone --------> 固定长度为11\nphone char(11)\n\n```\n\n3） . 日期时间类型\n\n| 类型      | 大 小 | 范围                                       | 格式                | 描述                      |\n| --------- | ----- | ------------------------------------------ | ------------------- | ------------------------- |\n| DATE      | 3     | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                    |\n| TIME      | 3     | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续 时间         |\n| YEAR      | 1     | 1901 至 2155                               | YYYY                | 年份值                    |\n| DATETIME  | 8     | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值         |\n| TIMESTAMP | 4     | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值，时间戳 |\n\n``` tex\n如:\n    1). 生日字段 birthday\n    birthday date\n    2). 创建时间 createtime\n    createtime datetime\n```\n\n##### 1.3.2.3 表操作-案例\n\n> 设计一张员工信息表，要求如下：\n>\n> 1. 编号（纯数字）\n> 2. 员工工号 (字符串类型，长度不超过10位)\n> 3. 员工姓名（字符串类型，长度不超过10位） \n> 4. 性别（男/女，存储一个汉字） \n> 5. 年龄（正常人年龄，不可能存储负数） \n> 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符） \n> 7. 入职时间（取值年月日即可）\n\n对应的建表语句如下：\n\n``` sql\ncreate table emp(\n    id int comment \'编号\',\n    workno varchar(10) comment \'工号\',\n    name varchar(10) comment \'姓名\',\n    gender char(1) comment \'性别\',\n    age tinyint unsigned comment \'年龄\',\n    idcard char(18) comment \'身份证号\',\n    entrydate date comment \'入职时间\'\n) comment \'员工表\';\n```\n\n建表之后可通过 `desc emp`查看员工表结构\n\n![image-20220524093825055](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240938173.png)\n\n至此，员工表就已经创建好了，当我们指定了字段的最大长度之后，超出最大长度将会报错。\n\n##### 1.3.2.4 表操作-修改\n\n1）. 添加字段\n\n``` sql\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\n```\n\n案例:\n\n为emp表增加一个新的字段\"昵称\"为nickname，类型为varchar(20)\n\n``` sql\n-- 添加字段\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT \'昵称\';\n```\n\n2）. 修改数据类型\n\n``` sql\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)\n```\n\n3）. 修改字段名和字段类型\n\n``` sql\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];\n```\n\n案例:\n\n将emp表的nickname字段修改为username,类型为varchar(30)\n\n``` sql\n-- 将emp表的nickname字段修改为username,类型为varchar(30)\nALTER TABLE emp CHANGE nickname username VARCHAR(30) COMMENT \'用户名\';\n```\n\n4）. 删除字段\n\n``` sql\nALTER TABLE 表名 DROP 字段名;\n```\n\n``` sql\n-- 删除emp表中的username\nALTER TABLE emp DROP username;\n```\n\n5）. 修改表名\n\n``` sql\nALTER TABLE 表名 RENAME TO 新表名;\n```\n\n案例:\n\n将emp表的表名修改为employee\n\n``` sql\n-- 修改表名ALTER TABLE 表名 RENAME TO 新表名;\nALTER  TABLE emp RENAME TO employee;\n```\n\n**总结:**\n\n​	**对表的修改操作通用格式为**:` ALTER TABLE 表名 操作名(ADD,MODIFY,CHANGE,DROP,RENAME TO)`\n\n##### 1.3.2.5 表操作-删除\n\n1）. 删除表\n\n``` sql\nDROP TABLE [IF EXISTS] 表名;\n```\n\n可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。\n\n案例: \n\n如果tb_user表存在，则删除tb_user表\n\n``` sql\nDROP TABLE IF EXISTS tb_user;\n```\n\n2）. 删除指定表，并重新创建表\n\n``` sql\nTRUNCATE TABLE 表名;\n```\n\n> 我的理解是 相当于清空数据，新建的表结构并不会发生变化\n\n### 1.4 图形化界面工具\n\nidea、Navicat\n\n这里我们使用idea的自带的数据库操作工具学习\n\n### 1.5 DML\n\n>  **DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作**。\n\n- 添加数据（INSERT） \n- 修改数据（UPDATE） \n- 删除数据（DELETE）\n\n#### 1.5.1 添加数据\n\n1）. 给指定字段添加数据\n\n``` sql\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\n```\n\n案例：给employee表所有的字段添加数据 ；\n\n```sql\n# 插入数据\ninsert into employee (id, workno, name, gender, age, idcard, entrydate)\nvalues (1,\'1\',\'icatw\',\'男\',18,\'431088200205180463\',\'2002-05-22\');\n```\n\n插入数据完成之后有两种方式查询数据库的数据\n\nA. 方式一\n\n在表名上双击，就可以看到这张表的数据。\n\n![image-20220524124505124](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205241245329.png)\n\nB. 方式二\n\n直接使用查询的SQL语句\n\n``` sql\nselect * from employee;\n```\n\n2）. 给全部字段添加数据\n\n``` sql\nINSERT INTO 表名 VALUES (值1, 值2, ...);\n```\n\n案例：给employee表的所有字段添加数据\n\n``` sql\n# 给所有字段添加数据\ninsert into employee values (2, \'2\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'2005-01-01\');\n```\n\n3）. 批量添加数据\n\n``` sql\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\n```\n\n``` sql\nINSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\n```\n\n案例：批量插入数据到employee表\n\n``` sql\ninsert into employee values(3,\'3\',\'韦一笑\',\'男\',38,\'123456789012345670\',\'2005-01-01\'),(4,\'4\',\'赵敏\',\'女\',18,\'123456789012345670\',\'2005-01-01\');\n\n```\n\n> 注意事项：\n>\n> - 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n> - 字符串和日期型数据应该包含在引号中。\n> - 插入的数据大小，应该在字段的规定范围内，不能超过最大值。\n\n#### 1.5.2 修改数据\n\n修改数据的具体语法为：\n\n```sql\nUPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;\n```\n\n**如果不指定where条件将修改所有行**\n\n案例：\n\nA. 修改id为1的数据，将那么修改为icatw2\n\n``` sql\nupdate employee set name=\'icatw2\' where id=1;\n```\n\nB. 修改id为1的数据，将name修改为小昭，gender修改为女\n\n``` sql\nupdate employee set name=\'小昭\' ,gender=\'女\' where id=1;\n```\n\nC. 将所有员工的入职日期修改为2008-01-01\n\n``` sql\nupdate employee set entrydate=\'2008-01-01\'\n```\n\n> 注意事项：\n>\n> ​		**修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。**\n\n#### 1.5.3 删除数据\n\n语法：\n\n``` sql\ndelete from 表名 [where 条件];\n```\n\n案例：\n\nA. 删除gender为女的员工\n\n``` sql\ndelete from employee where gender=\'女\';\n```\n\nB. 删除所有员工\n\n``` sql\ndelete from employee\n```\n\n> 注意事项: \n>\n> - DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。\n> - DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n> - 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击 Execute即可。\n\n\n\n### 1.6 DDL\n\n> **DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。** \n\n查询关键字: **SELECT** \n\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站， 在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\n\n首先我们准备数据\n\n``` sql\n# 添加数据\ndrop table if exists employee;\ncreate table emp\n(\n    id          int comment \'编号\',\n    workno      varchar(10) comment \'工号\',\n    name        varchar(10) comment \'姓名\',\n    gender      char(1) comment \'性别\',\n    age         tinyint unsigned comment \'年龄\',\n    idcard      char(18) comment \'身份证号\',\n    workaddress varchar(50) comment \'工作地址\',\n    entrydate   date comment \'入职时间\'\n) comment \'员工表\';\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (1, \'00001\', \'柳岩666\', \'女\', 20, \'123456789012345678\', \'北京\', \'2000-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (2, \'00002\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'北京\', \'2005-09-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (3, \'00003\', \'韦一笑\', \'男\', 38, \'123456789712345670\', \'上海\', \'2005-08-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (4, \'00004\', \'赵敏\', \'女\', 18, \'123456757123845670\', \'北京\', \'2009-12-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (5, \'00005\', \'小昭\', \'女\', 16, \'123456769012345678\', \'上海\', \'2007-07-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (6, \'00006\', \'杨逍\', \'男\', 28, \'12345678931234567X\', \'北京\', \'2006-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (7, \'00007\', \'范瑶\', \'男\', 40, \'123456789212345670\', \'北京\', \'2005-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (8, \'00008\', \'黛绮丝\', \'女\', 38, \'123456157123645670\', \'天津\', \'2015-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (9, \'00009\', \'范凉凉\', \'女\', 45, \'123156789012345678\', \'北京\', \'2010-04-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (10, \'00010\', \'陈友谅\', \'男\', 53, \'123456789012345670\', \'上海\', \'2011-01-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (11, \'00011\', \'张士诚\', \'男\', 55, \'123567897123465670\', \'江苏\', \'2015-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (12, \'00012\', \'常遇春\', \'男\', 32, \'123446757152345670\', \'北京\', \'2004-02-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (13, \'00013\', \'张三丰\', \'男\', 88, \'123656789012345678\', \'江苏\', \'2020-11-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (14, \'00014\', \'灭绝\', \'女\', 65, \'123456719012345670\', \'西安\', \'2019-05-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (15, \'00015\', \'胡青牛\', \'男\', 70, \'12345674971234567X\', \'西安\', \'2018-04-01\');\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\nVALUES (16, \'00016\', \'周芷若\', \'女\', 18, null, \'北京\', \'2012-06-01\');\n\n```\n\n#### 1.6.1 基本语法\n\nDDL查询语句，语法结构如下：\n\n``` sql\nSELECT\n字段列表\nFROM\n表名列表\nWHERE\n条件列表\nGROUP BY\n分组字段列表\nHAVING\n分组后条件列表\nORDER BY\n排序字段列表\nLIMIT\n分页参数\n\n```\n\n大致可以拆分为以下几个部分：\n\n- 基本查询（不带任何条件） \n- 条件查询（WHERE） \n- 聚合函数（count、max、min、avg、sum） \n- 分组查询（group by） \n- 排序查询（order by） \n- 分页查询（limit）\n\n#### 1.6.2基本查询\n\n在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：\n\n1）. 查询多个字段\n\n``` sql\nselect 字段1,字段2,字段3 ... from 表名;\n```\n\n``` sql\nSELECT * FROM 表名 ;\n```\n\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\n\n2）. 字段设置别名\n\n``` sql\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;\n```\n\n``` sql\n# as 也可省略\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\n```\n\n3）. 去除重复记录\n\n``` sql\nselect distinct 字段列表 from 表名;\n```\n\n案例：\n\nA. 查询指定字段 name，workno，age并返回\n\n``` sql\nselect name,workno,age from emp;\n```\n\nB. 查询返回所有字段\n\n``` sql\nselect id,workno,name,gender,age,idcard,workaddress,entrydate from emp;\n```\n\n``` sql\nselect * from emp;\n```\n\nC. 查询所有员工的工作地址，起别名\n\n``` sql\nselect workaddress as \'工作地址\' from emp;\n```\n\n``` sql\n-- as可以省略\nselect workaddress \'工作地址\' from emp;\n```\n\nD. 查询公司员工的上班地址有哪些（去重）\n\n``` sql\nselect distinct workaddress \'工作地址\' from emp;\n```\n\n#### 1.6.3 条件查询\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 where 条件列表;\n```\n\n2）. 条件\n\n常用的比较运算符如下：\n\n| 比较运算符          | 功能                                     |\n| ------------------- | ---------------------------------------- |\n| >                   | 大于                                     |\n| >=                  | 大于等于                                 |\n| <                   | 小于                                     |\n| <=                  | 小于等于                                 |\n| =                   | 等于                                     |\n| <> 或 !=            | 不等于                                   |\n| BETWEEN ... AND ... | 在某个范围之内(含最小、最大值)           |\n| IN(...)             | 在in之后的列表中的值，多选一             |\n| LIKE 占位符         | 模糊匹配(_匹配单个字符, %匹配任意个字符) |\n| IS NULL             | 是NULL                                   |\n\n常用的逻辑运算符如下：\n\n|逻辑运算符|功能|\n|----|----|\n|AND 或 &&|并且 (多个条件同时成立)|\n|OR 或 \\|\\||或者 (多个条件任意一个成立)|\n|NOT 或 !|非 , 不是|\n\n案例：\n\nA. 查询年龄等于88的员工\n\n``` sql\nselect * from emp where age=88;\n```\n\nB. 查询年龄小于20的员工信息\n\n``` sql\nselect * from emp where age<20;\n```\n\nC. 查询年龄小于等于20的员工信息\n\n``` sql\nselect * from emp where age<=20;\n```\n\nD. 查询没有身份证号的员工信息\n\n``` sql\nselect * from emp where idcard is null;\n```\n\nE. 查询有身份证号的员工信息\n\n``` sql\nselect * from emp where idcard is not null;\n```\n\nF. 查询年龄不等于88的员工信息\n\n``` sql\nselect * from emp where age!=88;\n```\n\n``` sql\nselect * from emp where age<>88;\n```\n\nG. 查询年龄在15岁（包含）到20岁（包含）之间的员工信息\n\n``` sql\nselect * from emp where age >=15 and age <= 20;\nselect * from emp where age>=15 && age <=20;\nselect * from emp where age between 15 and 20;\n```\n\nH. 查询性别为女 且年龄小于25的员工信息\n\n``` sql\nselect * from emp where gender =\'女\' and age<25;\n```\n\nI. 查询年龄等于18或20或40的员工信息\n\n``` sql\nselect * from emp where age =18 or age =20 or age =40;\nselect * from emp where age in(18,20,40)\n```\n\nJ. 查询姓名为两个字的员工信息 _ %\n\n``` sql\nselect * from emp where name like \'__\'\n```\n\nK. 查询身份证号最后以为是x的员工信息\n\n``` sql\nselect * from emp where idcard like \'%x\';\nselect * from emp where idcard like \'_________________x\';\n```\n\n#### 1.6.4 聚合函数\n\n1）. 介绍\n\n将一列数据作为一个整体，进行纵向计算。\n\n2）. 常见的聚合函数\n\n| 函数  | 功能     |\n| ----- | -------- |\n| count | 统计数量 |\n| max   | 最大值   |\n| min   | 最小值   |\n| avg   | 平均值   |\n| sum   | 求和     |\n\n3）. 语法\n\n``` sql\nselect 聚合函数（字段列表） from 表名;\n```\n\n> 注意：null值是不参与所有聚合函数运算的。\n\n案例：\n\nA. 统计该企业员工数量\n\n``` sql\nselect count(*) from emp; -- 统计的是总记录数,也就是记录行数\nselect count(idcard) from emp; -- 统计的是idcard字段不为null的记录数\n```\n\n对于count聚合函数，统计符合条件的总记录数，还可以通过count（数字/字符串）的形式进行统计查询，比如：\n\n``` sql\nselect count(1) from emp;\n-- 效果等于 select count(*) from emp;\n```\n\nB. 统计该企业员工的平均年龄\n\n``` sql\nselect avg(age) from emp;\n```\n\nC. 统计该企业员工的最大年龄\n\n``` sql\nselect max(age) from emp;\n```\n\nD. 统计该企业员工的最小年龄\n\n``` sql\nselect min(age) from emp;\n```\n\nE. 统计西安地区员工的年龄之和\n\n``` sql\nselect sum(age) from emp where wordaddress=\'西安\';\n```\n\n#### 1.6.5 分组查询\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\n```\n\n2）. where与having区别\n\n- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n- 判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n> 注意事项：\n>\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n> - 执行顺序: where > 聚合函数 > having 。\n> - 支持多字段分组, 具体语法为 : group by columnA,columnB\n\n案例：\n\nA. 根据性别分组，统计男性员工和女性员工的数量\n\n``` sql\nselect gender,count(*) from emp group by gender;\n```\n\n![image-20220525150636926](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251506016.png)\n\nB. 根据性别分组，统计男性员工和女性员工的平均年龄\n\n``` sql\nselect gender,avg(age) from emp group by gender;\n```\n\n![image-20220525150757361](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251507435.png)\n\nC. 查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址\n\n``` sql\nselect workaddress, count(*) address_count\nfrom emp\nwhere age < 45\ngroup by workaddress\nhaving address_count >= 3;\n```\n\n![image-20220525151427330](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251514414.png)\n\nD. 统计各个工作地址上班的男性及女性员工的数量\n\n``` sql\nselect workaddress \'地区\', gender \'性别\', count(*) \'数量\'\nfrom emp\ngroup by gender, workaddress;\n```\n\n#### 1.6.6 排序查询\n\n排序是日常开发只能够非常常见的一个操作，分为升序和降序排序\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;\n```\n\n2）. 排序方式\n\n- ASC：升序（默认值）\n- DESC：降序\n\n> 注意事项\n>\n> - 如果是升序, 可以不指定排序方式ASC ; \n> - 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\n\n案例：\n\nA. 根据年龄对公司的员工进行升序排序\n\n``` sql\nselect * from emp order by age asc;\nselect * from emp order by age;\n```\n\nB. 根据入职时间，对员工进行降序排序\n\n``` sql\nselect * from emp order by entry date desc;\n```\n\nC. 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序\n\n``` sql\nselect * from emp order by age asc , entrydate desc;\n```\n\n#### 1.6.7 分页查询\n\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台 都需要借助于数据库的分页操作。\n\n1）. 语法\n\n``` sql\nselect 字段列表 from 表名 limit 起始索引 , 查询记录数;\n```\n\n> 注意事项: \n>\n> - **起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数**。 \n> - 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 \n> - 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10\n\n案例：\n\nA. 查询第一页员工数据，每页显示十条记录\n\n``` sql\n-- 起始索引为 （查询页码）-1*每页显示记录数\nselect * from emp limit 0,10;\n-- 查询的为第一页数据，起始索引可以省略\nselect * from emp limit 10;\n```\n\nB. 查询第二页员工数据，每页展示10条记录\n\n--------> (页码-1)*页展示记录数\n\n``` sql\n-- 需要查询的为第二页员工数据\n-- 起始索引等于 （查询页码-1）*每页显示记录数\n-- 因此，此处起始索引为（2-1）*10\nselect * from emp limit 10,10;\n```\n\n#### 1.6.8 案例\n\n1）. 查询年龄为20,21,22,23岁的员工信息。\n\n``` sql\nselect * from emp where age in(20,21,22,23);\n```\n\n2）. 查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\n\n``` sql\n#  查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\nselect *\nfrom emp\nwhere gender = \'男\'\n  and age between 20 and 40\n  and name like \'___\';\n```\n\n3）. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\n\n``` sql\n# 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\nselect gender, count(*)\nfrom emp\nwhere age < 60\ngroup by gender;\n```\n\n4）. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按 入职时间降序排序。\n\n``` sql\nselect name, age\nfrom emp\nwhere age <= 35\norder by age, entrydate desc;\n```\n\n5）.  查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。\n\n``` sql\nselect *\nfrom emp\nwhere gender = \'男\'\n  and age between 20 and 40\norder by age, entrydate desc\nlimit 5;\n```\n\n#### 1.6.9 执行顺序\n\n![image-20220525154935887](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251549982.png)\n\n**DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...**\n\n### 1.7 DCL\n\n> DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。\n\n![image-20220525155152013](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251551105.png)\n\n#### 1.7.1 管理用户\n\n1）. 查询用户\n\n``` sql\nselect * from mysql.user;\n```\n\n查询结果如下：\n\n![image-20220525155335839](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251619656.png)\n\n**其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户**\n\n2）. 创建用户\n\n``` sql\ncreate user \'用户名\'@\'主机名\' identified by \'密码\';\n```\n\n3）. 修改用户密码\n\n``` sql\nalter user \'用户名\'@\'主机名\' identified with mysql_native_password by \'新密码\';\n```\n\n4）. 删除用户\n\n``` sql\ndrop user \'用户名\'@\'主机名\';\n```\n\n> 注意事项: \n>\n> - 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n> - 主机名可以使用 % 通配。 \n> - 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。\n\n案例：\n\nA. 创建用户icat, 只能够在当前主机localhost访问, 密码123456;\n\n``` sql\ncreate user \'icat\'@\'localhost\' identified by \'123456\';\n```\n\nB. 创建用户icatw, 可以在任意主机访问该数据库, 密码123456;\n\n``` sql\ncreate user \'icatw\'@\'%\' identified by \'123456\';\n```\n\nC. 修改用户icatw的访问密码为1234;\n\n``` sql\nalter user \'icatw\'@\'%\' identified with mysql_native_password by \'1234\';\n```\n\nD. 删除 icat@localhost 用户\n\n``` sql\ndrop user \'icat\'@\'localhost\';\n```\n\n#### 1.7.2 权限控制\n\nMySQL中定义了很多种权限，但是常用的就以下几种：\n\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| ALL, ALL PRIVILEGES | 所有权限           |\n| SELECT              | 查询数据           |\n| INSERT              | 插入数据           |\n| UPDATE              | 修改数据           |\n| DELETE              | 删除数据           |\n| ALTER               | 修改表             |\n| DROP                | 删除数据库/表/视图 |\n| CREATE              | 创建数据库/表      |\n\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html)。\n\n1）. 查询权限\n\n``` sql\nSHOW GRANTS FOR \'用户名\'@\'主机名\' ;\n```\n\n2）. 授予权限\n\n``` sql\nGRANT 权限列表 ON 数据库名.表名 TO \'用户名\'@\'主机名\';\n```\n\n3）. 撤销权限\n\n``` sql\nREVOKE 权限列表 ON 数据库名.表名 FROM \'用户名\'@\'主机名\';\n```\n\n> 注意事项： \n>\n> - 多个权限之间，使用逗号分隔 \n> - 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\n\n案例: \n\nA. 查询 \'heima\'@\'%\' 用户的权限\n\n``` sql\nshow grants for \'heima\'@\'%\';\n```\n\nB. 授予 \'heima\'@\'%\' 用户itcast数据库所有表的所有操作权限\n\n``` sql\ngrant all on itcast.* to \'heima\'@\'%\'\n```\n\nC. 撤销 \'heima\'@\'%\' 用户的itcast数据库的所有权限\n\n``` sql\nrevoke all on itcast.* from \'heima\'@\'%\';\n```\n\n\n\n## 2. 函数\n\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那 么，函数到底在哪儿使用呢？ 我们先来看两个场景：\n\n![image-20220525162834366](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251628459.png)\n\n1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能 够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计 算出天数呢？ \n\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的 分数值，如98/75，如何快速判定分数的等级呢？ 其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。\n\n其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。 \n\nMySQL中的函数主要分为以下四类： **字符串函数、数值函数、日期函数、流程函数。**\n\n### 2.1 字符串函数\n\nMySQL中内置了很多字符串函数，常用的几个如下：\n\n| 函数                     | 功能                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串               |\n| LOWER(str)               | 将字符串str全部转为小写                                    |\n| UPPER(str)               | 将字符串str全部转为大写                                    |\n| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 |\n| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 |\n| TRIM(str)                | 去掉字符串头部和尾部的空格                                 |\n| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串            |\n\n演示如下：\n\nA. concat：字符串拼接\n\n``` sql\nselect concat(\'Hello\' , \' MySQL\');\n```\n\n结果如下：\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251651650.png\" alt=\"image-20220525165104555\" style=\"zoom:67%;\" />\n\nB. lower : 全部转小写\n\n``` sql\nselect lower(\'Hello\');\n```\n\n![image-20220525165228376](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251652464.png)\n\nC. upper : 全部转大写\n\n``` sql\nselect upper(\'Hello\');\n```\n\n![image-20220525165323592](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251653679.png)\n\nD.  lpad : 左填充\n\n``` sql\nselect lpad(\'01\', 5, \'-\');\n```\n\n![image-20220525165433666](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251654755.png)\n\nE. rpad : 右填充\n\n``` sql\nselect rpad(\'01\', 5, \'-\');\n```\n\n![image-20220525165713762](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251657320.png)\n\nF. trim : 去除空格\n\n``` sql\nselect trim(\' Hello MySQL \');\n```\n\nG. substring : 截取子字符串\n\n``` sql\nselect substring(\'Hello MySQL\',1,5);\n```\n\n案例：\n\n![image-20220525174936078](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251749181.png)\n\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员 工的工号应该为00001。\n\n``` sql\nupdate emp set workno = lpad(workno, 5, \'0\');\n```\n\n处理完毕后, 具体的数据为:\n\n![image-20220525175223093](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251752289.png)\n\n### 2.2 数值函数\n\n常见的数值函数如下：\n\n| 函数       | 功能                               |\n| ---------- | ---------------------------------- |\n| CEIL(x)    | 向上取整                           |\n| FLOOR(x)   | 向下取整                           |\n| MOD(x,y)   | 返回x/y的模                        |\n| RAND()     | 返回0~1内的随机数                  |\n| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |\n\n演示如下：\n\nA. ceil：向上取整\n\n``` sql\nselect ceil(1.1);\n```\n\nB. floor：向下取整\n\n``` sql\nselect floor(1.9)\n```\n\nC. mod：取模\n\n``` sql\nselect mod(7,4);\n```\n\nD. rand：获取随机数\n\n``` sql\nselect rand();\n```\n\nE. round：四舍五入\n\n``` sql\nselect round(2.344,2);\n```\n\n案例： \n\n通过数据库的函数，生成一个六位数的随机验证码。\n\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础 上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\n\n``` sql\nselect lpad(round(rand()*1000000 , 0), 6, \'0\');\n```\n\n### 2.3 日期函数\n\n常见的日期函数如下：\n\n| 函数                               | 功能                                               |\n| ---------------------------------- | -------------------------------------------------- |\n| CURDATE()                          | 返回当前日期                                       |\n| CURTIME()                          | 返回当前时间                                       |\n| NOW()                              | 返回当前日期和时间                                 |\n| YEAR(date)                         | 获取指定date的年份                                 |\n| MONTH(date)                        | 获取指定date的月份                                 |\n| DAY(date)                          | 获取指定date的日期                                 |\n| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的 时间值 |\n| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天 数      |\n\n演示如下：\n\nA. curdate：当前日期\n\n``` sql\nselect curdate();\n```\n\nB. curtime：当前时间\n\n``` SQL\nselect curtime();\n```\n\nC. now：当前日期和时间\n\n``` sql\nselect now();\n```\n\nD. YEAR , MONTH , DAY：当前年、月、日\n\n``` sql\nselect YEAR(now());\nselect MONTH(now());\nselect DAY(now());\n```\n\nE. date_add：增加指定的时间间隔\n\n``` sql\nselect date_add(now(), INTERVAL 70 YEAR );\n```\n\nF. datediff：获取两个日期相差的天数\n\n``` sql\nselect datediff(\'2021-10-01\', \'2021-12-01\');\n```\n\n案例： \n\n查询所有员工的入职天数，并根据入职天数倒序排序。 \n\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\n\n``` sql\nselect name, datediff(curdate(), entrydate) as \'entrydays\' from emp order by entrydays desc;\n\n```\n\n### 2.4 流程函数\n\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n| 函数                                                         | 功能                                                       |\n| ------------------------------------------------------------ | ---------------------------------------------------------- |\n| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回 f                       |\n| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则 返回value2              |\n| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |\n| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |\n演示如下：\n\nA. if\n\n``` sql\nselect if(false, \'Ok\', \'Error\');\n```\n\nB. ifnull \n\n``` sql\nselect ifnull(\'Ok\',\'Default\');\nselect ifnull(\'\',\'Default\');\n-- 只有这个才会输出default\nselect ifnull(null,\'Default\');\n```\n\nC. case when then else end\n\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----> 一线城市 , 其他 ----> 二线城市)\n\n``` sql\nselect name,\n       (case workaddress\n            when \'北京\' then \'一线城市\'\n            when \'上海\' then \'一线城市\'\n            else\n                \'二线城市\' end) as \'工作地址\'\nfrom emp;\n```\n\n案例：\n\n将学生表按成绩分类\n\n首先，准备数据\n\n``` sql\ncreate table score\n(\n    id      int comment \'ID\',\n    name    varchar(20) comment \'姓名\',\n    math    int comment \'数学\',\n    english int comment \'英语\',\n    chinese int comment \'语文\'\n) comment \'学员成绩表\';\ninsert into score(id, name, math, english, chinese)\nVALUES (1, \'Tom\', 67, 88, 95),\n       (2, \'Rose\', 23, 66, 90),\n       (3, \'Jack\', 56, 98, 76);\n\n```\n\n具体SQL如下\n\n``` sql\nselect id,\n       name,\n       (case when math >= 85 then \'优秀\' when math >= 60 then \'及格\' else \'不及格\' end)\n                \'数学\',\n       (case\n            when english >= 85 then \'优秀\'\n            when english >= 60 then \'及格\'\n            else \'不及格\'\n           end) \'英语\',\n       (case\n            when chinese >= 85 then \'优秀\'\n            when chinese >= 60 then \'及格\'\n            else \'不及格\'\n           end) \'语文\'\nfrom score;\n```\n\n![image-20220525181610736](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251816834.png)\n\nMySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景， 思考一下需要用到什么样的函数来实现? \n\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------> \n\n答案: datediff \n\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------> \n\n答案: case ... when ...\n\n## 3. 约束\n\n### 3.1 概述\n\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n\n目的：保证数据库中数据的正确、有效性和完整性。\n\n分类：\n\n| 约束                      | 描述                                                      | 关键字      |\n| ------------------------- | --------------------------------------------------------- | ----------- |\n| 非空约束                  | 限制该字段的数据不能为null                                | NOT NULL    |\n| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                    | UNIQUE      |\n| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                  | PRIMARY KEY |\n| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值            | DEFAULT     |\n| 检查约束(8.0.16版本 之后) | 保证字段值满足某一个条件                                  | CHECK       |\n| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致 性和完整性 | FOREIGN KEY |\n\n> 注意：**约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。**\n\n### 3.2 约束演示\n\n案例需求： 根据需求，完成表结构的创建。需求如下：\n\n| 字段名 | 字段含 义   | 字段类型    | 约束条件                   | 约束关键字                  |\n| ------ | ----------- | ----------- | -------------------------- | --------------------------- |\n| id     | ID唯一 标识 | int         | 主键，并且自动增长         | PRIMARY KEY, AUTO_INCREMENT |\n| name   | 姓名        | varchar(10) | 不为空，并且唯一           | NOT NULL , UNIQUE           |\n| age    | 年龄        | int         | 大于0，并且小于等 于120    | CHECK                       |\n| status | 状态        | char(1)     | 如果没有指定该值， 默认为1 | DEFAULT                     |\n| gender | 性别        | char(1)     | 无                         |                             |\n\n对应的建表语句为：\n\n``` sql\nCREATE TABLE tb_user\n(\n    id     int AUTO_INCREMENT PRIMARY KEY COMMENT \'ID唯一标识\',\n    name   varchar(10) NOT NULL UNIQUE COMMENT \'姓名\',\n    age    int check (age > 0 && age <= 120) COMMENT \'年龄\',\n    status char(1) default \'1\' COMMENT \'状态\',\n    gender char(1) COMMENT \'性别\'\n);\n```\n\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。\n\n### 3.3 外键约束\n\n#### 3.3.1 介绍\n\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\n\n准备数据\n\n``` sql\ncreate table dept\n(\n    id   int auto_increment comment \'ID\' primary key,\n    name varchar(50) not null comment \'部门名称\'\n) comment \'部门表\';\nINSERT INTO dept (id, name)\nVALUES (1, \'研发部\'),\n       (2, \'市场部\'),\n       (3, \'财务部\'),\n       (4,\n        \'销售部\'),\n       (5, \'总经办\');\ndrop table if exists icatw.emp;\ncreate table emp\n(\n    id        int auto_increment comment \'ID\' primary key,\n    name      varchar(50) not null comment \'姓名\',\n    age       int comment \'年龄\',\n    job       varchar(20) comment \'职位\',\n    salary    int comment \'薪资\',\n    entrydate date comment \'入职时间\',\n    managerid int comment \'直属领导ID\',\n    dept_id   int comment \'部门ID\'\n) comment \'员工表\';\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\n       (2, \'张无忌\', 20,\n        \'项目经理\', 12500, \'2005-12-05\', 1, 1),\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1);\n\n```\n\n\n\n#### 3.3.2 语法\n\n1）. 添加外键\n\n``` sql\nCREATE TABLE 表名(\n字段名 数据类型,\n...\n[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)\n);\n```\n\n``` sql\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)\nREFERENCES 主表 (主表列名) ;\n```\n\n案例：\n\n为emp表的dept_id字段添加外键约束，关联dept表的主键id。\n\n``` sql\nalter table emp\n    add constraint fk foreign key (dept_id) references dept (id);\n```\n\n![image-20220525212454577](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252124722.png)\n\n**当添加外键约束之后，不能直接删除父表的记录，需要先删除子表所关联数据，否则会报错。**\n\n2）. 删除外键\n\n``` sql\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n```\n\n案例：\n\n删除emp表的外键fk。\n\n``` sql\nalter table emp\n    drop foreign key fk;\n```\n\n#### 3.3.3 删除/更新行为\n\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:\n\n| 行为        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为 |\n| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为 |\n| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。 |\n| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。 |\n| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)  |\n\n具体语法为：\n\n``` sql\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\n主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;\n```\n\n## 4. 多表查询\n\n### 4.1 多表关系\n\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n- 一对多(多对一) \n- 多对多 \n- 一对一\n\n#### 4.1.1 一对多\n\n- 案例：部门与员工的关系\n- 关系：一个部门对应多名员工，一个员工对应一个部门\n- 实现：在多的一方建立外键，指向另一方的主键\n\n![image-20220525213949714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252139778.png)\n\n#### 4.1.2 多对多\n\n- 案例：学生与课程的关系\n- 关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n- 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n![image-20220525214004144](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252140207.png)\n\n对应的SQL脚本：\n\n``` sql\ncreate table student\n(\n    id   int auto_increment primary key comment \'主键ID\',\n    name varchar(10) comment \'姓名\',\n    no   varchar(10) comment \'学号\'\n) comment \'学生表\';\ninsert into student\nvalues (null, \'黛绮丝\', \'2000100101\'),\n       (null, \'谢逊\',\n        \'2000100102\'),\n       (null, \'殷天正\', \'2000100103\'),\n       (null, \'韦一笑\', \'2000100104\');\ncreate table course\n(\n    id   int auto_increment primary key comment \'主键ID\',\n    name varchar(10) comment \'课程名称\'\n) comment \'课程表\';\ninsert into course\nvalues (null, \'Java\'),\n       (null, \'PHP\'),\n       (null, \'MySQL\'),\n       (null, \'Hadoop\');\n\ncreate table student_course\n(\n    id        int auto_increment comment \'主键\' primary key,\n    studentid int not null comment \'学生ID\',\n    courseid  int not null comment \'课程ID\',\n    constraint fk_courseid foreign key (courseid) references course (id),\n    constraint fk_studentid foreign key (studentid) references student (id)\n) comment \'学生课程中间表\';\ninsert into student_course\nvalues (null, 1, 1),\n       (null, 1, 2),\n       (null, 1, 3),\n       (null, 2, 2),\n       (null, 2, 3),\n       (null, 3, 4);\n```\n\n#### 4.1.3 一对一\n\n- 案例：用户与用户详情的关系\n- 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n- 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n\n![image-20220525214650949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252146016.png)\n\n对应的SQL脚本：\n\n``` sql\ncreate table if not exists tb_user\n(\n    id     int auto_increment primary key comment \'主键ID\',\n    name   varchar(10) comment \'姓名\',\n    age    int comment \'年龄\',\n    gender char(1) comment \'1: 男 , 2: 女\',\n    phone  char(11) comment \'手机号\'\n) comment \'用户基本信息表\';\ncreate table if not exists tb_user_edu\n(\n    id            int auto_increment primary key comment \'主键ID\',\n    degree        varchar(20) comment \'学历\',\n    major         varchar(50) comment \'专业\',\n    primaryschool varchar(50) comment \'小学\',\n    middleschool  varchar(50) comment \'中学\',\n\n    university    varchar(50) comment \'大学\',\n    userid        int unique comment \'用户ID\',\n    constraint fk_userid foreign key (userid) references tb_user (id)\n) comment \'用户教育信息表\';\ninsert into tb_user(id, name, age, gender, phone)\nvalues (null, \'黄渤\', 45, \'1\', \'18800001111\'),\n       (null, \'冰冰\', 35, \'2\', \'18800002222\'),\n       (null, \'码云\', 55, \'1\', \'18800008888\'),\n       (null, \'李彦宏\', 50, \'1\', \'18800009999\');\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,\n                        university, userid)\nvalues (null, \'本科\', \'舞蹈\', \'静安区第一小学\', \'静安区第一中学\', \'北京舞蹈学院\', 1),\n       (null, \'硕士\', \'表演\', \'朝阳区第一小学\', \'朝阳区第一中学\', \'北京电影学院\', 2),\n       (null, \'本科\', \'英语\', \'杭州市第一小学\', \'杭州市第一中学\', \'杭州师范大学\', 3),\n       (null, \'本科\', \'应用数学\', \'阳泉第一小学\', \'阳泉区第一中学\', \'清华大学\', 4);\n```\n\n### 4.2 多表查询概述\n\n#### 4.2.1 数据准备\n\n1）. 删除之前emp，dept表的测试数据\n\n2）. 执行如下脚本，创建emp表与dept表并插入测试数据\n\n``` sql\n-- 创建dept表，并插入数据\ndrop table if exists dept;\ncreate table dept\n(\n    id   int auto_increment comment \'ID\' primary key,\n    name varchar(50) not null comment \'部门名称\'\n) comment \'部门表\';\nINSERT INTO dept (id, name)\nVALUES (1, \'研发部\'),\n       (2, \'市场部\'),\n       (3, \'财务部\'),\n       (4,\n        \'销售部\'),\n       (5, \'总经办\'),\n       (6, \'人事部\');\n-- 创建emp表，并插入数据\ndrop table if exists emp;\ncreate table emp\n(\n    id        int auto_increment comment \'ID\' primary key,\n    name      varchar(50) not null comment \'姓名\',\n    age       int comment \'年龄\',\n    job       varchar(20) comment \'职位\',\n    salary    int comment \'薪资\',\n    entrydate date comment \'入职时间\',\n    managerid int comment \'直属领导ID\',\n    dept_id   int comment \'部门ID\'\n) comment \'员工表\';\n-- 添加外键\nalter table emp\n    add constraint fk_emp_dept_id foreign key (dept_id) references\n        dept (id);\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\n       (2, \'张无忌\', 20, \'项目经理\', 12500, \'2005-12-05\', 1, 1),\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1),\n       (7, \'灭绝\', 60, \'财务总监\', 8500, \'2002-09-12\', 1, 3),\n       (8, \'周芷若\', 19, \'会计\', 48000, \'2006-06-02\', 7, 3),\n       (9, \'丁敏君\', 23, \'出纳\', 5250, \'2009-05-13\', 7, 3),\n       (10, \'赵敏\', 20, \'市场部总监\', 12500, \'2004-10-12\', 1, 2),\n       (11, \'鹿杖客\', 56, \'职员\', 3750, \'2006-10-03\', 10, 2),\n       (12, \'鹤笔翁\', 19, \'职员\', 3750, \'2007-05-09\', 10, 2),\n       (13, \'方东白\', 19, \'职员\', 5500, \'2009-02-12\', 10, 2),\n       (14, \'张三丰\', 88, \'销售总监\', 14000, \'2004-10-12\', 1, 4),\n       (15, \'俞莲舟\', 38, \'销售\', 4600, \'2004-10-12\', 14, 4),\n       (16, \'宋远桥\', 40, \'销售\', 4600, \'2004-10-12\', 14, 4),\n       (17, \'陈友谅\', 42, null, 2000, \'2011-10-12\', 1, null);\n```\n\ndept表共6条记录，emp表共17条记录。\n\n#### 4.2.2 概述\n\n多表查询就是指从多张表中查询数据。\n\n原来查询单表数据，执行的SQL形式为：select * from emp; \n\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，\n\n如： `select * from emp , dept` ; 具体的执行结果如下:\n\n![image-20220526085113395](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260851744.png)\n\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。\n\n**笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。**\n\n![image-20220526085212058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260853700.png)\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\n![image-20220526085430499](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260854637.png)\n\n![image-20220526085521044](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260855198.png)\n\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\n\n``` sql\nselect *\nfrom icatw.emp,\n     icatw.dept\nwhere emp.dept_id = dept.id;\n```\n\n![image-20220526085719946](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260857204.png)\n\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。\n\n#### 4.2.3 分类\n\n- 连接查询\n  - 内连接：相当于查询A、B交集部分数据 \n  - 外连接： \n  - 左外连接：查询左表所有数据，以及两张表交集部分数据 \n  - 右外连接：查询右表所有数据，以及两张表交集部分数据 \n  - 自连接：当前表与自身的连接查询，自连接必须使用表别名\n- 子查询\n\n![image-20220526090006541](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900675.png)\n\n### 4.3 内连接\n\n![image-20220526090056077](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900217.png)\n\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构\n\n1）. 隐式内连接\n\n``` sql\nselect 字段列表 from 表1 , 表2 where 条件...;\n```\n\n2）. 显式内连接\n\n``` sql\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;\n```\n\n案例：\n\nA. 查询每一个员工的姓名，及关联的部门的名称（隐式内连接）\n\n表结构：emp , dept\n\n连接条件：emp.dept_id = dept.id\n\n``` sql\nselect emp.name, dept.name\nfrom emp,\n     dept\nwhere emp.dept_id = dept.id;\n\n-- 为每一张表起别名,简化SQL编写\nselect e.name, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n![image-20220526091506843](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260915000.png)\n\nB. 查询每一个员工的姓名，及关联的部门的名称（显示内连接实现）\n\n--- INNER JOIN ... ON ...\n\n表结构：emp，dept\n\n连接条件：emp.dept_id = dept.id\n\n``` sql\nselect e.name, d.name\nfrom emp e\n         inner join dept d on e.dept_id = d.id;\n         \n-- 为每一张表起别名,简化SQL编写\nselect e.name, d.name\nfrom emp e\n         join dept d on e.dept_id = d.id;\n```\n\n> 表的别名：\n>\n> - tablea as 别名1 ,  tableb as 别名2 ;\n> -  tablea 别名1 , tableb 别名2 ;\n>\n> 注意事项：\n>\n> ​		一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\n\n### 4.4 外连接\n\n![image-20220526105436328](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261054413.png)\n\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\n\n1）. 左外连接\n\n``` sql\nselect 字段列表 from 表1 left [outer] join 表2 on 条件 ...;\n```\n\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n2）. 右外连接\n\n``` sql\nselect 字段列表 from 表1 right [outer] join 表2 on 条件...;\n```\n\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n案例: \n\nA. 查询emp表的所有数据, 和对应的部门信息 \n\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。 \n\n表结构: emp, dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.*, d.name\nfrom icatw.emp e\n         left join icatw.dept d on e.dept_id = d.id;\n\nselect e.*, d.name\nfrom emp e\n         left outer join dept d on e.dept_id = d.id;\n```\n\nB. 查询dept表的所有数据, 和对应的员工信息(右外连接)\n\n由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 \n\n表结构: emp, dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;\n\nselect d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;\n```\n\n> 注意事项：\n>\n> ​		左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n\n### 4.5 自连接\n\n#### 4.5.1 自连接查询\n\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。下面是自连接 的查询语法：\n\n``` sql\nselect 字段列表 from 表A 别名A join 表A 别名B on 条件...;\n```\n\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\n\n案例：\n\nA. 查询员工 及其 所属领导的名字 \n\n表结构: emp\n\n``` SQL\n# A. 查询员工 及其 所属领导的名字\nselect a.name \'领导名\', b.name \'员工名\'\nfrom emp a\n         join emp b on a.id = b.managerid;\n```\n\nB. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 \n\n表结构: emp a , emp b\n\n``` SQL\nselect a.name \'员工\', b.name \'领导\'\nfrom emp a\n         left join emp b on a.managerid =\n                            b.id;\n```\n\n> 注意事项: \n>\n> ​		在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底 是哪一张表的字段。\n\n#### 4.5.2 联合查询\n\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\n\n``` sql\nSELECT 字段列表 FROM 表A ...\nUNION [ ALL ]\nSELECT 字段列表 FROM 表B ....;\n```\n\n- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 \n- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\n\n案例: \n\nA. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. \n\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们 也可以通过union/union all来联合查询.\n\nunion all: 会有重复值\n\n``` sql\nselect *\nfrom emp\nwhere salary < 5000\nunion all\nselect *\nfrom emp\nwhere age > 50;\n```\n\n相当于\n\n``` sql\nselect * from emp where salary < 5000 or age > 50;\n```\n\n![image-20220526112549321](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261125429.png)\n\nunion 联合查询，会对查询出来的结果进行去重处理\n\n``` sql\nselect *\nfrom emp\nwhere salary < 5000\nunion\nselect *\nfrom emp\nwhere age > 50;\n```\n\n相当于\n\n``` sql\nselect distinct *\nfrom emp\nwhere salary < 5000\n   or age > 50;\n```\n\n> 注意： \n>\n> ​		如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报 错。如：\n\n![image-20220526112722744](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261127805.png)\n\n### 4.6 子查询\n\n#### 4.6.1 概述\n\n1）. 概念\n\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\n\n``` sql\nselect * from t1 where column1=(select column1 from t2); \n```\n\n子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。\n\n2）. 分类\n\n根据子查询结果不同，分为： \n\nA. 标量子查询（子查询结果为单个值） \n\nB. 列子查询(子查询结果为一列) \n\nC. 行子查询(子查询结果为一行) \n\nD. 表子查询(子查询结果为多行多列)\n\n\n\n根据子查询位置，分为： \n\nA. WHERE之后 \n\nB. FROM之后 \n\nC. SELECT之后\n\n#### 4.6.2 标量子查询\n\n子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= <> > >= < <=\n\n案例：\n\nA. 查询 \"销售部\" 的所有员工信息 \n\n完成这个需求时，我们可以将需求分解为两步： \n\n①. 查询 \"销售部\" 部门ID\n\n``` sql\nselect id\n                 from dept\n                 where name = \'销售部\';\n```\n\n②. 根据 \"销售部\" 部门ID, 查询员工信息\n\n``` sql\n# 查询 \"销售部\" 的所有员工信息\nselect *\nfrom emp\nwhere dept_id = (select id\n                 from dept\n                 where name = \'销售部\');\n```\n\n内连接：\n\n``` sql\nselect e.*\nfrom emp e\n         join dept d on e.dept_id = d.id and d.name = \'销售部\';\n```\n\nB. 查询在 \"方东白\" 入职之后的员工信息 \n\n完成这个需求时，我们可以将需求分解为两步： \n\n①. 查询 方东白 的入职日期\n\n``` sql\n# 查询在 \"方东白\" 入职之后的员工信息\nselect entrydate\nfrom emp\nwhere name = \'方东白\';\n```\n\n②. 查询指定入职日期之后入职的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere entrydate > (select entrydate\n                   from emp\n                   where name = \'方东白\');\n```\n\n#### 4.6.3 列子查询\n\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 \n\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n| 操作符 | 描述                                   |\n| ------ | -------------------------------------- |\n| IN     | 在指定的集合范围之内，多选一           |\n| NOT IN | 不在指定的集合范围之内                 |\n| ANY    | 子查询返回列表中，有任意一个满足即可   |\n| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |\n| ALL    | 子查询返回列表的所有值都必须满足       |\n\n案例：\n\nA. 查询 \"销售部\" 和 \"市场部\" 的所有员工信息\n\n分解为以下两步: \n\n①. 查询 \"销售部\" 和 \"市场部\" 的部门ID\n\n``` sql\nselect id\nfrom dept\nwhere name = \'销售部\'\n   or name = \'市场部\';\n```\n\n②. 根据部门ID, 查询员工信息\n\n``` sql\nselect *\nfrom emp\nwhere dept_id in (select id\n                  from dept\n                  where name = \'销售部\'\n                     or name = \'市场部\');\n```\n\nB. 查询比 财务部 所有人工资都高的员工信息\n\n分解为以下两步: \n\n①. 查询所有 财务部 人员工资\n\n``` sql\nselect id from dept where name = \'财务部\';\nselect salary from emp where dept_id = (select id from dept where name = \'财务部\');\n```\n\n②. 比 财务部 所有人工资都高的员工信息\n\n``` sql\nselect * from emp where salary > all ( select salary from emp where dept_id =\n(select id from dept where name = \'财务部\') );\n```\n\nC. 查询比研发部其中任意一人工资高的员工信息\n\n分解为以下两步: \n\n①. 查询研发部所有人工资\n\n``` sql\nselect salary\nfrom emp\nwhere dept_id = (select id from dept where name = \'研发部\');\n```\n\n②. 比研发部其中任意一人工资高的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere salary > any (select salary\n                    from emp\n                    where dept_id = (select id from dept where name = \'研发部\'));\n```\n\n#### 4.6.4 行子查询\n\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：= 、<> 、IN 、NOT IN\n\n案例: \n\nA. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ; \n\n这个需求同样可以拆解为两步进行:\n\n①. 查询 \"张无忌\" 的薪资及直属领导\n\n```sql\nselect salary, managerid\nfrom emp\nwhere name = \'张无忌\';\n```\n\n②. 查询与 \"张无忌\" 的薪资及直属领导相同的员工信息 ;\n\n``` sql\nselect *\nfrom emp\nwhere (salary, managerid) = (select salary, managerid\n                             from emp\n                             where name = \'张无忌\');\n```\n\n#### 4.6.5 表子查询\n\n子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN\n\n案例: \n\nA. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息 \n\n分解为两步执行:\n\n①. 查询 \"鹿杖客\" , \"宋远桥\" 的职位和薪资\n\n``` sql\nselect job, salary\nfrom emp\nwhere name = \'鹿杖客\'\n   or name = \'宋远桥\';\n```\n\n②. 查询与 \"鹿杖客\" , \"宋远桥\" 的职位和薪资相同的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere (job, salary) in (select job, salary\n                        from emp\n                        where name = \'鹿杖客\'\n                           or name = \'宋远桥\');\n```\n\nB. 查询入职日期是 \"2006-01-01\" 之后的员工信息 , 及其部门信息\n\n分解为两步执行: \n\n①. 入职日期是 \"2006-01-01\" 之后的员工信息\n\n``` sql\nselect *\nfrom emp where entrydate>\'2006-01-01\';\n```\n\n②. 查询这部分员工, 对应的部门信息;\n\n```sql\n-- 先查询出入职日期是 \"2006-01-01\" 之后的员工信息，再将其作为新表与部门表进行左外连接查询\nselect *\nfrom (select *\n      from emp\n      where entrydate > \'2006-01-01\') e\n         left join dept d\n                   on e.dept_id = d.id;\n```\n\n### 4.7 多表查询案例\n\n数据环境准备：\n\n``` sql\ncreate table salgrade\n(\n    grade int,\n    losal int,\n    hisal int\n) comment \'薪资等级表\';\ninsert into salgrade\nvalues (1, 0, 3000),\n       (2, 3001, 5000),\n       (3, 5001, 8000),\n       (4, 8001, 10000),\n       (5, 10001, 15000),\n       (6, 15001, 20000),\n       (7, 20001, 25000),\n       (8, 25001, 30000);\n```\n\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉 及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\n\n1）. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\n\n表: emp , dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.name, e.age, e.job, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n2）. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接） \n\n表: emp , dept\n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.name, e.age, e.job, d.name\nfrom emp e\n         inner join dept d on e.dept_id = d.id and e.age < 30;\n```\n\n3）. 查询拥有员工的部门ID、部门名称\n\n表：emp，dept\n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect distinct d.id, d.name\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id;\n```\n\n4）. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出 来(外连接) \n\n表: emp , dept \n\n连接条件: emp.dept_id = dept.id\n\n``` sql\nselect e.*, d.name\nfrom emp e\n         left join dept d on d.id = e.dept_id and e.age > 40;\n```\n\n5）. 查询所有员工的工资等级 \n\n表: emp , salgrade \n\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\n\n``` sql\nselect e.*, s.grade \'员工等级\'\nfrom emp e,\n     salgrade s\nwhere e.salary between s.losal and s.hisal;\n```\n\n6）. 查询 \"研发部\" 所有员工的信息及 工资等级 \n\n表: emp , salgrade , dept \n\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id \n\n查询条件 : dept.name = \'研发部\'\n\n``` sql\nselect e.*, d.name, s.grade\nfrom emp e,\n     dept d,\n     salgrade s\nwhere d.name = \'研发部\'\n  and e.dept_id = d.id\n  and e.salary between s.losal and s.hisal;\n```\n\n7）. 查询 \"研发部\" 员工的平均工资 \n\n表: emp , dept \n\n连接条件 : emp.dept_id = dept.id\n\n``` sql\nselect avg(e.salary)\nfrom emp e,\n     dept d\nwhere e.dept_id = d.id\n  and d.name = \'研发部\';\n```\n\n8）. 查询工资比 \"灭绝\" 高的员工信息。 \n\n①. 查询 \"灭绝\" 的薪资\n\n``` sql\nselect salary\nfrom emp\nwhere emp.name = \'灭绝\';\n```\n\n②. 查询比她工资高的员工数据\n\n``` sql\nselect *\nfrom emp\nwhere salary > (select salary\n                from emp\n                where emp.name = \'灭绝\');\n```\n\n9）.  查询比平均薪资高的员工信息 \n\n①. 查询员工的平均薪资\n\n``` sql\nselect avg(salary)\nfrom emp;\n```\n\n②. 查询比平均薪资高的员工信息\n\n``` sql\nselect *\nfrom emp\nwhere salary > (select avg(salary)\n                from emp);\n```\n\n10）.  查询低于本部门平均工资的员工信息 \n\n①. 查询指定部门平均薪资\n\n``` sql\nselect avg(e1.salary) from emp e1 where e1.dept_id = 1;\nselect avg(e1.salary) from emp e1 where e1.dept_id = 2;\n```\n\n②. 查询低于本部门平均工资的员工信息\n\n``` sql\nselect *\nfrom emp e2\nwhere e2.salary < (select avg(e1.salary)\n                   from emp e1\n                   where e1.dept_id = e2.dept_id);\n```\n\n11）. 查询所有的部门信息, 并统计部门的员工人数\n\n``` sql\nselect d.id, d.name, (select count(*) from emp e where e.dept_id = d.id) \'人数\'\nfrom dept d;\n```\n\n12）. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\n\n表: student , course , student_course \n\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\n\n``` sql\nselect s.name, s.no, c.name\nfrom student s,\n     student_course sc,\n     course c\nwhere s.id = sc.studentid\n  and sc.courseid = c.id;\n```\n\n**备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条 件的记录即可。**\n\n## 5. 事务\n\n### 5.1 事务介绍\n\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 \n\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\n\n![image-20220526211221401](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112624.png)\n\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :\n\n![image-20220526211238606](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112698.png)\n\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\n\n![image-20220526211300656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113735.png)\n\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\n\n![image-20220526211317578](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113661.png)\n\n> **注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。**\n\n### 5.2 事务操作\n\n数据准备：\n\n``` sql\ndrop table if exists account;\ncreate table account\n(\n    id    int primary key AUTO_INCREMENT comment \'ID\',\n    name  varchar(10) comment \'姓名\',\n    money double(10, 2) comment \'余额\'\n) comment \'账户表\';\ninsert into account(name, money)\nVALUES (\'张三\', 2000),\n       (\'李四\', 2000);\n```\n\n#### 5.2.1 未控制事务\n\n1). 测试正常情况\n\n``` sql\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n```\n\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\n\n![image-20220526211732232](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262117323.png)\n\n2). 测试异常情况\n\n``` sql\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n出错了....\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n```\n\n我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。\n\n![image-20220526211831649](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262118725.png)\n\n#### 5.2.2 控制事务一\n\n1）. 查看/设置事务提交方式\n\n``` sql\nSELECT @@autocommit ;\nSET @@autocommit = 0 ;\n```\n\n2）. 提交事务\n\n``` sql\ncommit;\n```\n\n3）. 回滚事务\n\n``` sql\nrollback;\n```\n\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\n\n#### 5.2.3 控制事务二\n\n1）. 开启事务\n\n``` sql\nSTART TRANSACTION 或 BEGIN ;\n```\n\n2）. 提交事务\n\n``` sql\ncommit;\n```\n\n3）. 回滚事务\n\n``` sql\nROLLBACK;\n```\n\n转账案例：\n\n``` sql\n-- 开启事务\nstart transaction\n-- 1. 查询张三余额\nselect * from account where name = \'张三\';\n-- 2. 张三的余额减少1000\nupdate account set money = money - 1000 where name = \'张三\';\n-- 3. 李四的余额增加1000\nupdate account set money = money + 1000 where name = \'李四\';\n-- 如果正常执行完毕, 则提交事务\ncommit;\n-- 如果执行过程中报错, 则回滚事务\n-- rollback;\n```\n\n### 5.3  事务四大特性（ACID）\n\n- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 \n- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 \n- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。\n- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n上述就是事务的四大特性，简称ACID。\n\n![image-20220526215911714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262159820.png)\n\n### 5.4 并发事务问题\n\n1）. 脏读：一个事务读到另外一个事务还没有提交的数据。\n\n![image-20220526220426943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204036.png)\n\n2）. 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n\n![image-20220526220450359](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204455.png)\n\n3）. 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 \"幻影\"。\n\n![image-20220526220605668](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262206753.png)\n\n### 5.5 事务隔离级别\n\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\n\n| 隔离级别                          | 脏读 | 不可重复读取 | 幻读 |\n| --------------------------------- | ---- | ------------ | ---- |\n| Read uncommitted（读未提交）      | √    | √            | √    |\n| Read committed（读已提交）        | ×    | √            | √    |\n| Repeatable Read(默认)（可重复读） | ×    | ×            | √    |\n| Serializable（串行化）            | ×    | ×            | ×    |\n\n1）. 查看事务隔离级别\n\n``` SQL\nSELECT @@TRANSACTION_ISOLATION;\n```\n\n2）. 设置事务隔离级别\n\n``` sql\nSET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |\nREAD COMMITTED | REPEATABLE READ | SERIALIZABLE }\n```\n\n> **注意：事务隔离级别越高，数据越安全，但是性能越低。**',1,'',0,0,1,'2022-05-26 22:41:34',NULL),(98,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b91897a77cb0bb9bca9f7c2b50e161d2.jpg','mybatis学习笔记','# Mybatis学习笔记\n\n## 一、Mybatis简介\n\n### 1、MyBatis历史\n\nMyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。 \n\niBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects（DAO）。\n\n### 2、MyBatis特性\n\n1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 \n\n3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 \n\n4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架\n\n### 3、MyBatis下载\n\nMyBatis下载地址：https://github.com/mybatis/mybatis-3\n\n![image-20220527082907171](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205270829457.png)\n\n### 4、和其它持久化层技术对比\n\n- JDBC\n  - SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 \n  - 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 \n  - 代码冗长，开发效率低\n- Hibernate 和 JPA\n  - 操作简便，开发效率高 \n  - 程序中的长难复杂 SQL 需要绕过框架 \n  - 内部自动生产的 SQL，不容易做特殊优化 \n  - 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 \n  - 反射操作太多，导致数据库性能下降\n- MyBatis\n  - 轻量级，性能出色 \n  - SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 \n  - 开发效率稍逊于HIbernate，但是完全能够接受\n\n## 二、搭建MyBatis\n\n这里使用SpringBoot整合MyBatis\n\n### 1、开发环境\n\nIDE：idea 2021.3 \n\n构建工具：maven 3.8.3\n\nMySQL版本：MySQL 8.x\n\nMyBatis版本：MyBatis 3.5.9\n\n### 2、创建maven工程\n\n引入依赖\n\n``` java\n <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.9</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.29</version>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.13.2</version>\n        <scope>test</scope>\n    </dependency>\n```\n\n### 3、创建MyBatis的核心配置文件\n\n> 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息\n>\n> 核心配置文件存放的位置是src/main/resources目录下\n\nmybatis-config.xml\n\n``` java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--设置连接数据库的环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\"\n                          value=\"jdbc:mysql://localhost:3306/MyBatis\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"12345\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--引入映射文件-->\n    <mappers>\n        <mapper resource=\"mappers/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### 4、创建mapper接口\n\n> MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要 提供实现类。\n\n``` java\npublic interface UserMapper {\n/**\n* 添加用户信息\n*/\nint insertUser();\n}\n```\n\n### 5、创建MyBatis的映射文件\n\n相关概念：**ORM（Object Relationship Mapping）对象关系映射**。 \n\n- 对象：Java的实体类对象 \n- 关系：关系型数据库 \n- 映射：二者之间的对应关系\n\n| Java概念 | 数据库概念 |\n| -------- | ---------- |\n| 类       | 表         |\n| 属性     | 字段/列    |\n| 对象     | 记录/行    |\n\n>1、映射文件的命名规则： \n>\n>表所对应的实体类的类名+Mapper.xml \n>\n>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml \n>\n>因此一个映射文件对应一个实体类，对应一张表的操作 \n>\n>MyBatis映射文件用于编写SQL，访问以及操作表中的数据 \n>\n>MyBatis映射文件存放的位置是src/main/resources/mappers目录下 \n>\n>2、MyBatis中可以面向接口操作数据，要保证两个一致： \n>\n>a>mapper接口的全类名和映射文件的命名空间（namespace）保持一致 b>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"cn.icatw.mybatis.mapper.UserMapper\">\n    <!--int insertUser();-->\n    <insert id=\"insertUser\">\n        insert into t_user\n        values (3, \'张三\', \'123\', 23, \'女\', \'762188827@qq.com\')\n    </insert>\n</mapper>\n```\n\n### 6、通过junit测试功能\n\n``` java\n//读取MyBatis的核心配置文件\nInputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n//创建SqlSessionFactoryBuilder对象\nSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new\nSqlSessionFactoryBuilder();\n//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\nSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\n//SqlSession sqlSession = sqlSessionFactory.openSession();\n//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交\nSqlSession sqlSession = sqlSessionFactory.openSession(true);\n//通过代理模式创建UserMapper接口的代理实现类对象\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配\n映射文件中的SQL标签，并执行标签中的SQL语句\nint result = userMapper.insertUser();\n//sqlSession.commit();\nSystem.out.println(\"结果：\"+result);\n```\n\n> - SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的 会话） \n>\n> - SqlSessionFactory：是“生产”SqlSession的“工厂”。 \n>\n> - 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的 相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。\n\n### 7、加入log4j日志功能\n\n- 加入依赖\n\n  ``` java\n      <!-- log4j日志 -->\n      <dependency>\n          <groupId>log4j</groupId>\n          <artifactId>log4j</artifactId>\n          <version>1.2.17</version>\n      </dependency>\n  ```\n\n  \n\n- 加入log4j配置文件\n\n> log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\">\n<log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\">\n    <appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\">\n        <param name=\"Encoding\" value=\"UTF-8\"/>\n        <layout class=\"org.apache.log4j.PatternLayout\">\n            <param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS}\n%m (%F:%L) \\n\"/>\n        </layout>\n    </appender>\n    <logger name=\"java.sql\">\n        <level value=\"debug\"/>\n    </logger>\n    <logger name=\"org.apache.ibatis\">\n        <level value=\"info\"/>\n    </logger>\n    <root>\n        <level value=\"debug\"/>\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n</log4j:configuration>\n\n```\n\n> **日志的级别**\n>\n> FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试) 从左到右打印的内容越来越详细\n\n日志效果如下：\n\n![image-20220527161432211](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205271614357.png)\n\n## 三、核心配置文件详解\n\n核心配置文件中的标签必须按照固定的顺序： properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//MyBatis.org//DTD Config 3.0//EN\"\n        \"http://MyBatis.org/dtd/MyBatis-3-config.dtd\">\n<configuration>\n    <!--引入properties文件，此时就可以${属性名}的方式访问属性值-->\n    <properties resource=\"jdbc.properties\"></properties>\n    <settings>\n        <!--将表中字段的下划线自动转换为驼峰-->\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n        <!--开启延迟加载-->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n    <typeAliases>\n        <!--\n        typeAlias：设置某个具体的类型的别名\n        属性：\n        type：需要设置别名的类型的全类名\n        alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小\n        写\n        若设置此属性，此时该类型的别名只能使用alias所设置的值\n        -->\n        <!--<typeAlias type=\"com.atguigu.mybatis.bean.User\"></typeAlias>-->\n        <!--<typeAlias type=\"com.atguigu.mybatis.bean.User\" alias=\"abc\">\n        </typeAlias>-->\n        <!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写-->\n        <package name=\"com.atguigu.mybatis.bean\"/>\n    </typeAliases>\n    <!--\n    environments：设置多个连接数据库的环境\n    属性：\n    default：设置默认使用的环境的id\n    -->\n    <environments default=\"mysql_test\">\n        <!--\n        environment：设置具体的连接数据库的环境信息\n        属性：\n        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，\n        表示默认使用的环境\n        -->\n        <environment id=\"mysql_test\">\n            <!--\n            transactionManager：设置事务管理方式\n            属性：\n            type：设置事务管理方式，type=\"JDBC|MANAGED\"\n            type=\"JDBC\"：设置当前环境的事务管理都必须手动处理\n            type=\"MANAGED\"：设置事务被管理，例如spring中的AOP\n            -->\n            <transactionManager type=\"JDBC\"/>\n            <!--\n            dataSource：设置数据源\n            属性：\n            type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\"\n            type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从\n            缓存中直接获取，不需要重新创建\n            type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建\n            type=\"JNDI\"：调用上下文中的数据源\n            -->\n            <dataSource type=\"POOLED\">\n                <!--设置驱动类的全类名-->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <!--设置连接数据库的连接地址-->\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <!--设置连接数据库的用户名-->\n                <property name=\"username\" value=\"${jdbc.username}\"/>\n                <!--设置连接数据库的密码-->\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--引入映射文件-->\n    <mappers>\n        <mapper resource=\"UserMapper.xml\"/>\n        <!--\n        以包为单位，将包下所有的映射文件引入核心配置文件\n        注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下\n        -->\n        <package name=\"com.icatw.mybatis.mapper\"/>\n    </mappers>\n</configuration>\n```\n\n## 四、MyBatis的增删改查\n\n增删改大致都差不多\n\n1、添加\n\n``` xml\n<!--int insertUser();-->\n    <insert id=\"insertUser\">\n        insert into t_user(username, password, age, sex, email)\n        values (\'张三\', \'123\', 23, \'女\', \'762188827@qq.com\')\n    </insert>\n```\n\n2、删除\n\n``` xml\n<!--int deleteUser();-->\n<delete id=\"deleteUser\">\ndelete from t_user where id = 7\n</delete>\n```\n\n3、修改\n\n``` xml\n<!--int updateUser();-->\n<update id=\"updateUser\">\nupdate t_user set username=\'ybc\',password=\'123\' where id = 6\n</update>\n```\n\n4、查询一个实体类对象\n\n``` xml\n<select id=\"getUserById\" resultType=\"cn.icatw.mybatis.pojo.User\">\n        select *\n        from t_user\n        where id = 3;\n</select>\n```\n\n5、查询集合\n\n``` xml\n<select id=\"getAllUsers\" resultType=\"cn.icatw.mybatis.pojo.User\">\n   select *\n   from t_user;\n</select>\n```\n\n> 注意： \n>\n> 1. 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 \n>\n>    resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 \n>\n> 2. 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值\n\n## 五、MyBatis获取参数值的两种方式（重点）\n\n**MyBatis获取参数值的两种方式：${}和#{}** \n\n**${}的本质就是字符串拼接（会有sql注入的问题），#{}的本质就是占位符赋值** \n\n**${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；**\n\n**但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号**\n\n### 1、单个字面量类型的参数\n\n若mapper接口中的方法参数为单个的字面量类型 此时可以使用${}和#{}以任意的名称获取参数的值，**注意${}需要手动加单引号**\n\n例如：\n\n- #{}\n\nUserMapper接口为\n\n``` java\nUser getByUsername(String username);\n```\n\n**对应的xml，这里的#{}内可以为任意字符串**\n\n``` xml\n<select id=\"getByUsername\" resultType=\"User\">\n        select *\n        from t_user\n        where username = #{username};\n    </select>\n```\n\n- ${}\n\nUserMapper接口为\n\n``` java\nUser getByUsername(String username);\n```\n\n**对应的xml，这里的${}内可以为任意字符串，但是${}外必须加单引号**\n\n``` xml\n<select id=\"getByUsername\" resultType=\"User\">\n        select *\n        from t_user\n        where username = \'${username}\';\n    </select>\n```\n\n\n\n### 2、多个字面量类型的参数\n\n若mapper接口中的方法参数为多个时 \n\n此时MyBatis会自动将这些参数放在一个map集合中，**以arg0,arg1...为键，以参数为值；以 param1,param2...为键，以参数为值；**因此只需要通过${}和#{}访问map集合的键就可以获取相对应的 值，**注意${}需要手动加单引号**\n\n例如：\n\nUserMapper接口为\n\n``` java\nUser checkLogin(String username, String password);\n```\n\n对应的xml为\n\n``` xml\n<select id=\"checkLogin\" resultType=\"cn.icatw.mybatis.pojo.User\">\n        select *\n        from t_user\n        where username = #{arg0}\n          and password = #{arg1};\n    </select>\n```\n\n或者为\n\n``` xml\n<select id=\"checkLogin\" resultType=\"cn.icatw.mybatis.pojo.User\">\n        select *\n        from t_user\n        where username = #{param1}\n          and password = #{param2};\n    </select>\n```\n\n> 也可以将arg和param混合使用，但是参数位置需要对应\n>\n> arg0 -> param2\n>\n> param1 -> arg1\n\n\n\n### 3、map集合类型的参数\n\n若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n\n### 4、实体类类型的参数\n\n若mapper接口中的方法参数为实体类对象时 \n\n此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号\n\n### 5、使用@Param标识参数 \n\n可以通过@Param注解标识mapper接口中的方法参数 此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以 param1,param2...为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值， 注意${}需要手动加单引号\n\n## 六、MyBatis的各种查询功能\n\n### 1、查询一个实体类对象\n\n``` java\n/**\n* 根据用户id查询用户信息\n* @param id\n* @return\n*/\nUser getUserById(@Param(\"id\") int id);\n```\n\n``` xml\n<!--User getUserById(@Param(\"id\") int id);-->\n<select id=\"getUserById\" resultType=\"User\">\nselect * from t_user where id = #{id}\n</select>\n```\n\n### 2、查询一个list集合\n\n``` java\n/**\n* 查询所有用户信息\n* @return\n*/\nList<User> getUserList();\n```\n\n``` xml\n<!--List<User> getUserList();-->\n<select id=\"getUserList\" resultType=\"User\">\nselect * from t_user\n</select>\n```\n\n### 3、查询单个数据\n\n``` java\n/**\n* 查询用户的总记录数\n* @return\n* 在MyBatis中，对于Java中常用的类型都设置了类型别名\n* 例如：java.lang.Integer-->int|integer\n* 例如：int-->_int|_integer\n* 例如：Map-->map,List-->list\n*/\nint getCount();\n```\n\n``` xml\n<!--int getCount();-->\n<select id=\"getCount\" resultType=\"_integer\">\nselect count(id) from t_user\n</select>\n```\n\n### 4、查询一条数据为map集合\n\n``` java\n/**\n* 根据用户id查询用户信息为map集合\n* @param id\n* @return\n*/\nMap<String, Object> getUserToMap(@Param(\"id\") int id);\n```\n\n``` xml\n<!--Map<String, Object> getUserToMap(@Param(\"id\") int id);-->\n<select id=\"getUserToMap\" resultType=\"map\">\nselect * from t_user where id = #{id}\n</select>\n<!--结果：{password=123456, sex=男, id=1, age=23, username=admin}-->\n```\n\n### 5、查询多条数据为map集合\n\n方式一：\n\n``` java\n/**\n* 查询所有用户信息为map集合\n* @return\n* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此\n时可以将这些map放在一个list集合中获取\n*/\nList<Map<String, Object>> getAllUserToMap();\n```\n\n```xml\n<!--Map<String, Object> getAllUserToMap();-->\n<select id=\"getAllUserToMap\" resultType=\"map\">\nselect * from t_user\n</select>\n```\n\n方式二：\n\n``` java\n/**\n* 查询所有用户信息为map集合\n* @return\n* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并\n且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的\nmap集合\n*/\n@MapKey(\"id\")\nMap<String, Object> getAllUserToMap();\n```\n\n``` xml\n<!--Map<String, Object> getAllUserToMap();-->\n<select id=\"getAllUserToMap\" resultType=\"map\">\nselect * from t_user\n</select>\n结果：\n<!--\n{\n1={password=123456, sex=男, id=1, age=23, username=admin},\n2={password=123456, sex=男, id=2, age=23, username=张三},\n3={password=123456, sex=男, id=3, age=23, username=张三}\n}\n-->\n```\n\n## 七、特殊SQL的执行\n\n### 1、模糊查询\n\n``` java\n/**\n* 测试模糊查询\n* @param mohu\n* @return\n*/\nList<User> testMohu(@Param(\"mohu\") String mohu);\n```\n\n``` xml\n<!--List<User> testMohu(@Param(\"mohu\") String mohu);-->\n<select id=\"testMohu\" resultType=\"User\">\n<!--select * from t_user where username like \'%${mohu}%\'-->\n<!--select * from t_user where username like concat(\'%\',#{mohu},\'%\')-->\nselect * from t_user where username like \"%\"#{mohu}\"%\"\n</select>\n```\n\n### 2、批量删除\n\n``` java\n/**\n* 批量删除\n* @param ids\n* @return\n*/\nint deleteMore(@Param(\"ids\") String ids);\n```\n\n```` xml\n<!--int deleteMore(@Param(\"ids\") String ids);-->\n<delete id=\"deleteMore\">\ndelete from t_user where id in (${ids})\n</delete>\n````\n\n### 3、动态设置表名\n\n``` java\n/**\n* 动态设置表名，查询所有的用户信息\n* @param tableName\n* @return\n*/\nList<User> getAllUser(@Param(\"tableName\") String tableName);\n```\n\n``` xml\n<!--List<User> getAllUser(@Param(\"tableName\") String tableName);-->\n<select id=\"getAllUser\" resultType=\"User\">\nselect * from ${tableName}\n</select>\n```\n\n### 4、添加功能获取自增的主键\n\nt_clazz(clazz_id,clazz_name) \n\nt_student(student_id,student_name,clazz_id) \n\n1、添加班级信息 \n\n2、获取新添加的班级的id \n\n3、为班级分配学生，即将某学的班级id修改为新添加的班级的id\n\n``` java\n/**\n* 添加用户信息\n* @param user\n* @return\n* useGeneratedKeys：设置使用自增的主键\n* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参\n数user对象的某个属性中\n*/\nint insertUser(User user);\n```\n\n``` xml\n<!--int insertUser(User user);-->\n<insert id=\"insertUser\" useGeneratedKeys=\"true\" keyProperty=\"id\">\ninsert into t_user values(null,#{username},#{password},#{age},#{sex})\n</insert>\n```\n\n## 八、自定义映射resultMap\n\n### 1、resultMap处理字段和属性的映射关系\n\n若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射\n\n``` xml\n    <!--\n    resultMap：设置自定义映射\n    属性：\n    id：表示自定义映射的唯一标识\n    type：查询的数据要映射的实体类的类型\n    子标签：\n    id：设置主键的映射关系\n    result：设置普通字段的映射关系\n    association：设置多对一的映射关系\n    collection：设置一对多的映射关系\n    属性：\n    property：设置映射关系中实体类中的属性名\n    column：设置映射关系中表中的字段名\n    -->\n    <resultMap id=\"userMap\" type=\"User\">\n        <id property=\"id\" column=\"id\"></id>\n        <result property=\"userName\" column=\"user_name\"></result>\n        <result property=\"password\" column=\"password\"></result>\n        <result property=\"age\" column=\"age\"></result>\n        <result property=\"sex\" column=\"sex\"></result>\n    </resultMap>\n    <!--List<User> testMohu(@Param(\"mohu\") String mohu);-->\n    <select id=\"testMohu\" resultMap=\"userMap\">\n        <!--select * from t_user where username like \'%${mohu}%\'-->\n        select id,user_name,password,age,sex from t_user where user_name like\n        concat(\'%\',#{mohu},\'%\')\n    </select>\n```\n\n### 2、多对一映射处理\n\n> 根据员工id查询员工信息以及员工所对应的部门信息\n\n- **级联方式处理映射关系**\n\n首先编写SQL语句\n\n``` sql\n     select *\n        from t_emp emp,\n             t_dept dept\n        where emp.did = dept.did\n          and emp.eid = 1;\n```\n\n查询结果为\n\n![image-20220528114839064](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205281148144.png)\n\n要建立员工与部门一对多的映射关系需要在员工实体中添加部门属性\n\n``` java\n@ToString\n@Data\npublic class Emp implements Serializable {\n    private static final long serialVersionUID = -33707633162257748L;\n\n    private Integer eid;\n\n    private String empName;\n\n    private Integer age;\n\n    private String sex;\n\n    private String email;\n    \n    private Dept dept;\n\n}\n```\n\n之后再通过resultMap映射\n\n``` xml\n<resultMap id=\"empAndDeptResultMapOne\" type=\"emp\">\n        <id property=\"eid\" column=\"eid\"/>\n        <result property=\"empName\" column=\"emp_name\" jdbcType=\"VARCHAR\"/>\n        <result property=\"age\" column=\"age\" jdbcType=\"INTEGER\"/>\n        <result property=\"sex\" column=\"sex\" jdbcType=\"VARCHAR\"/>\n        <result property=\"email\" column=\"email\" jdbcType=\"VARCHAR\"/>\n        <result property=\"dept.did\" column=\"did\" jdbcType=\"INTEGER\"/>\n        <result property=\"dept.deptName\" column=\"dept_name\"/>\n    </resultMap>\n```\n\n``` xml\n <select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\">\n        select *\n        from t_emp emp,\n             t_dept dept\n        where emp.did = dept.did\n          and emp.eid = #{eid};\n    </select>\n```\n\n- **使用association处理映射关系**\n\n``` xml\n    <resultMap id=\"empAndDeptResultMapTwo\" type=\"emp\">\n        <id property=\"eid\" column=\"eid\"/>\n        <result property=\"empName\" column=\"emp_name\" jdbcType=\"VARCHAR\"/>\n        <result property=\"age\" column=\"age\" jdbcType=\"INTEGER\"/>\n        <result property=\"sex\" column=\"sex\" jdbcType=\"VARCHAR\"/>\n        <result property=\"email\" column=\"email\" jdbcType=\"VARCHAR\"/>\n        <association property=\"dept\" javaType=\"dept\">\n            <id property=\"did\" column=\"did\"/>\n            <result property=\"deptName\" column=\"dept_name\"/>\n        </association>\n    </resultMap>\n```\n\n- 分步查询\n\n1）查询员工信息\n\n``` java\n/**\n* 通过分步查询查询员工信息\n* @param eid\n* @return\n*/\nEmp getEmpByStep(@Param(\"eid\") int eid);\n```\n\n``` xml\n    <resultMap id=\"empDeptStepMap\" type=\"Emp\">\n        <id column=\"eid\" property=\"eid\"></id>\n        <result column=\"ename\" property=\"ename\"></result>\n        <result column=\"age\" property=\"age\"></result>\n        <result column=\"sex\" property=\"sex\"></result>\n        <!--\n        select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）\n        column：将sql以及查询结果中的某个字段设置为分步查询的条件，将其传入select的参数\n        -->\n        <association property=\"dept\"\n                     select=\"com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep\" column=\"did\">\n        </association>\n    </resultMap>\n    <!--Emp getEmpByStep(@Param(\"eid\") int eid);-->\n    <select id=\"getEmpByStep\" resultMap=\"empDeptStepMap\">\n        select *\n        from t_emp\n        where eid = #{eid}\n    </select>\n```\n\n2）根据员工所对应的部门id查询部门信息\n\n``` java\n/**\n* 分步查询的第二步：根据员工所对应的did查询部门信息\n* @param did\n* @return\n*/\nDept getEmpDeptByStep(@Param(\"did\") int did);\n```\n\n```  xml\n    <!--Dept getEmpDeptByStep(@Param(\"did\") int did);-->\n    <select id=\"getEmpDeptByStep\" resultType=\"Dept\">\n        select *\n        from t_dept\n        where did = #{did}\n    </select>\n```\n\n\n\n### 3、一对多映射处理\n\n- collection\n\n首先修改部门实体\n\n``` java\n/**\n * (TDept)实体类\n *\n * @author icatw\n * @since 2022-05-27 19:48:39\n */\n@Data\n@ToString\npublic class Dept implements Serializable {\n    private static final long serialVersionUID = -53974633969964494L;\n\n    private Integer did;\n\n    private String deptName;\n    private List<Emp> emps;\n\n}\n```\n\n\n\n``` java\n/**\n* 根据部门id查新部门以及部门中的员工信息\n* @param did\n* @return\n*/\nDept getDeptEmpByDid(@Param(\"did\") int did);\n```\n\n```  xml\n<resultMap id=\"deptEmpMap\" type=\"dept\">\n        <id property=\"did\" column=\"did\"/>\n        <result property=\"deptName\" column=\"dept_name\"/>\n        <collection property=\"emps\" ofType=\"emp\">\n            <id property=\"eid\" column=\"eid\"/>\n            <result property=\"empName\" column=\"emp_name\"/>\n            <result property=\"age\" column=\"age\"/>\n            <result property=\"sex\" column=\"sex\"/>\n            <result property=\"email\" column=\"email\"/>\n        </collection>\n    </resultMap>\n    <select id=\"getDeptEmpByDid\" resultMap=\"deptEmpMap\">\n        select d.*, e.*\n        from t_emp e,\n             t_dept d\n        where e.did = d.did\n          and d.did = #{did};\n    </select>\n```\n\n![image-20220528144644567](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205281446649.png)\n\n- 分步查询\n\n1）查询部门信息\n\n``` java\n/**\n* 分步查询部门和部门中的员工\n* @param did\n* @return\n*/\nDept getDeptByStep(@Param(\"did\") int did);\n```\n\n``` xml\n<resultMap id=\"deptEmpStep\" type=\"dept\">\n        <id property=\"did\" column=\"did\"/>\n        <result property=\"deptName\" column=\"dept_name\"/>\n        <collection property=\"emps\" select=\"cn.icatw.mybatis.mapper.EmpDao.getEmpListByDid\" column=\"did\"/>\n    </resultMap>\n <select id=\"getDeptByStep\" resultMap=\"deptEmpStep\">\n        select *\n        from t_dept\n        where did = #{did};\n    </select>\n```\n\n2）查询部门员工信息\n\n``` java\n    /**\n     * 根据部门id查询员工信息\n     *\n     * @param did\n     * @return\n     */\n    List<Emp> getEmpListByDid(@Param(\"did\") int did);\n```\n\n``` xml\n    <select id=\"getEmpListByDid\" resultType=\"cn.icatw.mybatis.entity.Emp\">\n        select *\n        from t_emp where did=#{did};\n    </select>\n```\n\n> 　　分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： \n>\n> 　lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 \n>\n> 　aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个 属性会按需加载 \n>\n> 　此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=\"lazy(延迟加 载)|eager(立即加载)\"\n\n## 九、动态SQL\n\nMybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。\n\n### 1、if\n\nif标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中 的内容不会执行\n\n``` xml\n    <!--List<Emp> getEmpListByMoreTJ(Emp emp);-->\n    <select id=\"getEmpListByMoreTJ\" resultType=\"Emp\">\n        select * from t_emp where 1=1\n        <if test=\"ename != \'\' and ename != null\">\n            and ename = #{ename}\n        </if>\n        <if test=\"age != \'\' and age != null\">\n            and age = #{age}\n        </if>\n        <if test=\"sex != \'\' and sex != null\">\n            and sex = #{sex}\n        </if>\n    </select>\n```\n\n### 2、where\n\n``` xml\n    <select id=\"getEmpListByMoreTJ2\" resultType=\"Emp\">\n        select * from t_emp\n        <where>\n            <if test=\"ename != \'\' and ename != null\">\n                ename = #{ename}\n            </if>\n            <if test=\"age != \'\' and age != null\">\n                and age = #{age}\n            </if>\n            <if test=\"sex != \'\' and sex != null\">\n                and sex = #{sex}\n            </if>\n        </where>\n    </select>\n```\n\n> where和if一般结合使用： \n>\n> a>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 \n>\n> b>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉 **注意：where标签不能去掉条件最后多余的and**\n\n### 3、trim\n\n``` xml-dtd\n    <select id=\"getEmpListByMoreTJ\" resultType=\"Emp\">\n        select * from t_emp\n        <trim prefix=\"where\" suffixOverrides=\"and\">\n            <if test=\"ename != \'\' and ename != null\">\n                ename = #{ename} and\n            </if>\n            <if test=\"age != \'\' and age != null\">\n                age = #{age} and\n            </if>\n            <if test=\"sex != \'\' and sex != null\">\n                sex = #{sex}\n            </if>\n        </trim>\n    </select>\n```\n\n>trim用于去掉或添加标签中的内容 \n>\n>常用属性： \n>\n>prefix：在trim标签中的内容的前面添加某些内容 \n>\n>prefixOverrides：在trim标签中的内容的前面去掉某些内容 \n>\n>suffix：在trim标签中的内容的后面添加某些内容 \n>\n>suffixOverrides：在trim标签中的内容的后面去掉某些内容\n\n### 4、choose、when、otherwise\n\nchoose、when、otherwise相当于if...else if..else\n\n``` java\n    <!--List<Emp> getEmpListByChoose(Emp emp);-->\n    <select id=\"getEmpListByChoose\" resultType=\"Emp\">\n        select <include refid=\"empColumns\"></include> from t_emp\n        <where>\n            <choose>\n                <when test=\"ename != \'\' and ename != null\">\n                    ename = #{ename}\n                </when>\n                <when test=\"age != \'\' and age != null\">\n                    age = #{age}\n                </when>\n                <when test=\"sex != \'\' and sex != null\">\n                    sex = #{sex}\n                </when>\n                <when test=\"email != \'\' and email != null\">\n                    email = #{email}\n                </when>\n            </choose>\n        </where>\n    </select>\n```\n\n### 5、foreach\n\n``` xml\n    <!--int insertMoreEmp(List<Emp> emps);-->\n    <insert id=\"insertMoreEmp\">\n        insert into t_emp values\n        <foreach collection=\"emps\" item=\"emp\" separator=\",\">\n            (null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)\n        </foreach>\n    </insert>\n    <!--int deleteMoreByArray(int[] eids);-->\n    <delete id=\"deleteMoreByArray\">\n        delete from t_emp where\n        <foreach collection=\"eids\" item=\"eid\" separator=\"or\">\n            eid = #{eid}\n        </foreach>\n    </delete>\n    <!--int deleteMoreByArray(int[] eids);-->\n    <delete id=\"deleteMoreByArray\">\n        delete from t_emp where eid in\n        <foreach collection=\"eids\" item=\"eid\" separator=\",\" open=\"(\" close=\")\">\n            #{eid}\n        </foreach>\n    </delete>\n```\n\n> 属性： \n>\n> collection：设置要循环的数组或集合 \n>\n> item：表示集合或数组中的每一个数据 \n>\n> separator：设置循环体之间的分隔符 \n>\n> open：设置foreach标签中的内容的开始符 \n>\n> close：设置foreach标签中的内容的结束符\n\n### 6、SQL片段\n\nsql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入\n\n``` xml\n<sql id=\"empColumns\">\neid,ename,age,sex,did\n</sql>\nselect <include refid=\"empColumns\"></include> from t_emp\n```\n\n## 十、MyBatis的缓存\n\n### 1、MyBatis的一级缓存\n\n一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就 会从缓存中直接获取，不会从数据库重新访问 \n\n使一级缓存失效的四种情况： \n\n-  不同的SqlSession对应不同的一级缓存 \n-  同一个SqlSession但是查询条件不同 \n-  同一个SqlSession两次查询期间执行了任何一次增删改操作 \n-  同一个SqlSession两次查询期间手动清空了缓存\n\n### 2、MyBatis的二级缓存\n\n二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 \n\n二级缓存开启的条件： \n\na>在核心配置文件中，设置全局配置属性`cacheEnabled=\"true\"`，默认为true，不需要设置 \n\nb>在映射文件中设置标签 `<cache/>`\n\nc>二级缓存必须在SqlSession关闭或提交之后有效 \n\nd>查询的数据所转换的实体类类型必须实现序列化的接口 \n\n使二级缓存失效的情况： \n\n两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n\n### 3、二级缓存的相关配置\n\n在mapper配置文件中添加的cache标签可以设置一些属性： \n\n- eviction属性：缓存回收策略 \n\n  - LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 \n  - FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 \n  - SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 \n  - WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。 \n\n- flushInterval属性：刷新间隔，单位毫秒 \n\n  默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 \n\n- size属性：引用数目，正整数 \n\n  代表缓存最多可以存储多少个对象，太大容易导致内存溢出 \n\n- readOnly属性：只读，true/false \n\n  true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。 \n\n  false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。\n\n### 4、MyBatis缓存查询的顺序\n\n- 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 \n- 如果二级缓存没有命中，再查询一级缓存 \n- 如果一级缓存也没有命中，则查询数据库 \n- SqlSession关闭之后，一级缓存中的数据会写入二级缓存',1,'',0,0,1,'2022-05-28 15:21:36',NULL),(99,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d503e8958ff03839702dbce6d0b563fe.jpg','Servlet生命周期','# servlet生命周期\n\n> 今天在面试时被问到了servlet生命周期，只回答出一个初始化....因此特地写篇博客记录一下(2022/6/8)\n\n## 与servlet生命周期有关的方法\n\n**与servlet生命周期有关的方法一般有以下三个**：\n\n1. **init()方法**\n\ninit()方法是在创建servlet对象时被调用，而且只能被调用一次，用于servlet对象在整个生命周期内的唯一一次初始化。只有在init()方法调用成功后，servlet才会处于服务状态，才能够去处理客户端的请求。\n\n2. **service()方法**\n\nservice()方法是servlet工作的核心方法。当客户端请求访问servlet时，servlet容器就会调用service方法去处理来自客户端的请求，并把处理后的响应返回给客户端。\n\n3. **destroy()方法**\n\ndestroy()方法是servlet容器回收servlet对象之前调用的，且只会调用一次，而此时的服务器处于停止状态或者访问资源以及被移除。\n\n## Servlet生命周期(三个阶段)\n\nservlet生命周期大概流程可以用下图来诠释。\n\n![servlet生命周期示意图](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206081950424.png)\n\n此图描述了servlet的完整生命周期，按照功能的不同，**大致可以将servlet的生命周期分为三个阶段，分别是初始化阶段、运行阶段和销毁阶段。**\n\n1. 初始化阶段\n\n   当用户第一次向Servlet容器发出HTTP请求要求访问某个Servlet时，Servlet容器会在整个容器中搜索该Servlet对象，发现这个Servlet对象没有被实例化，于是创建这个Servlet对象，然后调用该对象的init()方法完成初始化。\n\n   <br>\n\n   当用户第二次访问这个Servlet时，Servlet容器仍然在容器中搜索该Servlet对象，结果找到了该对象的实例，则不去创建而直接使用该对象。\n\n   <br>\n\n   找到了对应的Servlet对象，随后Servlet进入到运行阶段。\n\n   <br>\n\n   **需要注意的是，在Servlet的整个生命周期内，它的init()方法只被调用一次。**\n\n2. 运行阶段\n\n   这是Servlet生命周期中最核心的阶段。在该阶段中，Servlet容器会为当前的请求创建一个ServletRequest对象和一个ServletResponse对象（它们分别对应HTTP请求和HTTP响应），并将这两个对象作为参数传递给Servlet的service()方法。\n\n   <br>\n\n   service()方法从ServletRequest对象中获得用户的详细请求信息并处理该请求，通过ServletResponse对象生成响应结果。\n\n   <br>\n\n   **需要强调的是，在Servlet的整个生命周期内，用户每次访问Servlet时，Servlet容器都会调用一次Servlet的service()方法，并且创建新的ServletRequest和ServletResponse对象。**\n\n3. 销毁阶段\n\n   当服务器停止是，Servlet容器需要回收Servlet对象所占用的内存，在回收之前，会自动调用该对象的destroy()方法做好回收内存前的准备，譬如关闭后台线程。\n\n   <br>\n\n   和init()方法类似，destroy()方法也只会被调用一次。\n\n   <br>\n\n   **注意：Servlet对象一旦创建就会驻留在内存中一直等待客户端的访问，直到服务器关闭或项目被移出容器时，Servlet对象才会被销毁。**\n\n## 总结\n\n对Servlet声明周期的几点汇总：\n\n1. Servlet对象被创建之后执行init()方法，并且init()方法只执行一次，其主要目的是完成Servlet对象的初始化工作。\n2. 对于Servlet对象的service()方法，只要用户请求一次，那么service()方法就会执行一次。\n3. Servlet对象被回收之前，destroy()方法会被调用，该方法只执行一次，执行的时候Servlet对象还在。\n\nServlet 对象的创建、对象提供服务、对象的销毁等操作皆由 Servlet 容器来管理，Java 程序员的任务只是负责编写 Servlet 类，无法干涉 Servlet 对象的生命周期。',1,'',0,0,1,'2022-06-08 20:15:14',NULL),(100,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ebbeff20471e191c716a658e6adf435b.jpg','Java多线程：实现多线程的几种方式以及对比','# Java多线程：实现多线程的几种方式以及对比\n\n## 前言\n\nJava多线程的使用有三种方法：继承Thread类、实现Runnable接口和使用Callable和Future创建线程，本文将对这三种方法一一进行介绍。\n\n## 1、继承Thread类\n\n实现方式很简单，只需要创建一个类去继续Thread类然后重写run方法，在main中调用该类实例对象的start方法即可实现多线程并发。代码：\n\n``` java\npublic class MyThread extends Thread{\n    @Override\n    public void run(){\n        super.run();\n        System.out.println(\"执行子线程...\");\n    }\n}\n```\n\n测试用例：\n\n``` java\npublic class Test {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        System.out.println(\"主线程...\");\n    }\n}\n```\n\n这里的结果不代表线程的执行顺序，线程是并发执行的，如果多运行几次，打印顺序可能会不一样。多线程的运行过程中，CPU是以不确定的方式去执行线程的，故运行结果与代码的执行顺序或者调用顺序无关，运行结果也可能不一样。\n\n这里还有一个需要注意的点就是main方法中应该调用的是myThread的start方法，而不是run()方法。调用start()方法是告诉CPU此线程已经准备就绪可以执行，进而系统有时间就会来执行其run()方法。而直接调用run()方法，则不是异步执行，而是等同于调用函数般按顺序同步执行，这就失去了多线程的意义了。\n\n## 2、实现Runnable接口\n\n这种方式的实现也很简单，就是把继承Thread类改为实现Runnable接口。代码如下：\n\n``` java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"执行子线程...\");\n    }\n}\n```\n\n测试用例：\n\n``` java\npublic class Test {\n    public static void main(String[] args) {\n\n        Runnable runnable = new MyRunnable();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        System.out.println(\"主线程运行结束!\");\n    }\n}\n```\n\n这里main中可以看到真正创建新线程还是通过Thread创建：\n\n``` java\nThread thread = new Thread(runnable);\n```\n\n这一步Thread类的作用就是把run()方法包装成线程执行体，然后依然通过start去告诉系统这个线程已经准备好了可以安排执行。\n\n## 3、使用Callable和Future创建线程\n\n上面的两种方式都有这两个问题：\n\n1. 无法获取子线程的返回值\n2. run方法不可以抛出异常\n\n为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。\n\n\n\n所以这里面其实就是要比上一个方法再多一个转换过程，最终一样是通过Thread的start来创建新线程。有了这个思路，代码就很容易理解了：\n\n``` java\nimport java.util.concurrent.Callable;\n\npublic class MyCallable implements Callable {\n    int i = 0;\n    @Override\n    public Object call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"  i的值：\"+ i);\n        return i++; //call方法可以有返回值\n    }\n}\n```\n\n测试：\n\n``` java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class Test {\n    public static void main(String[] args) {\n        Callable callable = new MyCallable();\n        for (int i = 0; i < 10; i++) {\n            FutureTask task = new FutureTask(callable);\n            new Thread(task,\"子线程\"+ i).start();\n            try {\n                //获取子线程的返回值\n                System.out.println(\"子线程返回值：\"+task.get() + \"\\n\");\n            }  catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 4、三种方式的对比\n\n### 第一种和后面两种的对比：\n\n1、通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换\n2、但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。\n\n### 第二种和第三种方式对比：\n\n1、同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换\n2、第三种方法有两个优点：有返回值、可以抛出异常\n\n### 总结\n\n实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。\n而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。',1,'',0,0,1,'2022-06-08 21:45:01',NULL),(101,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/229d09f7e3a48762b63f384357753681.jpg','Spring Mvc流程','# Spring Mvc流程\n\n## Spring Mvc流程\n\n![image-20220608233015981](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206082330104.png)\n\n1、 用户发送请求至前端控制器DispatcherServlet。\n\n2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 \n\n3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 \n\n4、 DispatcherServlet调用HandlerAdapter处理器适配器。 \n\n5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\n\n6、 Controller执行完成返回ModelAndView。 \n\n7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 \n\n8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 \n\n9、 ViewReslover解析后返回具体View。 \n\n10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\n\n11、DispatcherServlet响应用户。\n\n**组件说明：**\n\n以下组件通常使用框架提供实现： \n\nDispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件 之间的耦合性，提高每个组件的扩展性。 \n\nHandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方 式，注解方式等。 \n\nHandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 \n\nViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、 excel等。\n\n**组件：**\n\n**1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供** \n\n作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间 的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 \n\n**2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供** \n\n作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同 的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 \n\n**3、处理器适配器HandlerAdapter** \n\n作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的 处理器进行执行。 \n\n**4、处理器Handler(需要工程师开发)** \n\n**注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler** Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具 体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 \n\n**5、视图解析器View resolver(不需要工程师开发),由框架提供** \n\n作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即 具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务 需求开发具体的页面。 \n\n**6、视图View(需要工程师开发jsp...)** \n\nView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\n\n**核心架构的具体流程步骤如下：** \n\n1、首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给 其他的解析器进行处理，作为统一访问点，进行全局的流程控制； \n\n2、DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\n\n3、DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支 持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； \n\n4、HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真 正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视 图名）； \n\n5、ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术； \n\n6、View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数 据结构，因此很容易支持其他视图技术； \n\n7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n\n\n下边两个组件通常情况下需要开发： \n\nHandler：处理器，即后端控制器用controller表示。 \n\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\n\n## 传统MVC\n\n**MVC：MVC是一种设计模式**\n\nMVC的原理图：\n\n![image-20220609001723558](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090017631.png)\n\n**分析：** \n\nM-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） \n\nV-View 视图（做界面的展示 jsp，html……） \n\nC-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）\n\n',1,'',0,0,1,'2022-06-09 00:19:07',NULL),(102,1,195,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e6e6bce2d43cbe793a3097b931d0aaaf.jpg','快速排序算法（Java实现）','# 快速排序算法（Java实现）\n\n## 算法思路\n\n> 参考b站教程 [动画教程](https://www.bilibili.com/video/BV1at411T75o?spm_id_from=333.337.search-card.all.click)\n\n分治思想\n\n1. 选定key作为中心轴（一般选取第一个）\n2. 将大于key的数字放在key的右边\n3. 将小于key的数字放在key的左边\n4. 分别对左右子序列重复前三步操作\n\n个人理解:\n``` text \n1. 先定一个基准值key(一般选取第一个值为key)\n2. 指定left为下标0，right为length-1，即最后一个元素下标\n3. 从右往左找比key小的书放至左边，找到之后R--\n4. 再从左往右找比key大的数放至右边，找到之后L++\n5. 以此类推\n6. 直到L==R时，将key放到L==R的位置\n7. 此时得到key左边的数都小于key，key右边的数都大于key\n8. 最后再通过分别递归key左边和右边的数组进行排序\n\n```\n\n\n``` java\npublic class QuickSort {\n    private int[] array;\n    public QuickSort(int[] array) {\n        this.array = array;\n    }\n    public void sort() {\n        quickSort(array, 0, array.length - 1);\n    }\n    public void print() {\n        for (int i = 0; i < array.length; i++) {\n            System.out.println(array[i]);\n        }\n    }\n   \nprivate void quickSort(int[] src, int begin, int end) {\n        if (begin < end) {\n            //第一次排序将第一个元素指定为key\n            int key = src[begin];\n            //指定i为开始下标\n            //j为结束下标\n            int i = begin;\n            int j = end;\n            // 从右向左找小于key的数来填s[i]\n            while (i < j) {\n                //如果最后的值比key大的话，j--，结束下标-1\n                // 从右向左找小于x的数来填s[i]\n                while (i < j && src[j] > key) {\n                    j--;\n                }\n                if (i < j) {\n                    //将s[j]填到s[i]中，s[j]就形成了一个新的坑\n                    src[i] = src[j];\n                    i++;\n                }\n                // 从左向右找大于或等于x的数来填s[j]\n                while (i < j && src[i] < key) {\n                    i++;\n                }\n                if (i < j) {\n                    //将s[i]填到s[j]中，s[i]就形成了一个新的坑\n                    src[j] = src[i];\n                    j--;\n                }\n            }\n            src[i] = key;\n            //再次将左右两边的数组进行排序，递归\n            quickSort(src, begin, i - 1);\n            quickSort(src, i + 1, end);\n        }\n    }\n}\n```\n\n测试代码：\n\n``` java\npublic class SortTest {\n    public static void main(String[] args) {\n        testQuickSort();\n\n    } \n    /**\n     * 快速排序\n     */\n    private static void testQuickSort() {\n        int[] array = {5, 9, 1, 9, 5, 3, 7, 6, 1};\n        QuickSort quickSort = new QuickSort(array);\n        quickSort.sort();\n        quickSort.print();\n    }\n}\n```\n\n结果：\n\n![image-20220609092349619](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090923880.png)\n\n## 特点及性能\n\n快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。\n\n但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 `O(n2)`，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 `O(nlogn)`，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。\n\n快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。\n\n快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。\n\n**快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。**',1,'',0,0,1,'2022-06-09 09:26:02','2022-06-09 09:51:34'),(103,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c8459141d27224bd7621b5c5ba187486.jpg','数据库三大范式','# 数据库三大范式\n\n**数据库三大范式**\n\n数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。\n\n## 1.第一范式（1NF）：列不可再分\n\n1. 每一列属性都是不可再分的属性值，确保每一列的原子性\n2. 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据\n\n## 2.第二范式（2NF）：属性完全依赖于主键\n\n第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键\n\n## 3.第三范式（3NF）：属性不依赖于其它非主属性   属性直接依赖于主键\n\n数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。\n\n\n\n总结：三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。所以不能一味的去追求范式建立数据库。',1,'',0,0,1,'2022-06-11 18:38:56',NULL),(104,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6cae80187ea5f083fc26f3072da4f858.jpg','Redis缓存击穿、穿透及雪崩','# Redis缓存击穿、穿透及雪崩\n\n## 缓存更新策略\n\n缓存更新策略的最佳实践方案：\n\n1. 低一致性需求：使用Redis自带的内存淘汰机制\n\n2. 高一致性需求：主动更新，并以超时剔除作为兜底方案\n\n- 读操作：\n  - 缓存命中则直接返回\n  - 缓存未命中则查询数据库，并写入缓存，设定超时时间\n\n- 写操作：\n  - 先写数据库，然后再删除缓存\n  - 要确保数据库与缓存操作的原子性\n\n## 缓存穿透\n\n**缓存穿透**是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n常见的解决方案有两种：\n\n- 缓存空对象\n  - 优点：实现简单，维护方便\n  - 缺点：\n    - 额外的内存消耗\n    - 可能造成短期的不一致\n- 布隆过滤器\n  - 优点：内存占用较少，没有多余key\n  - 缺点：\n    - 实现复杂\n    - 存在判误可能\n\n![image-20220606170719663](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061735632.png)\n\n缓存穿透产生的原因是什么？\n\n- 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\n\n缓存穿透的解决方案有哪些？\n\n- 缓存null值\n\n- 布隆过滤\n\n- 增强id的复杂度，避免被猜测id规律\n\n- 做好数据的基础格式校验\n\n- 加强用户权限校验\n\n- 做好热点参数的限流\n\n## 缓存雪崩\n\n**缓存雪崩**是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力\n\n**解决方案：**\n\n- 给不同的Key的TTL添加随机值\n\n- 利用Redis集群提高服务的可用性\n\n- 给缓存业务添加降级限流策略\n\n- 给业务添加多级缓存\n\n![image-20220606180317024](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061803093.png)\n\n## 缓存击穿\n\n**缓存击穿问题**也叫热点Key问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n常见的解决方案有两种：\n\n- 互斥锁\n- 逻辑过期\n\n![image-20220606180444992](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061804056.png)\n\n![image-20220606181304579](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061813654.png)\n\n![image-20220606181723834](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061817658.png)\n\n',1,'',0,0,1,'2022-06-12 11:53:44',NULL),(105,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f2941c745e5433ebb770f76498b36d76.jpg','Redis基础篇','# Redis入门\n\nRedis的常见命令和客户端使用\n\n## 一、初识Redis\n\n### （一）认识NoSQL\n\n#### 1. SQL\n\n> SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL等。\n\n关系型数据库适合存储结构化数据\n\n如用户的帐号、地址等：\n\n1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹\n\n2）这些数据的规模、增长的速度通常是可以预期的\n\n3）保证数据的事务性、一致性要求（ACID）。\n\n#### 2. NoSQL\n\n> NoSQL（Not Only SQL）泛指非关系型数据库，主要代表：MongoDB，Redis等。\n\n非关系型数据库适合存储非结构化数据\n\n如发微博、文章、评论：\n\n1）这些数据通常用于模糊处理，如全文搜索、机器学习\n\n2）这些数据是海量的，而且增长的速度是难以预期的，\n\n3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性\n\n4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差\n\n目前许多大型互联网项目都会选用MySQL（或任何关系型数据库） + NoSQL的组合方案。\n\n![image-20220528205407889](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282054974.png)\n\n### （二）认识Redis\n\nRedis诞生于2009年全称是**Re**mote **Di**ctionary **S**erver，远程词典服务器**，是一个基于内存的键值型NoSQL数据库**。\n\n**特征**：\n\n- 键值（key-value）型，value支持多种不同数据结构，功能丰富\n\n- 单线程，每个命令具备原子性\n\n- 低延迟，速度快（基于内存、IO多路复用、良好的编码）。\n\n- 支持数据持久化\n\n- 支持主从集群、分片集群\n\n- 支持多语言客户端\n\n### （三）安装Redis\n\n这里使用虚拟机docker安装Redis\n\n#### 1. 安装Redis\n\n通过`docker search redis`和`docker pull redis`下载redis镜像\n\n#### 2. 新建挂载配置文件夹\n\n因为 redis 默认配置你会发现只能够本地连接，不能进行远程访问，使用 Redis Desktop Manager连接都会报错，因此需要手动挂载 redis 配置文件\n\n新建data和conf两个文件夹，位置随意。\n\neg：\n\n``` shell\nmkdir -p /root/docker/redis/data\nmkdir -p /root/docker/redis/conf\n```\n\n#### 3. 增加配置文件 redis.conf\n\n在刚才新建的redis/conf中新建文件redis.conf，内容如下：\n\n``` tex\nbind 0.0.0.0\nprotected-mode yes\nport 6379\ntcp-backlog 511\ntimeout 0\ntcp-keepalive 0\nloglevel notice\nlogfile \"redis.log\"\ndatabases 16\nsave 900 1\nsave 300 10\nsave 60 10000\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename dump.rdb\ndir ./\nslave-serve-stale-data yes\nslave-read-only yes\nrepl-diskless-sync no\nrepl-diskless-sync-delay 5\nrepl-disable-tcp-nodelay no\nslave-priority 100\nappendonly no\nappendfilename \"appendonly.aof\"\nappendfsync everysec\nno-appendfsync-on-rewrite no\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\naof-load-truncated yes\nlua-time-limit 5000\nslowlog-log-slower-than 10000\nslowlog-max-len 128\nlatency-monitor-threshold 0\nnotify-keyspace-events \"\"\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nlist-max-ziplist-size -2\nlist-compress-depth 0\nset-max-intset-entries 512\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\nhll-sparse-max-bytes 3000\nactiverehashing yes\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit slave 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\nhz 10\naof-rewrite-incremental-fsync yes\nrequirepass 123321\n```\n\n#### 4. 创建redis容器并启动\n\n执行命令如下：\n\n``` shell\ndocker run --name redis -p 6379:6379 -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf\n\n```\n\n释义如下：\n\n> –name：给容器起一个名\n> -p：端口映射 宿主机:容器\n> -v：挂载自定义配置 自定义配置:容器内部配置\n> -d：后台运行 redis-server --appendonly yes： 在容器执行redis-server启动命令，并打开redis持久化配置\n\n#### 5. 启动成功，查看状态\n\n通过`docker ps`查看启动状态，是否成功\n\n#### 6. 容器内部连接进行测试\n\n执行docker exec -it redis redis-cli 命令，进入终端。\n通过auth password进行登陆。\n\n## 二、Redis常见命令\n\n## （一）Redis数据结构介绍\n\nRedis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：\n\n![image-20220528215631822](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282156887.png)\n\nRedis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ [https://redis.io/commands ](https://redis.io/commands)）可以查看到不同的命令：\n\n![image-20220528215850343](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282158400.png)\n\n## （二）通用命令\n\n通用指令是部分数据类型的，都可以使用的指令，常见的有：\n\n- KEYS：查看符合模板的所有key\n\n- DEL：删除一个指定的key\n\n- EXISTS：判断key是否存在\n\n- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除\n\n- TTL：查看一个KEY的剩余有效期\n\n通过help [command] 可以查看一个命令的具体用法，例如：\n\n![image-20220528220236830](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282202927.png)\n\n## （三）String类型\n\nString类型，也就是字符串类型，是Redis中最简单的存储类型。\n\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\n\n- string：普通字符串\n\n- int：整数类型，可以做自增、自减操作\n\n- float：浮点类型，可以做自增、自减操作\n\n不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.\n\n|  KEY  |    VALUE    |\n| :---: | :---------: |\n|  msg  | hello world |\n|  num  |     10      |\n| score |    92.5     |\n\n#### **String类型的常见命令**\n\nString的常见命令有：\n\n- SET：添加或者修改已经存在的一个String类型的键值对\n\n- GET：根据key获取String类型的value\n\n- MSET：批量添加多个String类型的键值对\n\n- MGET：根据多个key获取多个String类型的value\n\n- INCR：让一个整型的key自增1\n\n- INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\n\n- INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\n\n- SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\n\n- SETEX：添加一个String类型的键值对，并且指定有效期\n\nKey的结构\n\nRedis的key允许有多个单词形成层级结构，多个单词之间用\':\'隔开，格式如下：\n\n``` tex\n项目名:业务名:类型:id\n```\n\n这个格式并非固定，也可以根据自己的需求来删除或添加词条。\n\n例如我们的项目名称叫 icatw，有user和product两种不同类型的数据，我们可以这样定义key：\n\n- user相关的key：icatw:user:1\n\n- product相关的key：icatw:product:1\n\n在图形化界面窗口中可以清晰的看到层级结构\n\n![image-20220528222847431](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282228488.png)\n\n如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：\n\n| KEY             | VALUE                                 |\n| --------------- | ------------------------------------- |\n| icatw:user:1    | {\"id\":1, \"name\": \"Jack\", \"age\": 21}   |\n| icatw:product:1 | {\"id\":1,\"name\":\"小米11\",\"price\":4999} |\n\n> 　　总结：\n>\n> 　String类型的三种格式：\n>\n> 　- 字符串\n> 　- int\n> 　- float\n>\n> 　Redis的key的格式：\n>\n> 　- [项目名] : [业务名] : [类型] : [id]\n\n## （四）Hash类型\n\nHash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\n\n<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>\n\n| KEY          | VALUE                 |\n| ------------ | --------------------- |\n| icatw:user:1 | {name:\"Jack\", age:21} |\n| icatw:user:2 | {name:\"Rose\", age:22} |\n\nHash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：\n\n<table align=\"center\">\n    <tr align=\"center\">\n        <td rowspan=\"2\">KEY</td> \n        <td colspan=\"2\">VALUE</td> \n   </tr>\n    <tr>\n        <td >field</td>    \n  		 <td >value</td> \n    </tr>\n    <tr>\n        <td rowspan=\"2\">icatw:user:1</td> \n        <td>name</td> \n        <td>Jack</td> \n    </tr>\n    <tr>\n        <td>age</td> \n        <td>21</td> \n    </tr>\n    <tr>\n  <td rowspan=\"2\">icatw:user:1</td> \n        <td>name</td> \n        <td>Rose</td> \n    </tr>\n    <tr>\n        <td>age</td>\n        <td>18</td> \n    </tr>\n</table>\n\n\n#### **Hash的常见命令**\n\nHash的常见命令有：\n\n- HSET key field value：添加或者修改hash类型key的field的值\n\n- HGET key field：获取一个hash类型key的field的值\n\n- HMSET：批量添加多个hash类型key的field的值\n\n- HMGET：批量获取多个hash类型key的field的值\n\n- HGETALL：获取一个hash类型的key中的所有的field和value\n\n- HKEYS：获取一个hash类型的key中的所有的field\n\n- HVALS：获取一个hash类型的key中的所有的value\n\n- HINCRBY:让一个hash类型key的字段值自增并指定步长\n\n- HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n\n## （五）List类型\n\nRedis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\n\n特征也与LinkedList类似：\n\n- 有序\n\n- 元素可以重复\n\n- 插入和删除快\n\n- 查询速度一般\n\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\n\n**List类型的常见命令**\n\nList的常见命令有：\n\n- LPUSH key element ... ：向列表左侧插入一个或多个元素\n\n- LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\n\n- RPUSH key element ... ：向列表右侧插入一个或多个元素\n\n- RPOP key：移除并返回列表右侧的第一个元素\n\n- LRANGE key star end：返回一段角标范围内的所有元素\n\n- BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n  ![image-20220531160158776](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220531160158776.png)\n\n## （六）Set类型\n\nRedis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\n\n- 无序\n\n- 元素不可重复\n\n- 查找快\n\n- 支持交集、并集、差集等功能\n\nSet的常见命令\n\nSet的常见命令有：\n\n- SADD key member ... ：向set中添加一个或多个元素\n\n- SREM key member ... : 移除set中的指定元素\n\n- SCARD key： 返回set中元素的个数\n\n- SISMEMBER key member：判断一个元素是否存在于set中\n\n- SMEMBERS：获取set中的所有元素\n\n- SINTER key1 key2 ... ：求key1与key2的交集\n- SDIFF key1 key2 ... ：求key1与key2的差集\n- SUNION key1 key2 ..：求key1和key2的并集\n\n## （七）SortedSet类型\n\nRedis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\nSortedSet具备下列特性：\n\n- 可排序\n\n- 元素不重复\n\n- 查询速度快\n\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\n\n**SortedSet类型的常见命令**\n\nSortedSet的常见命令有：\n\n- ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\n\n- ZREM key member：删除sorted set中的一个指定元素\n\n- ZSCORE key member : 获取sorted set中的指定元素的score值\n\n- ZRANK key member：获取sorted set 中的指定元素的排名\n\n- ZCARD key：获取sorted set中的元素个数\n\n- ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\n\n- ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\n\n- ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\n\n- ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\n\n- ZDIFF、ZINTER、ZUNION：求差集、交集、并集\n\n注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可\n\n## 三、Redis的Java的客户端\n\n![image-20220531162938681](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220531162938681.png)\n\n### （一）Jedis客户端\n\n#### **Jedis**\n\nJedis的官网地址： https://github.com/redis/jedis，我们先来个快速入门：\n\n新建maven项目\n\n1. 引入依赖：\n\n``` xml\n    <dependencies>\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.7.1</version>\n        </dependency>\n    </dependencies>\n```\n\n2. 建立连接\n\n``` java\n    @BeforeEach\n    void setUp() {\n        //1.建立连接\n        jedis = new Jedis(\"192.168.17.130\", 6379);\n        //2.设置密码\n        jedis.auth(\"123321\");\n        //3.选择库\n        jedis.select(0);\n    }\n```\n\n3. 测试string\n\n``` java\n    @Test\n    void testString() {\n        //    存入数据\n        String result = jedis.set(\"name\", \"王顺\");\n        System.out.println(\"result:=============\" + result);\n        //    获取数据\n        String name = jedis.get(\"name\");\n        System.out.println(\"name=>\" + name);\n    }\n```\n\n4. 释放连接\n\n``` java\n    @AfterEach\n    void tearDown() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n```\n\n**总结：**\n\nJedis使用的基本步骤：\n\n1.引入依赖\n\n2.创建Jedis对象，建立连接\n\n3.使用Jedis，方法名与Redis命令一致\n\n4.释放资源\n\n#### Jedis连接池\n\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。\n\n``` java\n//jedis连接池工具类\npublic class JedisConnectionFactory {\n    private static final JedisPool JEDIS_POOL;\n\n    static {\n        //配置连接池\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n        // 最大连接\n        jedisPoolConfig.setMaxTotal(8);\n        // 最大空闲连接\n        jedisPoolConfig.setMaxIdle(8);\n        // 最小空闲连接\n        jedisPoolConfig.setMinIdle(0);\n        // 设置最长等待时间， ms\n        jedisPoolConfig.setMaxWaitMillis(200);\n        //创建连接池对象\n        JEDIS_POOL = new JedisPool(jedisPoolConfig,\n                \"192.168.150.101\", 6379, 1000, \"123321\");\n    }\n\n    /**\n     * 获取jedis对象\n     *\n     * @return {@link Jedis}\n     */\n    public static Jedis getJedis() {\n        return JEDIS_POOL.getResource();\n    }\n}\n```\n\n测试\n\n``` java\n    @BeforeEach\n    void setUp() {\n        //1.建立连接\n        jedis = JedisConnectionFactory.getJedis();\n        //2.设置密码\n        jedis.auth(\"123321\");\n        //3.选择库\n        jedis.select(0);\n    }\n```\n\n\n\n### （二）SpringDataRedis客户端\n\n#### **SpringDataRedis**\n\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis\n\n- 提供了对不同Redis客户端的整合（Lettuce和Jedis）\n\n- 提供了RedisTemplate统一API来操作Redis\n\n- 支持Redis的发布订阅模型\n\n- 支持Redis哨兵和Redis集群\n\n- 支持基于Lettuce的响应式编程\n\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\n\n- 支持基于Redis的JDKCollection实现\n\n#### **SpringDataRedis快速入门**\n\nSpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\n\n| API                             | 返回值类型      | 说明                  |\n| ------------------------------- | --------------- | --------------------- |\n| **redisTemplate**.opsForValue() | ValueOperations | 操作String类型数据    |\n| **redisTemplate**.opsForHash()  | HashOperations  | 操作Hash类型数据      |\n| **redisTemplate**.opsForList()  | ListOperations  | 操作List类型数据      |\n| **redisTemplate**.opsForSet()   | SetOperations   | 操作Set类型数据       |\n| **redisTemplate**.opsForZSet()  | ZSetOperations  | 操作SortedSet类型数据 |\n| **redisTemplate**               |                 | 通用的命令            |\n\nSpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：\n\n新建springboot项目\n\n1. 引入依赖\n\n``` xml\n<!--Redis依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId\n    <artifactId>spring-boot-starter-data-redis</artifactId></dependency>\n<!--连接池依赖-->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n```\n\n2. 配置文件\n\n``` yaml\nspring:\n  redis:\n    host: 192.168.17.130\n    port: 6379\n    password: 123321\n    lettuce:\n      pool:\n        max-active: 8 # 最大连接\n        max-idle: 8 # 最大空闲连接\n        min-idle: 0 # 最小空闲连接\n        max-wait: 100 # 连接等待时间\n```\n\n3. 注入RedisTemplate\n\n``` java\n@Autowired\nprivate RedisTemplate redisTemplate;\n```\n\n4. 编写测试\n\n``` java\n/**\n *\n * @author icatw\n * @date 2022/06/01\n */\n@SpringBootTest\nclass RedisDemoApplicationTests {\n    @Autowired\n    RedisTemplate redisTemplate;\n\n    @Test\n    void contextLoads() {\n    }\n\n    @Test\n    void testString() {\n        redisTemplate.opsForValue().set(\"name\", \"李四\");\n        Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(\"name=\" + name);\n    }\n}\n```\n\n**总结**：\n\nSpringDataRedis的使用步骤：\n\n1.引入spring-boot-starter-data-redis依赖\n\n2.在application.yml配置Redis信息\n\n3.注入RedisTemplate\n\n#### **SpringDataRedis的序列化方式**\n\nRedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：\n\n![image-20220601160515943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601160515943.png)\n\n缺点：\n\n- 可读性差\n\n- 内存占用较大\n\n我们可以自定义RedisTemplate的序列化方式，代码如下：\n\n``` java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        // 创建Template\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        // 设置连接工厂\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        // 设置序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\n                new GenericJackson2JsonRedisSerializer();\n        // key和 hashKey采用 string序列化\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\n        //value和 hashValue采用 JSON序列化\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\n        return redisTemplate;\n    }\n\n}\n```\n\n注：\n\n如果没有使用web依赖则需要手动引入jackson依赖，否则将会报错\n\n``` xml\n<!--        jackson依赖 json序列化-->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n        </dependency>\n```\n\n#### **StringRedisTemplate**\n\n尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：\n\n![image-20220601164333457](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601164333457.png)\n\n为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。\n\n为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。\n\n![image-20220601164530393](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601164530393.png)\n\nSpring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程：\n\n``` java\n@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n// JSON工具\nprivate static final ObjectMapper mapper = new ObjectMapper();\n@Test\nvoid testStringTemplate() throws JsonProcessingException {\n    // 准备对象\n    User user = new User(\"虎哥\", 18);\n    // 手动序列化\n    String json = mapper.writeValueAsString(user);\n    // 写入一条数据到redis\n    stringRedisTemplate.opsForValue().set(\"user:200\", json);     // 读取数据\n    String val = stringRedisTemplate.opsForValue().get(\"user:200\");\n    // 反序列化 \n    User user1 = mapper.readValue(val, User.class); System.out.println(\"user1 = \" + user1);}\n\n```\n\n使用fastjson\n\n1. 引依赖\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.80</version>\n</dependency>\n```\n\n2. 注入StringRedisTemplate\n\n``` java\n@Autowired\nStringRedisTemplate stringRedisTemplate;\n```\n\n3. 测试\n\n``` java\n    @Test\n    void stringRedisTemplate() {\n        User user = new User(\"cs\", \"123\");\n        String jsonString = JSON.toJSONString(user);\n        //先把java对象转为json再存入redis，序列化\n        stringRedisTemplate.opsForValue().set(\"user\", jsonString);\n        String s = stringRedisTemplate.opsForValue().get(\"user\");\n        //将取出的redis数据转为java对象，反序列化\n        User json =JSON.parseObject(s, User.class);\n        System.out.println(json);\n    }\n```\n\n![image-20220601165839022](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601165839022.png)\n\n![image-20220601170500767](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601170500767.png)\n\n#### 总结：\n\nRedisTemplate的两种序列化实践方案：\n\n**方案一：**\n\n1.自定义RedisTemplate\n\n2.修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer\n\n**方案二：**\n\n1.使用StringRedisTemplate\n\n2.写入Redis时，手动把对象序列化为JSON\n\n3.读取Redis时，手动把读取到的JSON反序列化为对象',1,'',0,0,1,'2022-06-13 12:55:58',NULL),(106,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/321e9090797e8a5dbbe46528503198ca.jpg','事务注解 @Transactional 失效的3种场景及解决办法','# 事务注解 @Transactional 失效的3种场景及解决办法\n\n## **Transactional失效场景**\n\n### **第一种失效场景**\n\n**当Transactional注解标注方法修饰符为非public时**，@Transactional注解将会不起作用。例如以下代码，定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法：\n\n```java\n@Component\npublic class TestServiceImpl {\n    @Resource\n    TestMapper testMapper;\n    \n    @Transactional\n    void insertTestWrongModifier() {\n        int re = testMapper.insert(new Test(10,20,30));\n        if (re > 0) {\n            throw new NeedToInterceptException(\"need intercept\");\n        }\n        testMapper.insert(new Test(210,20,30));\n    }\n \n}\n```\n\n在同一个包内，新建调用对象，进行访问。\n\n``` java\n@Component\npublic class InvokcationService {\n    @Resource\n    private TestServiceImpl testService;\n    public void invokeInsertTestWrongModifier(){\n        //调用@Transactional标注的默认访问符方法\n        testService.insertTestWrongModifier();\n    }\n}\n```\n\n测试用例：\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class DemoApplicationTests {\n   @Resource\n   InvokcationService invokcationService;\n \n   @Test\n   public void  testInvoke(){\n      invokcationService.invokeInsertTestWrongModifier();\n   }\n}\n```\n\n以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果`TestServiceImpl#insertTestWrongModifier`方法改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。\n\n### 第二种失效场景\n\n**在类内部调用调用类内部@Transactional标注的方法**，这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用：\n\n```php\n@Component\npublic class TestServiceImpl implements TestService {\n    @Resource\n    TestMapper testMapper;\n \n    @Transactional\n    public void insertTestInnerInvoke() {\n        //正常public修饰符的事务方法\n        int re = testMapper.insert(new Test(10,20,30));\n        if (re > 0) {\n            throw new NeedToInterceptException(\"need intercept\");\n        }\n        testMapper.insert(new Test(210,20,30));\n    }\n \n \n    public void testInnerInvoke(){\n        //类内部调用@Transactional标注的方法。\n        insertTestInnerInvoke();\n    }\n \n}\n```\n\n测试用例：\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class DemoApplicationTests {\n \n   @Resource\n   TestServiceImpl testService;\n \n   /**\n    * 测试内部调用@Transactional标注方法\n    */\n   @Test\n   public void  testInnerInvoke(){\n       //测试外部调用事务方法是否正常\n      //testService.insertTestInnerInvoke();\n       //测试内部调用事务方法是否正常\n      testService.testInnerInvoke();\n   }\n}\n```\n\n上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚；\n\n然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。\n\n### 第三种失效场景\n\n事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下。\n\n``` java\n@Component\npublic class TestServiceImpl implements TestService {\n    @Resource\n    TestMapper testMapper;\n \n    @Transactional\n    public void insertTestCatchException() {\n        try {\n            int re = testMapper.insert(new Test(10,20,30));\n            if (re > 0) {\n                //运行期间抛异常\n                throw new NeedToInterceptException(\"need intercept\");\n            }\n            testMapper.insert(new Test(210,20,30));\n        }catch (Exception e){\n            System.out.println(\"i catch exception\");\n        }\n    }\n    \n}\n```\n\n测试用例代码如下：\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class DemoApplicationTests {\n \n   @Resource\n   TestServiceImpl testService;\n \n   @Test\n   public void testCatchException(){\n      testService.insertTestCatchException();\n   }\n}\n```\n\n运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。\n\n以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。\n\n**@Transactional注解不起作用原理分析**\n\n### 第一种场景分析\n\n`@Transactional`注解标注方法修饰符为非public时，`@Transactional`注解将会不起作用。这里分析 的原因是，`@Transactional`是基于动态代理实现的，`@Transactional`注解实现原理中分析了实现方法，在bean初始化过程中，对含有`@Transactional`标注的bean实例创建代理对象，这里就存在一个spring扫描`@Transactional`注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的`@Transactional`信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用\n\n`@Transactional`注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是。根据spring创建好一个aop切点`BeanFactoryTransactionAttributeSourceAdvisor`实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含`@Transactional`，如果bean任何一个方法包含`@Transactional`注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。\n\nspring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，\n\n```\nAopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class<?>, boolean)\n```\n\n``` java\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n   Assert.notNull(pc, \"Pointcut must not be null\");\n   if (!pc.getClassFilter().matches(targetClass)) {\n      return false;\n   }\n \n   MethodMatcher methodMatcher = pc.getMethodMatcher();\n   if (methodMatcher == MethodMatcher.TRUE) {\n      // No need to iterate the methods if we\'re matching any method anyway...\n      return true;\n   }\n \n   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n   }\n \n    //遍历class的方法对象\n   Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n   classes.add(targetClass);\n   for (Class<?> clazz : classes) {\n      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n      for (Method method : methods) {\n         if ((introductionAwareMethodMatcher != null &&\n               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n             //适配查询方法上的@Transactional注解信息  \n             methodMatcher.matches(method, targetClass)) {\n            return true;\n         }\n      }\n   }\n \n   return false;\n}\n```\n\n我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。\n\n```\nAbstractFallbackTransactionAttributeSource#getTransactionAttribute\n```\n\n- `AbstractFallbackTransactionAttributeSource#computeTransactionAttribute`\n\n``` java\nprotected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {\n   // Don\'t allow no-public methods as required.\n   //非public 方法，返回@Transactional信息一律是null\n   if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n      return null;\n   }\n   //后面省略.......\n }\n```\n\n#### 不创建代理对象\n\n所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。\n\n![image-20220630010117451](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206300101513.png)\n\n如果class中的方法都是非public的那么将不是代理对象。\n\n![image-20220630010131173](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206300101213.png)\n\n#### 不进行代理调用\n\n考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。\n\n创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。\n\n``` java\n@Component\npublic class TestServiceImpl implements TestService {\n    @Resource\n    TestMapper testMapper;\n \n    @Override\n    @Transactional\n    public void insertTest() {\n        int re = testMapper.insert(new Test(10,20,30));\n        if (re > 0) {\n            throw new NeedToInterceptException(\"need intercept\");\n        }\n        testMapper.insert(new Test(210,20,30));\n    }\n    \n    @Transactional\n    void insertTestWrongModifier() {\n        int re = testMapper.insert(new Test(10,20,30));\n        if (re > 0) {\n            throw new NeedToInterceptException(\"need intercept\");\n        }\n        testMapper.insert(new Test(210,20,30));\n    }\n}\n \n```\n\n原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中`CglibAopProxy.DynamicAdvisedInterceptor#intercept`，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。\n\n``` java\nList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n```\n\n而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次\n\n```\nAbstractFallbackTransactionAttributeSource#getTransactionAttribute\n```\n\n- `AbstractFallbackTransactionAttributeSource#computeTransactionAttribute`\n\n也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。\n\n### 第二种场景分析\n\n在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。\n\n经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到；\n\n> 既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。\n\n其实我们可以这样玩，内部调用也能实现开启事务，代码如下。\n\n``` java\n@Component\npublic class TestServiceImpl implements TestService {\n    @Resource\n    TestMapper testMapper;\n \n    @Resource\n    TestServiceImpl testServiceImpl;\n \n \n    @Transactional\n    public void insertTestInnerInvoke() {\n        int re = testMapper.insert(new Test(10,20,30));\n        if (re > 0) {\n            throw new NeedToInterceptException(\"need intercept\");\n        }\n        testMapper.insert(new Test(210,20,30));\n    }\n \n \n    public void testInnerInvoke(){\n        //内部调用事务方法\n        testServiceImpl.insertTestInnerInvoke();\n    }\n \n}\n```\n\n上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩~\n\n### 第三种场景分析\n\n事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。\n\n这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里卖弄动态代理逻辑是如何为我们管理事务的。\n\n```\nTransactionAspectSupport#invokeWithinTransaction\n```\n\n代码如下。\n\n``` java\nprotected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)\n      throws Throwable {\n \n   // If the transaction attribute is null, the method is non-transactional.\n   final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);\n   final PlatformTransactionManager tm = determineTransactionManager(txAttr);\n   final String joinpointIdentification = methodIdentification(method, targetClass);\n \n   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\n      // Standard transaction demarcation with getTransaction and commit/rollback calls.\n       //开启事务\n      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\n      Object retVal = null;\n      try {\n         // This is an around advice: Invoke the next interceptor in the chain.\n         // This will normally result in a target object being invoked.\n          //反射调用业务方法\n         retVal = invocation.proceedWithInvocation();\n      }\n      catch (Throwable ex) {\n         // target invocation exception\n          //异常时，在catch逻辑中回滚事务\n         completeTransactionAfterThrowing(txInfo, ex);\n         throw ex;\n      }\n      finally {\n         cleanupTransactionInfo(txInfo);\n      }\n       //提交事务\n      commitTransactionAfterReturning(txInfo);\n      return retVal;\n   }\n \n   else {\n     //....................\n   }\n}\n```\n\n所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。',2,'https://blog.csdn.net/hollis_chuang/article/details/115713374',0,0,1,'2022-06-30 01:07:39',NULL),(107,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4f607a38bb9f9d333c858205bfd38a55.jpg','Redis实现消息队列','# Redis消息队列\n\n**消息队列**（**M**essage **Q**ueue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：\n\n- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）\n\n- 生产者：发送消息到消息队列\n\n- 消费者：从消息队列获取消息并处理消息\n\n![image-20220630231817103](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302318189.png)\n\nRedis提供了三种不同的方式来实现消息队列：\n\n- list结构：基于List结构模拟消息队列\n\n- PubSub：基本的点对点消息模型\n\n- Stream：比较完善的消息队列模型\n\n## 基于List消息队列\n\n**Redis的list数据结构是一个双向链表，很容易模拟出队列效果。**\n\n队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。\n\n不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用**BRPOP**或者**BLPOP**来实现阻塞效果。\n\n![image-20220630232001933](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302320983.png)\n\n### 总结\n\n基于List的消息队列有哪些优缺点？\n\n优点：\n\n- 利用Redis存储，不受限于JVM内存上限\n\n- 基于Redis的持久化机制，数据安全性有保证\n\n- 可以满足消息有序性\n\n缺点：\n\n- 无法避免消息丢失\n\n- 只支持单消费者\n\n## 基于PubSub的消息队列\n\n**PubSub（发布订阅）**是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。\n\n-  SUBSCRIBE channel [channel] ：订阅一个或多个频道\n\n*  PUBLISH channel msg ：向一个频道发送消息\n\n-  PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道\n\n![image-20220630232343307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302323359.png)\n\n### 总结\n\n基于PubSub的消息队列有哪些优缺点？\n\n优点：\n\n- 采用发布订阅模型，支持多生产、多消费\n\n缺点：\n\n- 不支持数据持久化\n\n- 无法避免消息丢失\n\n- 消息堆积有上限，超出时数据丢失\n\n## 基于Stream的消息队列\n\nStream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。\n\n![image-20220701141016083](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410178.png)\n\n![image-20220701141027340](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410411.png)\n\n![image-20220701141051694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410758.png)\n\n### 总结\n\nSTREAM类型消息队列的XREAD命令特点：\n\n- 消息可回溯\n\n- 一个消息可以被多个消费者读取\n\n- 可以阻塞读取\n\n- 有消息漏读的风险\n\n## 基于Stream的消息队列-消费者组\n\n**消费者组（Consumer Group）**：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：\n\n![image-20220701142516546](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425603.png)\n\n![image-20220701142528396](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425454.png)\n\n![image-20220701142539919](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425975.png)\n\n![image-20220701142601370](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011426421.png)\n\n### 总结\n\nSTREAM类型消息队列的XREADGROUP命令特点：\n\n- 消息可回溯\n\n- 可以多消费者争抢消息，加快消费速度\n\n- 可以阻塞读取\n\n- 没有消息漏读的风险\n\n- 有消息确认机制，保证消息至少被消费一次\n\n![image-20220701142648622](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011426688.png)',1,'',0,0,1,'2022-07-02 17:20:53',NULL),(108,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ad41d14a2ca9c12b629ac97ab0387df3.jpg','Redis高级-分布式缓存','# 分布式缓存\n\n-- 基于Redis集群解决单机Redis存在的问题\n\n\n\n单机的Redis存在四大问题：\n\n![image-20210725144240631](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723923.png)\n\n\n\n\n\n# 0.学习目标\n\n\n\n# 1.Redis持久化\n\nRedis有两种持久化方案：\n\n- RDB持久化\n- AOF持久化\n\n\n\n## 1.1.RDB持久化\n\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\n\n### 1.1.1.执行时机\n\nRDB持久化在四种情况下会执行：\n\n- 执行save命令\n- 执行bgsave命令\n- Redis停机时\n- 触发RDB条件时\n\n\n\n**1）save命令**\n\n执行下面的命令，可以立即执行一次RDB：\n\n![image-20210725144536958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723924.png)\n\nsave命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\n\n\n\n**2）bgsave命令**\n\n下面的命令可以异步执行RDB：\n\n![image-20210725144725943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723925.png)\n\n这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。\n\n\n\n**3）停机时**\n\nRedis停机时会执行一次save命令，实现RDB持久化。\n\n\n\n**4）触发RDB条件**\n\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\n\n```properties\n# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \"\" 则表示禁用RDB\nsave 900 1  \nsave 300 10  \nsave 60 10000 \n```\n\n\n\nRDB的其它配置也可以在redis.conf文件中设置：\n\n```properties\n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\nrdbcompression yes\n\n# RDB文件名称\ndbfilename dump.rdb  \n\n# 文件保存的路径目录\ndir ./ \n```\n\n\n\n### 1.1.2.RDB原理\n\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。\n\nfork采用的是copy-on-write技术：\n\n- 当主进程执行读操作时，访问共享内存；\n- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。\n\n![image-20210725151319695](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723926.png)\n\n\n\n\n\n### 1.1.3.小结\n\nRDB方式bgsave的基本流程？\n\n- fork主进程得到一个子进程，共享内存空间\n- 子进程读取内存数据并写入新的RDB文件\n- 用新RDB文件替换旧的RDB文件\n\nRDB会在什么时候执行？save 60 1000代表什么含义？\n\n- 默认是服务停止时\n- 代表60秒内至少执行1000次修改则触发RDB\n\nRDB的缺点？\n\n- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\n- fork子进程、压缩、写出RDB文件都比较耗时\n\n\n\n## 1.2.AOF持久化\n\n\n\n### 1.2.1.AOF原理\n\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\n\n![image-20210725151543640](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723927.png)\n\n\n\n### 1.2.2.AOF配置\n\nAOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\n\n```properties\n# 是否开启AOF功能，默认是no\nappendonly yes\n# AOF文件的名称\nappendfilename \"appendonly.aof\"\n```\n\n\n\nAOF的命令记录的频率也可以通过redis.conf文件来配：\n\n```properties\n# 表示每执行一次写命令，立即记录到AOF文件\nappendfsync always \n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\nappendfsync everysec \n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\nappendfsync no\n```\n\n\n\n三种策略对比：\n\n![image-20210725151654046](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723928.png)\n\n\n\n### 1.2.3.AOF文件重写\n\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\n\n![image-20210725151729118](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723929.png)\n\n如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。\n\n所以重写命令后，AOF文件内容就是：`mset name jack num 666`\n\n\n\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\n\n```properties\n# AOF文件比上次文件 增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# AOF文件体积最小多大以上才触发重写 \nauto-aof-rewrite-min-size 64mb \n```\n\n\n\n## 1.3.RDB与AOF对比\n\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。\n\n![image-20210725151940515](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723930.png)\n\n\n\n# 2.Redis主从\n\n## 2.1.搭建主从架构\n\n单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。\n\n![image-20210725152037611](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723931.png)\n\n具体搭建流程参考课前资料《Redis集群.md》：\n\n![image-20210725152052501](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723932.png) \n\n\n\n\n\n## 2.2.主从数据同步原理\n\n\n\n### 2.2.1.全量同步\n\n主从第一次建立连接时，会执行**全量同步**，将master节点的所有数据都拷贝给slave节点，流程：\n\n![image-20210725152222497](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723933.png)\n\n\n\n这里有一个问题，master如何得知salve是第一次来连接呢？？\n\n有几个概念，可以作为判断依据：\n\n- **Replication Id**：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid\n- **offset**：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。\n\n因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。\n\n\n\n因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。\n\nmaster判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。\n\nmaster会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。\n\n因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致**。\n\n如图：\n\n![image-20210725152700914](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723934.png)\n\n\n\n完整流程描述：\n\n- slave节点请求增量同步\n- master节点判断replid，发现不一致，拒绝增量同步\n- master将完整内存数据生成RDB，发送RDB到slave\n- slave清空本地数据，加载master的RDB\n- master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave\n- slave执行接收到的命令，保持与master之间的同步\n\n\n\n### 2.2.2.增量同步\n\n全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做**增量同步**。\n\n什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：\n\n![image-20210725153201086](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723935.png)\n\n\n\n那么master怎么知道slave与自己的数据差异在哪里呢?\n\n\n\n### 2.2.3.repl_backlog原理\n\nmaster怎么知道slave与自己的数据差异在哪里呢?\n\n这就要说到全量同步时的repl_baklog文件了。\n\n这个文件是一个固定大小的数组，只不过数组是环形，也就是说**角标到达数组末尾后，会再次从0开始读写**，这样数组头部的数据就会被覆盖。\n\nrepl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：\n\n![image-20210725153359022](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723937.png) \n\nslave与master的offset之间的差异，就是salve需要增量拷贝的数据了。\n\n随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：\n\n![image-20210725153524190](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723938.png) \n\n\n\n直到数组被填满：\n\n![image-20210725153715910](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723939.png) \n\n此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。\n\n\n\n但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： \n\n![image-20210725153937031](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723940.png) \n\n如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：\n\n![image-20210725154155984](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723941.png) \n\n\n\n棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。\n\n![image-20210725154216392](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723942.png)\n\n\n\n\n\n## 2.3.主从同步优化\n\n主从同步可以保证主从数据的一致性，非常重要。\n\n可以从以下几个方面来优化Redis主从就集群：\n\n- 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。\n- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO\n- 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步\n- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力\n\n主从从架构图：\n\n![image-20210725154405899](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723943.png)\n\n\n\n## 2.4.小结\n\n简述全量同步和增量同步区别？\n\n- 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。\n- 增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave\n\n什么时候执行全量同步？\n\n- slave节点第一次连接master节点时\n- slave节点断开时间太久，repl_baklog中的offset已经被覆盖时\n\n什么时候执行增量同步？\n\n- slave节点断开又恢复，并且在repl_baklog中能找到offset时\n\n\n\n\n\n# 3.Redis哨兵\n\nRedis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。\n\n## 3.1.哨兵原理\n\n### 3.1.1.集群结构和作用\n\n哨兵的结构如图：\n\n![image-20210725154528072](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723944.png)\n\n哨兵的作用如下：\n\n- **监控**：Sentinel 会不断检查您的master和slave是否按预期工作\n- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主\n- **通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端\n\n\n\n### 3.1.2.集群监控原理\n\nSentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\n\n•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。\n\n•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。\n\n![image-20210725154632354](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723945.png)\n\n\n\n### 3.1.3.集群故障恢复原理\n\n一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：\n\n- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\n- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举\n- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\n- 最后是判断slave节点的运行id大小，越小优先级越高。\n\n\n\n当选出一个新的master后，该如何实现切换呢？\n\n流程如下：\n\n- sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master\n- sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。\n- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点\n\n\n\n![image-20210725154816841](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723946.png)\n\n\n\n\n\n\n\n\n\n\n\n### 3.1.4.小结\n\nSentinel的三个作用是什么？\n\n- 监控\n- 故障转移\n- 通知\n\nSentinel如何判断一个redis实例是否健康？\n\n- 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线\n- 如果大多数sentinel都认为实例主观下线，则判定服务下线\n\n故障转移步骤有哪些？\n\n- 首先选定一个slave作为新的master，执行slaveof no one\n- 然后让所有节点都执行slaveof 新master\n- 修改故障节点配置，添加slaveof 新master\n\n\n\n## 3.2.搭建哨兵集群\n\n具体搭建流程参考课前资料《Redis集群.md》：\n\n![image-20210725155019276](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723947.png) \n\n\n\n## 3.3.RedisTemplate\n\n在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。\n\n下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。\n\n### 3.3.1.导入Demo工程\n\n首先，我们引入课前资料提供的Demo工程：\n\n![image-20210725155124958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723948.png) \n\n\n\n### 3.3.2.引入依赖\n\n在项目的pom文件中引入依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n\n\n### 3.3.3.配置Redis地址\n\n然后在配置文件application.yml中指定redis的sentinel相关信息：\n\n```java\nspring:\n  redis:\n    sentinel:\n      master: mymaster\n      nodes:\n        - 192.168.150.101:27001\n        - 192.168.150.101:27002\n        - 192.168.150.101:27003\n```\n\n\n\n### 3.3.4.配置读写分离\n\n在项目的启动类中，添加一个新的bean：\n\n```java\n@Bean\npublic LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){\n    return clientConfigurationBuilder -> clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);\n}\n```\n\n\n\n这个bean中配置的就是读写策略，包括四种：\n\n- MASTER：从主节点读取\n- MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica\n- REPLICA：从slave（replica）节点读取\n- REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master\n\n\n\n\n\n# 4.Redis分片集群\n\n\n\n## 4.1.搭建分片集群\n\n主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\n\n- 海量数据存储问题\n\n- 高并发写的问题\n\n使用分片集群可以解决上述问题，如图:\n\n![image-20210725155747294](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723949.png)\n\n\n\n分片集群特征：\n\n- 集群中有多个master，每个master保存不同数据\n\n- 每个master都可以有多个slave节点\n\n- master之间通过ping监测彼此健康状态\n\n- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点\n\n\n\n具体搭建流程参考课前资料《Redis集群.md》：\n\n![image-20210725155806288](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723950.png) \n\n\n\n## 4.2.散列插槽\n\n### 4.2.1.插槽原理\n\nRedis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：\n\n![image-20210725155820320](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723951.png)\n\n\n\n数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：\n\n- key中包含\"{}\"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分\n- key中不包含“{}”，整个key都是有效部分\n\n\n\n\n\n例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。\n\n![image-20210725155850200](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723952.png) \n\n如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。\n\n到了7003后，执行`get num`时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点\n\n\n\n### 4.2.1.小结\n\nRedis如何判断某个key应该在哪个实例？\n\n- 将16384个插槽分配到不同的实例\n- 根据key的有效部分计算哈希值，对16384取余\n- 余数作为插槽，寻找插槽所在实例即可\n\n如何将同一类数据固定的保存在同一个Redis实例？\n\n- 这一类数据使用相同的有效部分，例如key都以{typeId}为前缀\n\n\n\n\n\n\n\n## 4.3.集群伸缩\n\nredis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：\n\n![image-20210725160138290](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723953.png)\n\n比如，添加节点的命令：\n\n![image-20210725160448139](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723954.png)\n\n\n\n### 4.3.1.需求分析\n\n需求：向集群中添加一个新的master节点，并向其中存储 num = 10\n\n- 启动一个新的redis实例，端口为7004\n- 添加7004到之前的集群，并作为一个master节点\n- 给7004节点分配插槽，使得num这个key可以存储到7004实例\n\n\n\n这里需要两个新的功能：\n\n- 添加一个节点到集群中\n- 将部分插槽分配到新插槽\n\n\n\n### 4.3.2.创建新的redis实例\n\n创建一个文件夹：\n\n```sh\nmkdir 7004\n```\n\n拷贝配置文件：\n\n```sh\ncp redis.conf /7004\n```\n\n修改配置文件：\n\n```sh\nsed /s/6379/7004/g 7004/redis.conf\n```\n\n启动\n\n```sh\nredis-server 7004/redis.conf\n```\n\n\n\n### 4.3.3.添加新节点到redis\n\n添加节点的语法如下：\n\n![image-20210725160448139](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723954.png)\n\n\n\n执行命令：\n\n```sh\nredis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001\n```\n\n\n\n通过命令查看集群状态：\n\n```sh\nredis-cli -p 7001 cluster nodes\n```\n\n\n\n如图，7004加入了集群，并且默认是一个master节点：\n\n![image-20210725161007099](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723955.png)\n\n但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上\n\n\n\n### 4.3.4.转移插槽\n\n我们要将num存储到7004节点，因此需要先看看num的插槽是多少：\n\n![image-20210725161241793](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723956.png)\n\n如上图所示，num的插槽为2765.\n\n\n\n我们可以将0~3000的插槽从7001转移到7004，命令格式如下：\n\n![image-20210725161401925](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723957.png)\n\n\n\n具体命令如下：\n\n建立连接：\n\n![image-20210725161506241](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723958.png)\n\n得到下面的反馈：\n\n![image-20210725161540841](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723959.png)\n\n\n\n询问要移动多少个插槽，我们计划是3000个：\n\n新的问题来了：\n\n![image-20210725161637152](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723960.png)\n\n那个node来接收这些插槽？？\n\n显然是7004，那么7004节点的id是多少呢？\n\n![image-20210725161731738](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723961.png)\n\n复制这个id，然后拷贝到刚才的控制台后：\n\n![image-20210725161817642](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723962.png)\n\n这里询问，你的插槽是从哪里移动过来的？\n\n- all：代表全部，也就是三个节点各转移一部分\n- 具体的id：目标节点的id\n- done：没有了\n\n\n\n这里我们要从7001获取，因此填写7001的id：\n\n![image-20210725162030478](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723963.png)\n\n填完后，点击done，这样插槽转移就准备好了：\n\n![image-20210725162101228](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723964.png)\n\n确认要转移吗？输入yes：\n\n然后，通过命令查看结果：\n\n![image-20210725162145497](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723965.png) \n\n可以看到： \n\n![image-20210725162224058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723966.png)\n\n目的达成。\n\n\n\n\n\n## 4.4.故障转移\n\n集群初识状态是这样的：\n\n![image-20210727161152065](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723967.png)\n\n其中7001、7002、7003都是master，我们计划让7002宕机。\n\n\n\n### 4.4.1.自动故障转移\n\n当集群中有一个master宕机会发生什么呢？\n\n直接停止一个redis实例，例如7002：\n\n```sh\nredis-cli -p 7002 shutdown\n```\n\n\n\n1）首先是该实例与其它实例失去连接\n\n2）然后是疑似宕机：\n\n![image-20210725162319490](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723968.png)\n\n3）最后是确定下线，自动提升一个slave为新的master：\n\n![image-20210725162408979](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723969.png)\n\n4）当7002再次启动，就会变为一个slave节点了：\n\n![image-20210727160803386](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723970.png)\n\n\n\n### 4.4.2.手动故障转移\n\n利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：\n\n![image-20210725162441407](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723971.png)\n\n\n\n这种failover命令可以指定三种模式：\n\n- 缺省：默认的流程，如图1~6歩\n- force：省略了对offset的一致性校验\n- takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见\n\n\n\n**案例需求**：在7002这个slave节点执行手动故障转移，重新夺回master地位\n\n步骤如下：\n\n1）利用redis-cli连接7002这个节点\n\n2）执行cluster failover命令\n\n如图：\n\n![image-20210727160037766](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723972.png)\n\n\n\n效果：\n\n![image-20210727161152065](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723967.png)\n\n\n\n## 4.5.RedisTemplate访问分片集群\n\nRedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：\n\n1）引入redis的starter依赖\n\n2）配置分片集群地址\n\n3）配置读写分离\n\n与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：\n\n```yaml\nspring:\n  redis:\n    cluster:\n      nodes:\n        - 192.168.150.101:7001\n        - 192.168.150.101:7002\n        - 192.168.150.101:7003\n        - 192.168.150.101:8001\n        - 192.168.150.101:8002\n        - 192.168.150.101:8003\n```\n\n\n\n',1,'',0,0,1,'2022-07-02 18:57:46',NULL),(109,1,194,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e25d332a34576199842e1298e8b06000.jpg','面试官：Redis持久化了解吗','# 1.Redis持久化\n\nRedis有两种持久化方案：\n\n- RDB持久化\n- AOF持久化\n\n\n\n## 1.1.RDB持久化\n\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\n\n### 1.1.1.执行时机\n\nRDB持久化在四种情况下会执行：\n\n- 执行save命令\n- 执行bgsave命令\n- Redis停机时\n- 触发RDB条件时\n\n\n\n**1）save命令**\n\n执行下面的命令，可以立即执行一次RDB：\n\n![image-20210725144536958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723924.png)\n\nsave命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\n\n\n\n**2）bgsave命令**\n\n下面的命令可以异步执行RDB：\n\n![image-20210725144725943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723925.png)\n\n这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。\n\n\n\n**3）停机时**\n\nRedis停机时会执行一次save命令，实现RDB持久化。\n\n\n\n**4）触发RDB条件**\n\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\n\n```properties\n# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \"\" 则表示禁用RDB\nsave 900 1  \nsave 300 10  \nsave 60 10000 \n```\n\n\n\nRDB的其它配置也可以在redis.conf文件中设置：\n\n```properties\n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\nrdbcompression yes\n\n# RDB文件名称\ndbfilename dump.rdb  \n\n# 文件保存的路径目录\ndir ./ \n```\n\n\n\n### 1.1.2.RDB原理\n\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。\n\nfork采用的是copy-on-write技术：\n\n- 当主进程执行读操作时，访问共享内存；\n- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。\n\n![image-20210725151319695](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723926.png)\n\n\n\n\n\n### 1.1.3.小结\n\nRDB方式bgsave的基本流程？\n\n- fork主进程得到一个子进程，共享内存空间\n- 子进程读取内存数据并写入新的RDB文件\n- 用新RDB文件替换旧的RDB文件\n\nRDB会在什么时候执行？save 60 1000代表什么含义？\n\n- 默认是服务停止时\n- 代表60秒内至少执行1000次修改则触发RDB\n\nRDB的缺点？\n\n- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\n- fork子进程、压缩、写出RDB文件都比较耗时\n\n\n\n## 1.2.AOF持久化\n\n\n\n### 1.2.1.AOF原理\n\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\n\n![image-20210725151543640](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723927.png)\n\n\n\n### 1.2.2.AOF配置\n\nAOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\n\n```properties\n# 是否开启AOF功能，默认是no\nappendonly yes\n# AOF文件的名称\nappendfilename \"appendonly.aof\"\n```\n\n\n\nAOF的命令记录的频率也可以通过redis.conf文件来配：\n\n```properties\n# 表示每执行一次写命令，立即记录到AOF文件\nappendfsync always \n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\nappendfsync everysec \n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\nappendfsync no\n```\n\n\n\n三种策略对比：\n\n![image-20210725151654046](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723928.png)\n\n\n\n### 1.2.3.AOF文件重写\n\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\n\n![image-20210725151729118](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723929.png)\n\n如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。\n\n所以重写命令后，AOF文件内容就是：`mset name jack num 666`\n\n\n\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\n\n```properties\n# AOF文件比上次文件 增长超过多少百分比则触发重写\nauto-aof-rewrite-percentage 100\n# AOF文件体积最小多大以上才触发重写 \nauto-aof-rewrite-min-size 64mb \n```\n\n\n\n## 1.3.RDB与AOF对比\n\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。\n\n![image-20210725151940515](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723930.png)',1,'',0,0,1,'2022-07-02 19:01:30',NULL),(110,1,197,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/754cca93d7c5838b8ffb899b7d7e8b7e.jpg','MySQL进阶（存储引擎）','# MySQL进阶（存储引擎）\n\n# 1. 存储引擎\n\n## 1.1 MySQL体系结构\n\n![image-20220707010322642](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070103898.png)\n\n1). 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。 \n\n2). 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。 \n\n3). 引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。 \n\n4). 存储层 数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\n\n## 1.2 存储引擎介绍\n\n![image-20220707010442964](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070104051.png)\n\n大家可能没有听说过存储引擎，但是一定听过引擎这个词，引擎就是发动机，是一个机器的核心组件。 比如，对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择 引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎 一样。 \n\n而对于存储引擎，也是一样，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。 \n\n**存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。**\n\n我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。\n\n1). 建表时指定存储引擎\n\n``` sql\nCREATE TABLE 表名(\n字段1 字段1类型 [ COMMENT 字段1注释 ] ,\n......\n字段n 字段n类型 [COMMENT 字段n注释 ]\n) ENGINE = INNODB [ COMMENT 表注释 ] ;\n```\n\n2). 查询当前数据库支持的存储引擎\n\n``` sql\nshow engines;\n```\n\n示例演示: \n\nA. 查询建表语句 --- 默认存储引擎: InnoDB\n\n``` sql\nshow create table account;\n```\n\n![image-20220707010813226](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070108263.png)\n\n我们可以看到，创建表时，即使我们没有指定存储引擎，数据库也会自动选择默认的存储引擎。\n\nB. 查询当前数据库支持的存储引擎\n\n``` sql\n show engines ;\n```\n\n![image-20220707010908844](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070109879.png)\n\nC. 创建表 my_myisam , 并指定MyISAM存储引擎\n\n``` sql\ncreate table my_myisam(\nid int,\nname varchar(10)\n) engine = MyISAM ;\n```\n\nD. 创建表 my_memory , 指定Memory存储引擎\n\n``` sql\ncreate table my_memory(\nid int,\nname varchar(10)\n) engine = Memory ;\n```\n\n## 1.3 存储引擎特点\n\n上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面 重点提到的三种存储引擎 **InnoDB、MyISAM、Memory**的特点。\n\n### 1.3.1 InnoDB \n\n#### 1). 介绍 \n\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。\n\n#### 2). 特点 \n\n- DML操作遵循ACID模型，支持事务； \n\n- 行级锁，提高并发访问性能； \n\n- 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n\n  **事务、外键，行级锁**\n\n#### 3). 文件 \n\nxxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。\n\n参数：innodb_file_per_table\n\n``` sql\nshow variables like \'innodb_file_per_table\n```\n\n![image-20220707011241280](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070112316.png)\n\n如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的 数据存放目录： C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。\n\n![image-20220707011305747](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070113777.png)\n\n可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。\n\n![image-20220707011400729](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070114794.png)\n\n#### 4). 逻辑存储结构\n\n![image-20220707011441036](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070114094.png)\n\n- 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 \n- 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 \n- 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 \n- 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 \n- 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。\n\n### 1.3.2 MyISAM \n\n#### 1). 介绍 \n\nMyISAM是MySQL早期的默认存储引擎。\n\n#### 2). 特点 \n\n- 不支持事务，不支持外键 \n\n- 支持表锁，不支持行锁 \n\n- 访问速度快\n\n#### 3). 文件 \n\nxxx.sdi：存储表结构信息 \n\nxxx.MYD: 存储数据 \n\nxxx.MYI: 存储索引\n\n![image-20220707011634576](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070116613.png)\n\n### 1.3.3 Memory \n\n#### 1). 介绍 \n\nMemory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。 \n\n#### 2). 特点 \n\n内存存放 hash索引（默认） \n\n#### 3).文件 \n\nxxx.sdi：存储表结构信息\n\n### 1.3.4 区别及特点\n\n![image-20220707011808103](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070118166.png)\n\n> 面试题: \n>\n> InnoDB引擎与MyISAM引擎的区别 ? \n>\n> ①. InnoDB引擎, 支持事务, 而MyISAM不支持。 \n>\n> ②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 \n>\n> ③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 \n>\n> 主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：\n>\n> https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html \n>\n> https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html\n\n## 1.4 存储引擎选择 \n\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 \n\n- InnoDB: 是Mysql的默认存储引擎，支持**事务、外键，行级锁**。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 \n- MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 \n- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\n\n',1,'',0,0,1,'2022-07-07 21:54:01',NULL),(111,1,197,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2a392709367b0c972a09663e2c2ca44.jpg','MySQL进阶（索引）','# MySQL进阶（索引）\n\n## 2.索引 \n\n### 2.1 索引概述 \n\n#### 2.1.1 介绍 \n\n**索引（index）是帮助MySQL高效获取数据的数据结构(有序)。**在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。\n\n![image-20220707215557913](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072155020.png)\n\n#### 2.1.2 演示 \n\n表结构及其数据如下：\n\n![image-20220707215622697](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072156746.png)\n\n假如我们要执行的SQL语句为 ： select * from user where age = 45;\n\n1). 无索引情况\n\n![image-20220707220024388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072200456.png)\n\n**在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。** \n\n2). 有索引情况\n\n如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。\n\n![image-20220707220150036](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072201094.png)\n\n此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。\n\n> 备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并 不是索引的真实结构，索引的真实结构，后面会详细介绍。\n\n#### 2.1.3 特点\n\n| 优势                                                         | 劣势                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 提高数据检索的效率，降低数据库的IO成本                       | 索引列也是要占用空间的                                       |\n| 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。 |\n\n### 2.2 索引结构 \n\n#### 2.2.1 概述 \n\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\n\n| 索引结构             | 描述                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| B+Tree索引           | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |\n| Hash索引             | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询 |\n| R-tree(空间索 引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少 |\n| Full-text(全文 索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES |\n\n上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持 情况。\n\n| 索引        | InnoDB          | MyISAM | Memory |\n| ----------- | --------------- | ------ | ------ |\n| B+tree索引  | 支持            | 支持   | 支持   |\n| Hash 索引   | 不支持          | 不支持 | 支持   |\n| R-tree 索引 | 不支持          | 支持   | 不支持 |\n| Full-text   | 5.6版本之后支持 | 支持   | 不支持 |\n\n> 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。\n\n#### 2.2.2 二叉树 \n\n假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：\n\n![image-20220707221524346](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215390.png)\n\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\n\n![image-20220707221541844](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215881.png)\n\n所以，如果选择二叉树作为索引结构，会存在以下缺点\n\n- 顺序插入时，会形成一个链表，查询性能大大降低。\n- 大数据量情况下，层级较深，检索速度慢。\n\n此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:\n\n![image-20220707221654789](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072216826.png)\n\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\n\n- 大数据量情况下，层级较深，检索速度慢。\n\n所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是 B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。\n\n#### 2.2.3 B-Tree\n\nB-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 \n\n以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：\n\n![image-20220707222217777](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072222823.png)\n\n> 知识小贴士: 树的度数指的是一个节点的子节点个数。\n\n特点： \n\n- 5阶的B树，每一个节点最多存储4个key，对应5个指针。 \n- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 \n- 在B树中，非叶子节点和叶子节点都会存放数据。\n\n#### 2.2.4 B+Tree \n\nB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：\n\n![image-20220707222506931](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072225965.png)\n\n我们可以看到，两部分： \n\n- 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 \n- 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\n\n最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： \n\n- 所有的数据都会出现在叶子节点。 \n- 叶子节点形成一个单向链表。 \n- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\n\n上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的 B+Tree。 \n\n**MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。**\n\n#### 2.2.5 Hash \n\nMySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。 \n\n1). 结构 \n\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。\n\n![image-20220707223044525](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072230585.png)\n\n如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。\n\n2). 特点 \n\nA. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...） \n\nB. 无法利用索引完成排序操作 \n\nC. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引\n\n3). 存储引擎支持 \n\n在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。\n\n> 面试题：为什么InnoDB选择B+Tree作为索引结构\n>\n> A. 相对于二叉树，层级更少，搜索效率高； \n>\n> B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； \n>\n> C. 相对Hash索引，B+tree支持范围匹配及排序操作；\n\n### 2.3 索引分类 \n\n#### 2.3.1 索引分类 \n\n在MySQL数据库，将索引的具体类型主要分为以下几类：**主键索引、唯一索引、常规索引、全文索引**。\n\n| 分类      | 含义                                                  | 特点                      | 关键字   |\n| --------- | ----------------------------------------------------- | ------------------------- | -------- |\n| 主键 索引 | 针对于表中主键创建的索引                              | 默认自动创建, 只能 有一个 | PRIMARY  |\n| 唯一 索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                | UNIQUE   |\n| 常规 索引 | 快速定位特定数据                                      | 可以有多个                |          |\n| 全文 索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                | FULLTEXT |\n\n#### 2.3.2 聚集索引&二级索引 \n\n而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n| 分类                      | 含义                                                        | 特点                 |\n| ------------------------- | ----------------------------------------------------------- | -------------------- |\n| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 | 必须有,而且只 有一个 |\n| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 | 可以存在多个         |\n\n聚集索引选取规则: \n\n- 如果存在主键，主键索引就是聚集索引。\n- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 \n- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。\n\n聚集索引和二级索引的具体结构如下：\n\n![image-20220707224328188](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072243281.png)\n\n- 聚集索引的叶子节点下挂的是这一行的数据 。 \n- 二级索引的叶子节点下挂的是该字段值对应的主键值。\n\n接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\n\n![image-20220707224404166](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072244220.png)\n\n具体过程如下:\n\n①. 由于是根据name字段进行查询，所以先根据name=\'Arm\'到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。\n\n②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。 \n\n③. 最终拿到这一行的数据，直接返回即可\n\n> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。\n\n### 2.4 索引语法 \n\n1). 创建索引\n\n``` sql\nCREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (\nindex_col_name,... ) ;\n```\n\n2). 查看索引\n\n``` sql\nshow index FROM table_name ;\n```\n\n3). 删除索引\n\n``` sql\nDROP INDEX index_name ON table_name ;\n```\n\n4). 创建联合索引\n\n``` sql\nCREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);\n```\n\n### 2.5 SQL性能分析 \n\n#### 2.5.1 SQL执行频率\n\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\n\n``` sql\n-- session 是查看当前会话 ;\n-- global 是查询全局数据 ;\nSHOW GLOBAL STATUS LIKE \'Com_______\';\n-- 7个下划线\n```\n\n> Com_delete: 删除次数\n>\n> Com_insert: 插入次数 \n>\n> Com_select: 查询次数 \n>\n> Com_update: 更新次数\n>\n> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。\n\n那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假 如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询 日志。 \n\n接下来，我们就来介绍一下MySQL中的慢查询日志。\n\n#### 2.5.2 慢查询日志 \n\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。\n\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\n\n``` sql\nshow variables like \'slow_query_log\'\n```\n\n![image-20220707225306618](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072253672.png)\n\n如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\n\n``` shell\n# 开启MySQL慢日志查询开关\nslow_query_log=1\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\nlong_query_time=2\n```\n\n配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。\n\n``` sh\nsystemctl restart mysqld\n```\n\n然后，再次查看开关情况，慢查询日志就已经打开了。\n\n![image-20220707225447531](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072254588.png)\n\n#### 2.5.3 profile详情\n\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：\n\n``` sql\nSELECT @@have_profiling ;\n```\n\n![image-20220707230356949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072303036.png)\n\n可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：\n\n``` sql\nSET profiling = 1;\n```\n\n开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 我们直接执行如下的SQL语句：\n\n``` sql\nselect * from tb_user;\nselect * from tb_user where id = 1;\nselect * from tb_user where name = \'白起\';\nselect count(*) from tb_sku;\n```\n\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\n\n``` sql\n-- 查看每一条SQL的耗时基本情况\nshow profiles;\n-- 查看指定query_id的SQL语句各个阶段的耗时情况\nshow profile for query query_id;\n-- 查看指定query_id的SQL语句CPU的使用情况\nshow profile cpu for query query_id;\n```\n\n查看每一条SQL的耗时情况:\n\n``` sql\nshow profiles\n```\n\n![image-20220707230532714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072305799.png)\n\n查看指定SQL各个阶段的耗时情况 :\n\n![image-20220707230606309](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072306430.png)\n\n#### 2.5.4 explain（执行计划）\n\nEXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。\n\n语法:\n\n``` sql\n-- 直接在select语句之前加上关键字 explain / desc\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;\n```\n\n![image-20220707230717108](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072307176.png)\n\nExplain 执行计划中各个字段的含义:\n\n| 字段         | 含义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |\n| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 |\n| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 |\n| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |\n| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |\n| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 |\n| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |\n| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |\n\n### 2.6 索引使用\n\n#### 2.6.1 最左前缀法则\n\n如果索引了多列（联合索引），要遵守最左前缀法则。\n\n**最左前缀法则指的是查询从联合索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。**\n\n> 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。\n\n#### 2.6.2 范围查询 \n\n联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。\n\n``` sql\nexplain select * from tb_user where profession = \'软件工程\' and age > 30 and status\n= \'0\';\n```\n\n![image-20220707232234948](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072322008.png)\n\n当范围查询使用> 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。\n\n``` sql\nexplain select * from tb_user where profession = \'软件工程\' and age >= 30 and\nstatus = \'0\';\n```\n\n![image-20220707232306611](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072323670.png)\n\n当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。\n\n所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 < 。\n\n#### 2.6.3 索引失效情况 \n\n##### 2.6.3.1 索引列运算 \n\n不要在索引列上进行运算操作， 索引将失效。\n\n- 比如各种运算符运算（substring）\n\n##### 2.6.3.2 字符串不加引号 \n\n字符串类型字段使用时，不加引号，索引将失效。\n\n**如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。**\n\n##### 2.6.3.3 模糊查询 \n\n**如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。**\n\n##### 2.6.3.4 or连接条件 \n\n**用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。**（or前后必须都有索引）\n\n##### 2.6.3.5 数据分布影响 \n\n如果MySQL评估使用索引比全表更慢，则不使用索引。\n\n就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。\n\n#### 2.6.5 SQL提示\n\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。\n\n1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。\n\n``` sql\nexplain select * from tb_user use index(idx_user_pro) where profession = \'软件工程\';\n```\n\n2). ignore index ： 忽略指定的索引。\n\n``` sql\nexplain select * from tb_user ignore index(idx_user_pro) where profession = \'软件工程\';\n```\n\n3). force index ： 强制使用索引。\n\n``` sql\nexplain select * from tb_user force index(idx_user_pro) where profession = \'软件工程\';\n```\n\n#### 2.6.6 覆盖索引 \n\n尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。\n\n#### 2.6.7 前缀索引 \n\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。\n\n1). 语法\n\n``` sql\ncreate index idx_xxxx on table_name(column(n)) ;\n```\n\n2). 前缀长度 \n\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\n\n``` sql\nselect count(distinct email) / count(*) from tb_user ;\nselect count(distinct substring(email,1,5)) / count(*) from tb_user ;\n```\n\n3). 前缀索引的查询流程\n\n![image-20220707233417388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072334452.png)\n\n#### 2.6.8 单列索引与联合索引 \n\n单列索引：即一个索引只包含单个列。 \n\n联合索引：即一个索引包含了多个列\n\n> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。\n\n### 2.7 索引设计原则 \n\n1). 针对于数据量较大，且查询比较频繁的表建立索引。 \n\n2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。 \n\n3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 \n\n4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 \n\n5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 \n\n6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。 \n\n7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。',1,'',0,0,1,'2022-07-07 23:36:45','2022-09-09 20:06:02'),(112,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg','springboot+md5实现数据库密码加密','# springboot+md5实现数据库密码加密\n\n## 引入依赖\n\n```xml\n<!-- MD5加密依赖 -->\n<dependency>\n    <groupId>commons-codec</groupId>\n    <artifactId>commons-codec</artifactId>\n</dependency>\n```\n\n## 工具类\n\n```java\npackage com.icatw.wallpaperapi.utils;\n\nimport org.apache.commons.codec.digest.DigestUtils;\n\n/**\n * md5加密工具\n *\n * @author 76218\n * @date 2022/10/05\n */\npublic class MD5Utils {\n    public static String md5(String src) {\n        return DigestUtils.md5Hex(src);\n    }\n\n    private static final String salt = \"1a2b3c4d\";\n\n    public static String inputPassToFormPass(String inputPass) {\n        String str = \"\"+salt.charAt(0)+salt.charAt(2) + inputPass +salt.charAt(5) + salt.charAt(4);\n        System.out.println(str);\n        return md5(str);\n    }\n\n    public static String formPassToDBPass(String formPass, String salt) {\n        String str = \"\"+salt.charAt(0)+salt.charAt(2) + formPass +salt.charAt(5) + salt.charAt(4);\n        return md5(str);\n    }\n\n    public static String inputPassToDbPass(String inputPass, String saltDB) {\n        String formPass = inputPassToFormPass(inputPass);\n        String dbPass = formPassToDBPass(formPass, saltDB);\n        return dbPass;\n    }\n    //编写主类进行测试\n     public static void main(String args[]) {\n        String s = \"123456\";\n        System.out.println(\"原始：\" + s);\n\n        System.out.println(\"加密后：\"+MD5Utils.inputPassToFormPass(s));\n\n    }\n}\n```\n\n## 使用\n\n在登陆和注册接口将前端传来的密码进行加密再与数据库的加密密码进行比对\n\n```java\npublic Object login(User user) {\n    try {\n        String userName = user.getUserName();\n        User one = this.getOne(new QueryWrapper<User>().eq(\"user_name\" , userName));\n        if (one != null) {\n            String password = user.getPassword();\n            //输入的密码加密后与数据库密码进行比较\n            String formPass = MD5Utils.inputPassToFormPass(password);\n            String onePassword = one.getPassword();\n            //如果密码相同，生成token\n            if (onePassword.equals(formPass)) {\n                //根据用户id生成token，将userId存入token荷载中\n                String token = JWTUtils.createToken(one.getUserId());\n                return R.ok(token);\n            }\n        }\n        //空，用户名不存在\n        return R.fail(ResultStatusEnum.NOT_USER.getCode(),ResultStatusEnum.NOT_USER.getMessage());\n    } catch (Exception e) {\n        //抛出异常，系统错误\n        e.printStackTrace();\n        throw new CustomException(ResultStatusEnum.SYSTEM_EXCEPTION);\n    }\n}\n```',1,'',0,0,1,'2022-10-05 20:41:23',NULL),(113,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dde3c71e642f112140ce6ec3797bbf27.jpg',' RuoYi-Vue二开指南','# RuoYi-Vue二开指南\n\n> RuoYi-Vue是一款基于SpringBoot+Vue前后端分离的Java快速开发框架（**gitee上拥有21.9k的star**）\n\n先来看看官方简介：\n\nGitee地址：https://gitee.com/y_project/RuoYi-Vue\n\n## 平台简介\n\n若依是一套全部开源的快速开发平台，毫无保留给个人及企业免费使用。\n\n- 前端采用Vue、Element UI。\n- 后端采用Spring Boot、Spring Security、Redis & Jwt。\n- 权限认证使用Jwt，支持多终端认证系统。\n- 支持加载动态权限菜单，多方式轻松权限控制。\n- 高效率开发，使用代码生成器可以一键生成前后端代码。\n- 提供了技术栈（[Vue3](https://gitee.com/link?target=https%3A%2F%2Fv3.cn.vuejs.org) [Element Plus](https://gitee.com/link?target=https%3A%2F%2Felement-plus.org%2Fzh-CN) [Vite](https://gitee.com/link?target=https%3A%2F%2Fcn.vitejs.dev)）版本[RuoYi-Vue3](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue3)，保持同步更新。\n- 提供了单应用版本[RuoYi-Vue-fast](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue-fast)，Oracle版本[RuoYi-Vue-Oracle](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue-Oracle)，保持同步更新。\n- 不分离版本，请移步[RuoYi](https://gitee.com/y_project/RuoYi)，微服务版本，请移步[RuoYi-Cloud](https://gitee.com/y_project/RuoYi-Cloud)\n- 特别鸣谢：[element](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement)，[vue-element-admin](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin)，[eladmin-web](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Felunez%2Feladmin-web)。\n- 阿里云折扣场：[点我进入](https://gitee.com/link?target=http%3A%2F%2Faly.ruoyi.vip)，腾讯云秒杀场：[点我进入](https://gitee.com/link?target=http%3A%2F%2Ftxy.ruoyi.vip) \n- 阿里云优惠券：[点我领取](https://gitee.com/link?target=https%3A%2F%2Fwww.aliyun.com%2Fminisite%2Fgoods%3FuserCode%3Dbrki8iof%26share_source%3Dcopy_link)，腾讯云优惠券：[点我领取](https://gitee.com/link?target=https%3A%2F%2Fcloud.tencent.com%2Fredirect.php%3Fredirect%3D1025%26cps_key%3D198c8df2ed259157187173bc7f4f32fd%26from%3Dconsole) \n\n## 内置功能\n\n1. 用户管理：用户是系统操作者，该功能主要完成系统用户配置。\n2. 部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。\n3. 岗位管理：配置系统用户所属担任职务。\n4. 菜单管理：配置系统菜单，操作权限，按钮权限标识等。\n5. 角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。\n6. 字典管理：对系统中经常使用的一些较为固定的数据进行维护。\n7. 参数管理：对系统动态配置常用参数。\n8. 通知公告：系统通知公告信息发布维护。\n9. 操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。\n10. 登录日志：系统登录日志记录查询包含登录异常。\n11. 在线用户：当前系统中活跃用户状态监控。\n12. 定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。\n13. 代码生成：前后端代码的生成（java、html、xml、sql）支持CRUD下载 。\n14. 系统接口：根据业务代码自动生成相关的api接口文档。\n15. 服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。\n16. 缓存监控：对系统的缓存信息查询，命令统计等。\n17. 在线构建器：拖动表单元素生成相应的HTML代码。\n18. 连接池监视：监视当前系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。\n\n## 个人修改版\n\n>  首先可以去http://fastbuild.run/这个网站修改若依的包名\n\n个人修改后的若依后台管理系统（去除了岗位和部门，使用knife4j作为接口文档，使用mybatisplus作为orm框架，改用oss上传文件）\n\nhttps://gitee.com/icatw/RuoYi-Vue-Icatw\n\n- 剔除了岗位和部门管理\n\n- 将接口文档工具swagger替换为了更美观的knife4j\n\n- 使用Mybatis-Plus作为数据库操作框架\n\n- 修改首页和登录页，后台登陆使用腾讯云人机验证\n\n- 使用lombok简化实体类get/set方法\n\n  ![image-20221004113727410](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041137098.png)\n\n![image-20221004113747815](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041137256.png)\n\n## 新增个人模块\n\n1. 新建maven模块\n\n   <img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041150786.png\" alt=\"image-20221004115026729\" style=\"zoom:50%;\" />\n\n2. 导入新模块坐标\n\n   ![image-20221004115131929](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041151026.png)\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041151800.png\" alt=\"image-20221004115152700\"  />\n\n<img src=\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041153488.png\" alt=\"image-20221004115343450\" style=\"zoom: 67%;\" />\n\n3. 启动前端\n\n   - npm install\n   - npm run dev\n\n   ![image-20221004115607081](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041156201.png)\n\n4. 创建数据库\n\n![image-20221004115627556](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041156603.png)\n\n5. 新建菜单\n\n   ![image-20221004122053981](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041220055.png)\n\n6. 代码生成\n\n![image-20221004115709902](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041157990.png)\n\n![image-20221004120501142](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041205236.png)\n\n![image-20221004122408710](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041224780.png)\n\n![image-20221004122838731](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041228776.png)\n\n7. 将代码复制粘贴到对应的目录下，并执行SQL\n\n8. 重启项目前后端',1,'',0,0,1,'2022-10-05 21:41:39',NULL),(114,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2d9ff49944343908a18340d6a43d9986.jpg','springboot使用@ConfigurationProperties读取配置文件','# springboot使用@ConfigurationProperties读取配置文件\n\n1. 配置文件\n\n   ![image-20221010134115656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210101341929.png)\n\n2. 注解使用\n\n   首先定义一个属性实体类\n\n``` java\n@ConfigurationProperties(prefix = \"aliyun.vod.file\")\n@Component\n@Data\npublic class AliConstant {\n    private String keyId;\n    private String keySecret;\n}\n```\n\n实体属性必须与配置文件中的属性对应\n\n***必须使用@Component将bean注入到spring容器中**\n\n3. 最终使用\n\n   ```Java\n   @Autowired\n   AliConstant aliConstant;\n   ```\n\n   注入使用即可\n\n',1,'',0,0,1,'2022-10-10 13:45:59',NULL),(115,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/abd253be0e10c331cec2245f8ff76ca0.jpg','将本地jar包安装到本地maven仓库','# 将本地jar包安装到本地maven仓库\n\n首先确保本地电脑有maven环境\n\n> 可使用mvn查看是否配置环境变量\n\n1. 首先下载好jar包\n\n2. 在存放jar包的文件夹cmd\n\n3. 使用mvn install命令\n\n   ``` java\n   mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar\n   ```\n\n   \n\n',1,'',0,0,1,'2022-10-10 14:16:13',NULL),(116,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c78e18bf6f8c87a7f7edbb28ae873f7c.jpg','Java8函数式编程','# 函数式编程-Stream流\n\n## 1. 概述\n\n### 1.1 为什么学？\n\n- 能够看懂公司里的代码\n- 大数量下处理集合效率高\n- 代码可读性高\n- 消灭嵌套地狱\n\n~~~~java\n//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重\nList<Book> bookList = new ArrayList<>();\nSet<Book> uniqueBookValues = new HashSet<>();\nSet<Author> uniqueAuthorValues = new HashSet<>();\nfor (Author author : authors) {\n    if (uniqueAuthorValues.add(author)) {\n        if (author.getAge() < 18) {\n            List<Book> books = author.getBooks();\n            for (Book book : books) {\n                if (book.getScore() > 70) {\n                    if (uniqueBookValues.add(book)) {\n                        bookList.add(book);\n                    }\n                }\n            }\n        }\n    }\n}\nSystem.out.println(bookList);\n~~~~\n\n~~~~java\nList<Book> collect = authors.stream()\n    .distinct()\n    .filter(author -> author.getAge() < 18)\n    .map(author -> author.getBooks())\n    .flatMap(Collection::stream)\n    .filter(book -> book.getScore() > 70)\n    .distinct()\n    .collect(Collectors.toList());\nSystem.out.println(collect);\n~~~~\n\n\n\n### 1.2 函数式编程思想\n\n#### 1.2.1 概念\n\n​	面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。\n\n#### 1.2.2 优点\n\n* 代码简洁，开发快速\n* 接近自然语言，易于理解\n* 易于\"并发编程\"\n\n\n\n## 2. Lambda表达式\n\n### 2.1 概述\n\n​	Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。\n\n### 2.2 核心原则\n\n> 可推导可省略\n\n### 2. 3 基本格式\n\n~~~~java\n(参数列表)->{代码}\n~~~~\n\n#### 例一\n\n我们在创建线程并启动时可以使用匿名内部类的写法：\n\n~~~~java\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"你知道吗 我比你想象的 更想在你身边\");\n    }\n}).start();\n~~~~\n\n可以使用Lambda的格式对其进行修改。修改后如下：\n\n~~~~java\nnew Thread(()->{\n    System.out.println(\"你知道吗 我比你想象的 更想在你身边\");\n}).start();\n~~~~\n\n\n\n#### 例二:\n\n现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。\n\n~~~~java\n    public static int calculateNum(IntBinaryOperator operator){\n        int a = 10;\n        int b = 20;\n        return operator.applyAsInt(a, b);\n    }\n\n    public static void main(String[] args) {\n        int i = calculateNum(new IntBinaryOperator() {\n            @Override\n            public int applyAsInt(int left, int right) {\n                return left + right;\n            }\n        });\n        System.out.println(i);\n    }\n~~~~\n\nLambda写法：\n\n~~~~java\n    public static void main(String[] args) {\n        int i = calculateNum((int left, int right)->{\n            return left + right;\n        });\n        System.out.println(i);\n    }\n~~~~\n\n\n\n#### 例三：\n\n现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。\n\n~~~~java\n    public static void printNum(IntPredicate predicate){\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\n        for (int i : arr) {\n            if(predicate.test(i)){\n                System.out.println(i);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        printNum(new IntPredicate() {\n            @Override\n            public boolean test(int value) {\n                return value%2==0;\n            }\n        });\n    }\n~~~~\n\nLambda写法：\n\n~~~~java\n    public static void main(String[] args) {\n        printNum((int value)-> {\n            return value%2==0;\n        });\n    }\n    public static void printNum(IntPredicate predicate){\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\n        for (int i : arr) {\n            if(predicate.test(i)){\n                System.out.println(i);\n            }\n        }\n    }\n~~~~\n\n\n\n#### 例四：\n\n现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。\n\n~~~~java\n    public static <R> R typeConver(Function<String,R> function){\n        String str = \"1235\";\n        R result = function.apply(str);\n        return result;\n    }\n    public static void main(String[] args) {\n        Integer result = typeConver(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) {\n                return Integer.valueOf(s);\n            }\n        });\n        System.out.println(result);\n    }\n~~~~\n\nLambda写法：\n\n~~~~java\n        Integer result = typeConver((String s)->{\n            return Integer.valueOf(s);\n        });\n        System.out.println(result);\n\n~~~~\n\n\n\n#### 例五：\n\n现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。\n\n~~~~java\n    public static void foreachArr(IntConsumer consumer){\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\n        for (int i : arr) {\n            consumer.accept(i);\n        }\n    }\n    public static void main(String[] args) {\n        foreachArr(new IntConsumer() {\n            @Override\n            public void accept(int value) {\n                System.out.println(value);\n            }\n        });\n    }\n~~~~\n\nLambda写法：\n\n~~~~java\n    public static void main(String[] args) {\n        foreachArr((int value)->{\n            System.out.println(value);\n        });\n    }\n~~~~\n\n\n\n### 2.4 省略规则\n\n* 参数类型可以省略\n* 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略\n* 方法只有一个参数时小括号可以省略\n* 以上这些规则都记不住也可以省略不记\n\n\n\n\n\n## 3. Stream流\n\n### 3.1 概述\n\n​	Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。\n\n\n\n### 3.2 案例数据准备\n\n~~~~xml\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.16</version>\n        </dependency>\n    </dependencies>\n~~~~\n\n\n\n~~~~java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@EqualsAndHashCode//用于后期的去重使用\npublic class Author {\n    //id\n    private Long id;\n    //姓名\n    private String name;\n    //年龄\n    private Integer age;\n    //简介\n    private String intro;\n    //作品\n    private List<Book> books;\n}\n~~~~\n\n~~~~java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode//用于后期的去重使用\npublic class Book {\n    //id\n    private Long id;\n    //书名\n    private String name;\n\n    //分类\n    private String category;\n\n    //评分\n    private Integer score;\n\n    //简介\n    private String intro;\n\n}\n~~~~\n\n~~~~java\n    private static List<Author> getAuthors() {\n        //数据初始化\n        Author author = new Author(1L,\"蒙多\",33,\"一个从菜刀中明悟哲理的祖安人\",null);\n        Author author2 = new Author(2L,\"亚拉索\",15,\"狂风也追逐不上他的思考速度\",null);\n        Author author3 = new Author(3L,\"易\",14,\"是这个世界在限制他的思维\",null);\n        Author author4 = new Author(3L,\"易\",14,\"是这个世界在限制他的思维\",null);\n\n        //书籍列表\n        List<Book> books1 = new ArrayList<>();\n        List<Book> books2 = new ArrayList<>();\n        List<Book> books3 = new ArrayList<>();\n\n        books1.add(new Book(1L,\"刀的两侧是光明与黑暗\",\"哲学,爱情\",88,\"用一把刀划分了爱恨\"));\n        books1.add(new Book(2L,\"一个人不能死在同一把刀下\",\"个人成长,爱情\",99,\"讲述如何从失败中明悟真理\"));\n\n        books2.add(new Book(3L,\"那风吹不到的地方\",\"哲学\",85,\"带你用思维去领略世界的尽头\"));\n        books2.add(new Book(3L,\"那风吹不到的地方\",\"哲学\",85,\"带你用思维去领略世界的尽头\"));\n        books2.add(new Book(4L,\"吹或不吹\",\"爱情,个人传记\",56,\"一个哲学家的恋爱观注定很难把他所在的时代理解\"));\n\n        books3.add(new Book(5L,\"你的剑就是我的剑\",\"爱情\",56,\"无法想象一个武者能对他的伴侣这么的宽容\"));\n        books3.add(new Book(6L,\"风与剑\",\"个人传记\",100,\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\"));\n        books3.add(new Book(6L,\"风与剑\",\"个人传记\",100,\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\"));\n\n        author.setBooks(books1);\n        author2.setBooks(books2);\n        author3.setBooks(books3);\n        author4.setBooks(books3);\n\n        List<Author> authorList = new ArrayList<>(Arrays.asList(author,author2,author3,author4));\n        return authorList;\n    }\n~~~~\n\n\n\n### 3.3 快速入门\n\n#### 3.3.1 需求\n\n​	我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。\n\n#### 3.3.2 实现\n\n~~~~java\n        //打印所有年龄小于18的作家的名字，并且要注意去重\n        List<Author> authors = getAuthors();\n        authors.\n                stream()//把集合转换成流\n                .distinct()//先去除重复的作家\n                .filter(author -> author.getAge()<18)//筛选年龄小于18的\n                .forEach(author -> System.out.println(author.getName()));//遍历打印名字\n~~~~\n\n\n\n### 3.4 常用操作\n\n#### 3.4.1 创建流\n\n单列集合： `集合对象.stream()`\n\n~~~~java\n        List<Author> authors = getAuthors();\n		Stream<Author> stream = authors.stream();\n~~~~\n\n数组：`Arrays.stream(数组) `或者使用`Stream.of`来创建\n\n~~~~JAVA\n        Integer[] arr = {1,2,3,4,5};\n        Stream<Integer> stream = Arrays.stream(arr);\n        Stream<Integer> stream2 = Stream.of(arr);\n~~~~\n\n双列集合：转换成单列集合后再创建\n\n~~~~java\n        Map<String,Integer> map = new HashMap<>();\n        map.put(\"蜡笔小新\",19);\n        map.put(\"黑子\",17);\n        map.put(\"日向翔阳\",16);\n\n        Stream<Map.Entry<String, Integer>> stream = map.entrySet().stream();\n~~~~\n\n\n\n#### 3.4.2 中间操作\n\n##### filter\n\n​	可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。\n\n\n\n例如：\n\n​	打印所有姓名长度大于1的作家的姓名\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .filter(author -> author.getName().length()>1)\n                .forEach(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n##### map\n\n​	可以把对流中的元素进行计算或转换。\n\n例如：\n\n​	打印所有作家的姓名\n\n~~~~java\n        List<Author> authors = getAuthors();\n\n        authors\n                .stream()\n                .map(author -> author.getName())\n                .forEach(name->System.out.println(name));\n~~~~\n\n~~~~java\n//        打印所有作家的姓名\n        List<Author> authors = getAuthors();\n\n//        authors.stream()\n//                .map(author -> author.getName())\n//                .forEach(s -> System.out.println(s));\n\n        authors.stream()\n                .map(author -> author.getAge())\n                .map(age->age+10)\n                .forEach(age-> System.out.println(age));\n~~~~\n\n\n\n\n\n##### distinct\n\n​	可以去除流中的重复元素。\n\n\n\n例如：\n\n​	打印所有作家的姓名，并且要求其中不能有重复元素。\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .distinct()\n                .forEach(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n**注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。**\n\n\n\n##### sorted\n\n​	可以对流中的元素进行排序。\n\n例如：\n\n​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\n\n~~~~java\n        List<Author> authors = getAuthors();\n//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\n        authors.stream()\n                .distinct()\n                .sorted()\n                .forEach(author -> System.out.println(author.getAge()));\n~~~~\n\n~~~~java\n        List<Author> authors = getAuthors();\n//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\n        authors.stream()\n                .distinct()\n                .sorted((o1, o2) -> o2.getAge()-o1.getAge())\n                .forEach(author -> System.out.println(author.getAge()));\n~~~~\n\n\n\n**注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。**\n\n​		\n\n\n\n##### limit	\n\n​	可以设置流的最大长度，超出的部分将被抛弃。\n\n\n\n例如：\n\n​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .distinct()\n                .sorted()\n                .limit(2)\n                .forEach(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n##### skip\n\n​	跳过流中的前n个元素，返回剩下的元素\n\n\n\n例如：\n\n​	打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。\n\n~~~~java\n//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .distinct()\n                .sorted()\n                .skip(1)\n                .forEach(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n\n\n\n\n##### flatMap\n\n​	map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。\n\n\n\n例一：\n\n​	打印所有书籍的名字。要求对重复的元素进行去重。\n\n~~~~java\n//        打印所有书籍的名字。要求对重复的元素进行去重。\n        List<Author> authors = getAuthors();\n\n        authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .distinct()\n                .forEach(book -> System.out.println(book.getName()));\n~~~~\n\n\n\n例二：\n\n​	打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情\n\n~~~~java\n//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .distinct()\n                .flatMap(book -> Arrays.stream(book.getCategory().split(\",\")))\n                .distinct()\n                .forEach(category-> System.out.println(category));\n~~~~\n\n\n\n\n\n#### 3.4.3 终结操作\n\n##### forEach\n\n​	对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。\n\n\n\n例子：\n\n​	输出所有作家的名字\n\n~~~~java\n//        输出所有作家的名字\n        List<Author> authors = getAuthors();\n\n        authors.stream()\n                .map(author -> author.getName())\n                .distinct()\n                .forEach(name-> System.out.println(name));\n\n~~~~\n\n\n\n\n\n##### count\n\n​	可以用来获取当前流中元素的个数。\n\n例子：\n\n​	打印这些作家的所出书籍的数目，注意删除重复元素。\n\n~~~~java\n//        打印这些作家的所出书籍的数目，注意删除重复元素。\n        List<Author> authors = getAuthors();\n\n        long count = authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .distinct()\n                .count();\n        System.out.println(count);\n~~~~\n\n\n\n\n\n##### max&min\n\n​	可以用来或者流中的最值。\n\n例子：\n\n​	分别获取这些作家的所出书籍的最高分和最低分并打印。\n\n~~~~java\n//        分别获取这些作家的所出书籍的最高分和最低分并打印。\n        //Stream<Author>  -> Stream<Book> ->Stream<Integer>  ->求值\n\n        List<Author> authors = getAuthors();\n        Optional<Integer> max = authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .map(book -> book.getScore())\n                .max((score1, score2) -> score1 - score2);\n\n        Optional<Integer> min = authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .map(book -> book.getScore())\n                .min((score1, score2) -> score1 - score2);\n        System.out.println(max.get());\n        System.out.println(min.get());\n~~~~\n\n\n\n\n\n\n\n##### collect\n\n​	把当前流转换成一个集合。\n\n\n\n例子：\n\n​	获取一个存放所有作者名字的List集合。\n\n~~~~java\n//        获取一个存放所有作者名字的List集合。\n        List<Author> authors = getAuthors();\n        List<String> nameList = authors.stream()\n                .map(author -> author.getName())\n                .collect(Collectors.toList());\n        System.out.println(nameList);\n~~~~\n\n​	获取一个所有书名的Set集合。\n\n~~~~java\n//        获取一个所有书名的Set集合。\n        List<Author> authors = getAuthors();\n        Set<Book> books = authors.stream()\n                .flatMap(author -> author.getBooks().stream())\n                .collect(Collectors.toSet());\n\n        System.out.println(books);\n~~~~\n\n​	获取一个Map集合，map的key为作者名，value为List<Book>\n\n~~~~java\n//        获取一个Map集合，map的key为作者名，value为List<Book>\n        List<Author> authors = getAuthors();\n\n        Map<String, List<Book>> map = authors.stream()\n                .distinct()\n                .collect(Collectors.toMap(author -> author.getName(), author -> author.getBooks()));\n\n        System.out.println(map);\n~~~~\n\n\n\n##### 查找与匹配\n\n###### anyMatch\n\n​	可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。\n\n\n\n例子：\n\n​	判断是否有年龄在29以上的作家\n\n~~~~java\n//        判断是否有年龄在29以上的作家\n        List<Author> authors = getAuthors();\n        boolean flag = authors.stream()\n                .anyMatch(author -> author.getAge() > 29);\n        System.out.println(flag);\n~~~~\n\n\n\n\n\n###### allMatch\n\n​	可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。\n\n例子：\n\n​	判断是否所有的作家都是成年人\n\n~~~~java\n//        判断是否所有的作家都是成年人\n        List<Author> authors = getAuthors();\n        boolean flag = authors.stream()\n                .allMatch(author -> author.getAge() >= 18);\n        System.out.println(flag);\n~~~~\n\n\n\n###### noneMatch\n\n​	可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false\n\n例子：\n\n​	判断作家是否都没有超过100岁的。\n\n~~~~java\n//        判断作家是否都没有超过100岁的。\n        List<Author> authors = getAuthors();\n\n        boolean b = authors.stream()\n                .noneMatch(author -> author.getAge() > 100);\n\n        System.out.println(b);\n~~~~\n\n\n\n\n\n###### findAny\n\n​	获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。\n\n\n\n例子：\n\n​	获取任意一个年龄大于18的作家，如果存在就输出他的名字\n\n~~~~java\n//        获取任意一个年龄大于18的作家，如果存在就输出他的名字\n        List<Author> authors = getAuthors();\n        Optional<Author> optionalAuthor = authors.stream()\n                .filter(author -> author.getAge()>18)\n                .findAny();\n\n        optionalAuthor.ifPresent(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n###### findFirst\n\n​	获取流中的第一个元素。\n\n\n\n例子：\n\n​	获取一个年龄最小的作家，并输出他的姓名。\n\n~~~~java\n//        获取一个年龄最小的作家，并输出他的姓名。\n        List<Author> authors = getAuthors();\n        Optional<Author> first = authors.stream()\n                .sorted((o1, o2) -> o1.getAge() - o2.getAge())\n                .findFirst();\n\n        first.ifPresent(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n##### reduce归并\n\n​	对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）\n\n​	reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。\n\n​	reduce两个参数的重载形式内部的计算方式如下：\n\n~~~~java\nT result = identity;\nfor (T element : this stream)\n	result = accumulator.apply(result, element)\nreturn result;\n~~~~\n\n​	其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。\n\n\n\n例子：\n\n​	使用reduce求所有作者年龄的和\n\n~~~~java\n//        使用reduce求所有作者年龄的和\n        List<Author> authors = getAuthors();\n        Integer sum = authors.stream()\n                .distinct()\n                .map(author -> author.getAge())\n                .reduce(0, (result, element) -> result + element);\n        System.out.println(sum);\n~~~~\n\n​	使用reduce求所有作者中年龄的最大值\n\n~~~~java\n//        使用reduce求所有作者中年龄的最大值\n        List<Author> authors = getAuthors();\n        Integer max = authors.stream()\n                .map(author -> author.getAge())\n                .reduce(Integer.MIN_VALUE, (result, element) -> result < element ? element : result);\n\n        System.out.println(max);\n~~~~\n\n​	使用reduce求所有作者中年龄的最小值\n\n~~~~java\n//        使用reduce求所有作者中年龄的最小值\n        List<Author> authors = getAuthors();\n        Integer min = authors.stream()\n                .map(author -> author.getAge())\n                .reduce(Integer.MAX_VALUE, (result, element) -> result > element ? element : result);\n        System.out.println(min);\n~~~~\n\n\n\n​	reduce一个参数的重载形式内部的计算\n\n~~~~java\n 	 boolean foundAny = false;\n     T result = null;\n     for (T element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.apply(result, element);\n     }\n     return foundAny ? Optional.of(result) : Optional.empty();\n~~~~\n\n​	如果用一个参数的重载方法去求最小值代码如下：\n\n~~~~java\n        //        使用reduce求所有作者中年龄的最小值\n        List<Author> authors = getAuthors();\n        Optional<Integer> minOptional = authors.stream()\n                .map(author -> author.getAge())\n                .reduce((result, element) -> result > element ? element : result);\n        minOptional.ifPresent(age-> System.out.println(age));\n~~~~\n\n\n\n\n\n\n\n### 3.5 注意事项\n\n- 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）\n- 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）\n- 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）\n\n\n\n\n\n## 4. Optional\n\n### 4.1 概述\n\n​	我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。\n\n​	例如：\n\n~~~~java\n        Author author = getAuthor();\n        if(author!=null){\n            System.out.println(author.getName());\n        }\n~~~~\n\n​	尤其是对象中的属性还是一个对象的情况下。这种判断会更多。	\n\n​	而过多的判断语句会让我们的代码显得臃肿不堪。\n\n​	所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。\n\n​	并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。\n\n\n\n### 4.2 使用\n\n#### 4.2.1 创建对象\n\n​	Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。\n\n\n\n​	我们一般使用**Optional**的**静态方法ofNullable**来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。\n\n~~~~java\n        Author author = getAuthor();\n        Optional<Author> authorOptional = Optional.ofNullable(author);\n~~~~\n\n​	你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。\n\n​	而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。\n\n\n\n​	如果你**确定一个对象不是空**的则可以使用**Optional**的**静态方法of**来把数据封装成Optional对象。\n\n~~~~java\n        Author author = new Author();\n        Optional<Author> authorOptional = Optional.of(author);\n~~~~\n\n​	但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）\n\n\n\n​	如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用**Optional**的**静态方法empty**来进行封装。\n\n~~~~java\n		Optional.empty()\n~~~~\n\n​	\n\n​	所以最后你觉得哪种方式会更方便呢？**ofNullable**\n\n\n\n#### 4.2.2 安全消费值\n\n​	我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其**ifPresent**方法对来消费其中的值。\n\n​	这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。\n\n​	例如,以下写法就优雅的避免了空指针异常。\n\n~~~~java\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\n\n        authorOptional.ifPresent(author -> System.out.println(author.getName()));\n~~~~\n\n\n\n#### 4.2.3 获取值\n\n​	如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。\n\n\n\n\n\n#### 4.2.4 安全获取值\n\n​	如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。\n\n* orElseGet\n\n  获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。\n\n  ~~~~java\n          Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\n          Author author1 = authorOptional.orElseGet(() -> new Author());\n  ~~~~\n\n  \n\n\n\n* orElseThrow\n\n  获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。\n\n  ~~~~java\n          Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\n          try {\n              Author author = authorOptional.orElseThrow((Supplier<Throwable>) () -> new RuntimeException(\"author为空\"));\n              System.out.println(author.getName());\n          } catch (Throwable throwable) {\n              throwable.printStackTrace();\n          }\n  ~~~~\n\n  \n\n#### 4.2.5 过滤\n\n​	我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。\n\n~~~~java\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\n        authorOptional.filter(author -> author.getAge()>100).ifPresent(author -> System.out.println(author.getName()));\n\n~~~~\n\n\n\n#### 4.2.6 判断\n\n​	我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，**更推荐使用ifPresent方法**。\n\n~~~~java\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\n\n        if (authorOptional.isPresent()) {\n            System.out.println(authorOptional.get().getName());\n        }\n~~~~\n\n\n\n#### 4.2.7 数据转换\n\n​	Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。\n\n例如我们想获取作家的书籍集合。\n\n~~~~java\n    private static void testMap() {\n        Optional<Author> authorOptional = getAuthorOptional();\n        Optional<List<Book>> optionalBooks = authorOptional.map(author -> author.getBooks());\n        optionalBooks.ifPresent(books -> System.out.println(books));\n    }\n~~~~\n\n\n\n## 5. 函数式接口\n\n### 5.1 概述\n\n​	**只有一个抽象方法**的接口我们称之为函数接口。\n\n​	JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。\n\n\n\n### 5.2 常见函数式接口	\n\n- ​	Consumer 消费接口\n\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。\n\n  ![image-20211028145622163](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145622163-16354041894551.png)\n\n- ​	Function 计算转换接口\n\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回\n\n  ![image-20211028145707862](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145707862-16354042291112.png)\n\n- ​	Predicate 判断接口\n\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果\n\n  ![image-20211028145818743](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145818743-16354043004393.png)\n\n- ​	Supplier 生产型接口\n\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回\n\n![image-20211028145843368](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145843368-16354043246954.png)\n\n\n\n### 5.3 常用的默认方法\n\n- and\n\n  我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&&来拼接两个判断条件\n\n  例如：\n\n  打印作家中年龄大于17并且姓名的长度大于1的作家。\n\n  ~~~~java\n          List<Author> authors = getAuthors();\n          Stream<Author> authorStream = authors.stream();\n          authorStream.filter(new Predicate<Author>() {\n              @Override\n              public boolean test(Author author) {\n                  return author.getAge()>17;\n              }\n          }.and(new Predicate<Author>() {\n              @Override\n              public boolean test(Author author) {\n                  return author.getName().length()>1;\n              }\n          })).forEach(author -> System.out.println(author));\n  ~~~~\n\n- or \n\n  我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。\n\n  例如：\n\n  打印作家中年龄大于17或者姓名的长度小于2的作家。\n\n  ~~~~java\n  //        打印作家中年龄大于17或者姓名的长度小于2的作家。\n          List<Author> authors = getAuthors();\n          authors.stream()\n                  .filter(new Predicate<Author>() {\n                      @Override\n                      public boolean test(Author author) {\n                          return author.getAge()>17;\n                      }\n                  }.or(new Predicate<Author>() {\n                      @Override\n                      public boolean test(Author author) {\n                          return author.getName().length()<2;\n                      }\n                  })).forEach(author -> System.out.println(author.getName()));\n  ~~~~\n\n  \n\n- negate\n\n  Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反\n\n  例如：\n\n  打印作家中年龄不大于17的作家。\n\n  ~~~~java\n  //        打印作家中年龄不大于17的作家。\n          List<Author> authors = getAuthors();\n          authors.stream()\n                  .filter(new Predicate<Author>() {\n                      @Override\n                      public boolean test(Author author) {\n                          return author.getAge()>17;\n                      }\n                  }.negate()).forEach(author -> System.out.println(author.getAge()));\n  ~~~~\n\n  \n\n## 6. 方法引用\n\n​	我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。\n\n\n\n### 6.1 推荐用法\n\n​	我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。\n\n​	当我们方法引用使用的多了慢慢的也可以直接写出方法引用。\n\n\n\n### 6.2 基本格式\n\n​	类名或者对象名::方法名\n\n\n\n### 6.3 语法详解(了解)\n\n#### 6.3.1 引用类的静态方法\n\n​	其实就是引用类的静态方法\n\n##### 格式\n\n~~~~java\n类名::方法名\n~~~~\n\n\n\n##### 使用前提\n\n​	如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个类的静态方法**，并且我们把要重写的**抽象方法中所有的参数都按照顺序传入了这个静态方法中**，这个时候我们就可以引用类的静态方法。\n\n​	\n\n例如：\n\n如下代码就可以用方法引用进行简化\n\n~~~~java\n        List<Author> authors = getAuthors();\n\n        Stream<Author> authorStream = authors.stream();\n        \n        authorStream.map(author -> author.getAge())\n                .map(age->String.valueOf(age));\n~~~~\n\n注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。\n\n优化后如下：\n\n~~~~java\n        List<Author> authors = getAuthors();\n\n        Stream<Author> authorStream = authors.stream();\n\n        authorStream.map(author -> author.getAge())\n                .map(String::valueOf);\n~~~~\n\n\n\n#### 6.3.2 引用对象的实例方法\n\n##### 格式\n\n~~~~java\n对象名::方法名\n~~~~\n\n\n\n##### 使用前提\n\n​	如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个对象的成员方法**，并且我们把要重写的**抽象方法中所有的参数都按照顺序传入了这个成员方法中**，这个时候我们就可以引用对象的实例方法\n\n\n\n例如：\n\n~~~~java\n        List<Author> authors = getAuthors();\n\n        Stream<Author> authorStream = authors.stream();\n        StringBuilder sb = new StringBuilder();\n        authorStream.map(author -> author.getName())\n                .forEach(name->sb.append(name));\n~~~~\n\n优化后：\n\n~~~~java\n        List<Author> authors = getAuthors();\n\n        Stream<Author> authorStream = authors.stream();\n        StringBuilder sb = new StringBuilder();\n        authorStream.map(author -> author.getName())\n                .forEach(sb::append);\n~~~~\n\n\n\n\n\n\n\n#### 6.3.4 引用类的实例方法\n\n##### 格式\n\n~~~~java\n类名::方法名\n~~~~\n\n\n\n##### 使用前提\n\n​	如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了第一个参数的成员方法**，并且我们把要**重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中**，这个时候我们就可以引用类的实例方法。\n\n\n\n例如：\n\n```java\n    interface UseString{\n        String use(String str,int start,int length);\n    }\n\n    public static String subAuthorName(String str, UseString useString){\n        int start = 0;\n        int length = 1;\n        return useString.use(str,start,length);\n    }\n    public static void main(String[] args) {\n\n        subAuthorName(\"三更草堂\", new UseString() {\n            @Override\n            public String use(String str, int start, int length) {\n                return str.substring(start,length);\n            }\n        });\n\n	}\n```\n\n优化后如下：\n\n~~~~java\n    public static void main(String[] args) {\n\n        subAuthorName(\"三更草堂\", String::substring);\n\n    }\n~~~~\n\n\n\n\n\n#### 6.3.5 构造器引用\n\n​	如果方法体中的一行代码是构造器的话就可以使用构造器引用。\n\n\n\n##### 格式\n\n~~~~java\n类名::new\n~~~~\n\n\n\n##### 使用前提\n\n​	如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个类的构造方法**，并且我们把**要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中**，这个时候我们就可以引用构造器。\n\n例如：\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .map(author -> author.getName())\n                .map(name->new StringBuilder(name))\n                .map(sb->sb.append(\"-三更\").toString())\n                .forEach(str-> System.out.println(str));\n~~~~\n\n优化后：\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .map(author -> author.getName())\n                .map(StringBuilder::new)\n                .map(sb->sb.append(\"-三更\").toString())\n                .forEach(str-> System.out.println(str));\n~~~~\n\n\n\n\n\n## 7. 高级用法\n\n### 基本数据类型优化\n\n​	我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。\n\n​	即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。\n\n​	所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。\n\n​	例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。\n\n~~~~java\n    private static void test27() {\n\n        List<Author> authors = getAuthors();\n        authors.stream()\n                .map(author -> author.getAge())\n                .map(age -> age + 10)\n                .filter(age->age>18)\n                .map(age->age+2)\n                .forEach(System.out::println);\n\n        authors.stream()\n                .mapToInt(author -> author.getAge())\n                .map(age -> age + 10)\n                .filter(age->age>18)\n                .map(age->age+2)\n                .forEach(System.out::println);\n    }\n~~~~\n\n\n\n### 并行流\n\n​	当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。\n\n​	parallel方法可以把串行流转换成并行流。\n\n~~~~java\n    private static void test28() {\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        Integer sum = stream.parallel()\n                .peek(new Consumer<Integer>() {\n                    @Override\n                    public void accept(Integer num) {\n                        System.out.println(num+Thread.currentThread().getName());\n                    }\n                })\n                .filter(num -> num > 5)\n                .reduce((result, ele) -> result + ele)\n                .get();\n        System.out.println(sum);\n    }\n~~~~\n\n​	也可以通过parallelStream直接获取并行流对象。\n\n~~~~java\n        List<Author> authors = getAuthors();\n        authors.parallelStream()\n                .map(author -> author.getAge())\n                .map(age -> age + 10)\n                .filter(age->age>18)\n                .map(age->age+2)\n                .forEach(System.out::println);\n~~~~\n\n\n\n\n\n',1,'',0,0,1,'2022-10-25 09:14:02',NULL),(117,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/30f83ce0bea0c233814f0b6e2a5624e6.jpg',' AOP+注解实现日志记录','# AOP+注解实现日志记录\n\n## 1、依赖\n\n首先引入springboot的aop依赖和fastjson用于序列化json\n\n```xml\n        <!-- fastjson -->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.11</version>\n        </dependency>\n		<!-- AOP切面 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n\n```\n\n## 2、自定义切入点注解\n\n```java\nimport java.lang.annotation.*;\n\n/**\n * @author icatw\n * @date 2022/10/26\n * @email 762188827@qq.com\n * @apiNote 自定义操作日志注解\n */\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\n@Documented\npublic @interface OperaLog {\n    String businessName();\n}\n\n/**\n * @author icatw\n * @date 2022/10/26\n * @email 762188827@qq.com\n * @apiNote\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface SysLog {\n    String businessName();\n}\n```\n\n## 3、建立日志表\n\n``` sql\nCREATE TABLE `sys_log` (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\n  `url` varchar(255) DEFAULT NULL COMMENT \'请求接口路径\',\n  `business_name` varchar(20) DEFAULT NULL COMMENT \'接口名\',\n  `http_method` varchar(20) DEFAULT NULL COMMENT \'请求类型\',\n  `class_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT \'全路径类名\',\n  `ip` varchar(255) DEFAULT NULL COMMENT \'请求ip\',\n  `request_args` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT \'请求参数（json）\',\n  `response` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT \'响应（json）\',\n  `create_time` datetime DEFAULT NULL COMMENT \'请求时间\',\n  `create_by` bigint DEFAULT NULL COMMENT \'创建人id\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=\'系统日志\';\n```\n\n## 4.创建实体类\n\n``` java\npackage cn.icatw.domain.entity;\n\nimport com.baomidou.mybatisplus.annotation.*;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport io.swagger.annotations.*;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * 系统日志(Log)实体类\n *\n * @author icatw\n * @since 2022-10-27 10:51:25\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@ApiModel(\"Log\")\n@TableName(\"sys_log\")\npublic class Log implements Serializable {\n    private static final long serialVersionUID = -56646343480001713L;\n    /**\n     * 主键id\n     */\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    /**\n     * 请求接口路径\n     */\n    @TableField(value = \"url\")\n    @ApiModelProperty(\"请求接口路径\")\n    private String url;\n\n    /**\n     * 接口名\n     */\n    @TableField(value = \"business_name\")\n    @ApiModelProperty(\"接口名\")\n    private String businessName;\n\n    /**\n     * 请求类型\n     */\n    @TableField(value = \"http_method\")\n    @ApiModelProperty(\"请求类型\")\n    private String httpMethod;\n\n    /**\n     * 类名\n     */\n    @TableField(value = \"class_method\")\n    @ApiModelProperty(\"全路径类名\")\n    private String classMethod;\n\n    /**\n     * 请求ip\n     */\n    @TableField(value = \"ip\")\n    @ApiModelProperty(\"请求ip\")\n    private String ip;\n\n    /**\n     * 请求参数（json）\n     */\n    @TableField(value = \"request_args\")\n    @ApiModelProperty(\"请求参数（json）\")\n    private String requestArgs;\n\n    /**\n     * 响应（json）\n     */\n    @TableField(value = \"response\")\n    @ApiModelProperty(\"响应（json）\")\n    private String response;\n    /**\n     * 创建人的用户id\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private Long createBy;\n    /**\n     * 创建时间\n     */\n    @TableField(value = \"create_time\", fill = FieldFill.INSERT)\n    @ApiModelProperty(\"请求时间\")\n    private Date createTime;\n}\n\n\n```\n\n## 5、定义操作日志切面\n\n``` java\n@Component\n@Aspect\n@Slf4j\npublic class LogAspect {\n    private final Log myLog = new Log();\n\n    @Autowired\n    LogService logService;\n\n    @Pointcut(\"@annotation(cn.icatw.annotation.SysLog)\")\n    public void pt() {\n    }\n\n    @Around(\"pt()\")\n    public Object printLog(ProceedingJoinPoint pjp) throws Throwable {\n        Object ret;\n        try {\n            handleBefore(pjp);\n            ret = pjp.proceed();\n            handleAfter(ret);\n        } finally {\n            //结束后换行\n            log.info(\"======End======\" + System.lineSeparator());\n        }\n        return ret;\n    }\n\n    private void handleAfter(Object ret) {\n        // 打印出参\n        log.info(\"Response       : {}\", JSON.toJSONString(ret));\n        myLog.setResponse(JSON.toJSONString(ret));\n        logService.save(myLog);\n    }\n\n    private void handleBefore(ProceedingJoinPoint pjp) {\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n        //获取被增强方法上的注解对象\n        SysLog sysLog = getSystemLog(pjp);\n        log.info(\"=======Start=======\");\n        // 打印请求 URL\n        log.info(\"URL            : {}\", request.getRequestURL());\n        myLog.setUrl(String.valueOf(request.getRequestURL()));\n        // 打印描述信息\n        log.info(\"BusinessName   : {}\", sysLog.businessName());\n        myLog.setBusinessName(sysLog.businessName());\n        // 打印 Http method\n        log.info(\"HTTP Method    : {}\", request.getMethod());\n        myLog.setHttpMethod(request.getMethod());\n        // 打印调用 controller 的全路径以及执行方法\n        log.info(\"Class Method   : {}.{}\",\n                pjp.getSignature().getDeclaringTypeName(),\n                ((MethodSignature) pjp.getSignature()).getName());\n        myLog.setClassMethod(pjp.getSignature().getDeclaringTypeName() + \".\"\n                + ((MethodSignature) pjp.getSignature()).getName());\n        // 打印请求的 IP\n        log.info(\"IP             : {}\", request.getRemoteHost());\n        myLog.setIp(request.getRemoteHost());\n        // 打印请求入参\n        log.info(\"Request Args   : {}\", JSON.toJSONString(pjp.getArgs()));\n        myLog.setRequestArgs(JSON.toJSONString(pjp.getArgs()));\n        // 结束后换行\n        log.info(\"=======End=======\" + System.lineSeparator());\n    }\n\n    private SysLog getSystemLog(ProceedingJoinPoint pjp) {\n        MethodSignature signature = (MethodSignature) pjp.getSignature();\n        return signature.getMethod().getAnnotation(SysLog.class);\n    }\n}\n```\n\n必须加上`@Component`和`@Aspect`注解\n\n## 6、在需要记录日志的Controller方法上打上@OperaLog注解\n\n``` java\n @PostMapping(\"/login\")\n    @SysLog(businessName = \"用户登陆\")\n    public ResponseResult login(@RequestBody User user) {\n        return blogLoginService.login(user);\n    }\n```\n\n大功告成！',1,'',0,0,1,'2022-10-27 14:33:13',NULL),(118,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg','SpringBoot初始化程序','# SpringBoot初始化程序\n\n> 今天在做博客项目时遇到了更新浏览量的问题\n>\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\n\n```java\npackage cn.icatw.runner;\n\nimport cn.icatw.Constants.SystemConstants;\nimport cn.icatw.domain.entity.Article;\nimport cn.icatw.mapper.ArticleMapper;\nimport cn.icatw.utils.RedisCache;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * 在项目启动时将文章浏览量存入Redis中\n *\n * @author icatw\n * @date 2022/10/27\n * @email 762188827@qq.com\n * @apiNote\n */\n@Component\n@Slf4j\npublic class ViewCountRunner implements CommandLineRunner {\n    @Resource\n    ArticleMapper articleMapper;\n    @Resource\n    RedisCache redisCache;\n\n    @Override\n    public void run(String... args) throws Exception {\n        List<Article> articles = articleMapper.selectList(null);\n        Map<String, Integer> map = articles.stream().collect(\n                //将文章id和浏览量以map结构存入redis中\n                Collectors.toMap(article -> article.getId().toString(),\n                        article -> article.getViewCount().intValue()));\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\n        log.info(\"===缓存初始化成功===\");\n    }\n}\n```',1,'',1,0,1,'2022-10-27 16:37:51','2024-04-17 16:18:08'),(119,1,197,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2023-11-13','1213213测试',1,'',0,1,1,'2023-11-13 09:08:54','2023-11-13 09:09:50'),(120,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2dc722f14293755dad61ba4ef9980332.jpg','SpringBoot使用@Scheduled注解实现定时任务','# SpringBoot使用@Scheduled注解实现定时任务\n\n1. 首先在启动类上加上@EnableScheduling注解\n\n![image-20231204081917602](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231204081917602.png)\n\n2. 创建定时任务\n\n使用@Scheduled注解创建定时任务，并使用@Component注入容器中。\n\n```java\npackage com.pumpkin.disease.schedule;\n\nimport com.pumpkin.disease.service.ImageService;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @author 王顺\n * @date 2023/12/2\n * @email 762188827@qq.com\n * @apiNote\n */\n@Component\npublic class ImageUploadTask {\n    @Resource\n    ImageService imageService;\n    private static final SimpleDateFormat f=new SimpleDateFormat(\"HH:mm:ss\");\n\n    /**\n     * 上传oss\n     * 60秒执行一次\n     */\n    @Scheduled(fixedRate = 60000)\n    public void uploadOss(){\n        imageService.timedUpload();\n        System.out.println(\"timedUpload方式开启定时任务：现在的时间是\"+f.format(new Date()));\n    }\n}\n```\n\n3. 编写定时任务实现\n\n```java\n@Override\npublic void timedUpload() {\n    try {\n        //最大520张\n        long count = this.count();\n        if (count > 520) {\n            return;\n        }\n        ImageJson imageJson = ImageUtil.getRandomImageJson();\n        AssertUtil.assertIsNotPass(AssertUtil.isNull(imageJson), \"壁纸接口异常！\");\n        //把地址转换成URL对象\n        URL url = new URL(Objects.requireNonNull(imageJson).getImgurl());\n        //创建http链接\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        //设置超时间为3秒\n        conn.setConnectTimeout(3 * 1000);\n        //防止屏蔽程序抓取而返回403错误\n        conn.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\");\n        //得到输入流\n        InputStream inputStream = conn.getInputStream();\n        /**\n         * filename:文件名\n         * file.getName()：原文件名称\n         * file.getContentType()：原文件ContentType\n         * fileStream：文件输入字节流\n         */\n        MultipartFile file = new MockMultipartFile(\"filename\", \"\", imageJson.getFormat(), inputStream);\n        String ossUrl = uploadStrategyContext.executeUploadFile(file, UploadModeEnum.OSS_UPLOAD.getMode(), \"randomWallpaper\");\n        Image image = new Image();\n        image.setImageUrl(ossUrl);\n        image.setImageName(\"随机测试\");\n        image.setDescription(\"这是壁纸接口拿来的随机图片\");\n        image.setTypeId(getTypeIdByCategory(imageJson.getCategory()));\n        saveImage(image);\n        log.info(\"图片保存成功！\");\n        System.out.println(ossUrl);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n',1,'',0,0,1,'2023-12-04 08:28:40',NULL),(121,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2dc722f14293755dad61ba4ef9980332.jpg','Spring Boot + Vue 壁纸分享平台','# Spring Boot + Vue 壁纸分享平台项目讲解\n\n大家好，我很荣幸在这里向大家介绍我们的壁纸分享平台项目。这个项目包括了前台和后台两个部分，为用户提供了丰富的壁纸资源和强大的管理功能。\n\n## 1. 项目背景\n\n##### 随着互联网的发展，壁纸分享平台在用户生活中扮演着越来越重要的角色。与传统壁纸网站不同，我们的平台不仅提供了丰富多彩的壁纸资源，而且是完全免费的。用户可以自由上传、分享、和下载高质量的壁纸，为用户提供了更广泛的选择空间。 在传统壁纸网站中，用户往往需要支付费用或者受到下载次数的限制，一不小心可能还会跳转到广告页面。而我们的平台通过开放的上传和下载机制，鼓励用户分享和交流优秀的作品。这不仅丰富了平台的壁纸库，也构建了一个更加活跃和友好的社区。\n\n## 2. 在线地址\n\n- **前台地址：** [www.wallpaper.icatw.top](http://www.wallpaper.icatw.top)\n- **后台管理系统地址：** [www.admin.wallpaper.icatw.top](http://www.admin.wallpaper.icatw.top)\n\n**项目截图**\n\n![项目截图1](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003029075.png)\n\n![项目截图2](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002930533.png)\n\n![项目截图3](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002945631.png)\n\n![项目截图4](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003010907.png)\n\n![项目截图5](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003120406.png)\n\n![项目截图6](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003134608.png)\n\n![项目截图7](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003145402.png)\n\n\n## 3. 技术栈概览\n\n### 后端技术栈：\n\n- **Spring Boot：** 强大的后端框架，提供快速开发和部署的能力。\n- **Spring Security：** 实现了基于RBAC权限模型的动态权限路由系统，确保灵活而安全的权限控制。\n- **MyBatisPlus：** 数据库操作的优秀框架，简化了数据库交互的流程。\n- **Swagger3和Knife4j：** 提供了强大的接口管理和文档生成功能，方便团队协作和API调试。\n- **Redis：** 用于缓存和提高系统性能。\n- **对象存储：** 支持腾讯云Cos、七牛云Kodo和阿里云Oss对象存储，为用户提供高效的图片存储和访问。\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\n- **JWT Token 登录：** 使用JWT实现了无状态的用户认证，增强了系统的安全性。\n\n### 代码结构：\n\n![代码结构](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205001504507.png)\n\n### 前端技术栈：\n\n- **Vue.js：** 强大的前端框架，使我们能够构建响应式和高性能的用户界面。\n- **Vue Router：** 提供了在单页面应用中进行导航的能力，使用户能够方便地切换页面。\n- **Vuex：** 用于管理应用的状态，实现组件之间的共享数据。\n- **Element UI、Ant Design Vue：** 提供了一套美观、易用的UI组件，简化了页面的开发过程。\n- **Axios：** 用于进行HTTP请求，与后端进行数据交互。\n\n## 4. 主要功能\n\n### 前台用户功能：\n\n- **用户认证与授权：** 提供注册和登录功能，确保用户信息的安全性。\n- **壁纸搜索与分类：** 用户可以轻松找到自己喜欢的壁纸，支持多种分类方式。\n- **个人信息管理：** 用户可以管理自己的个人信息，包括上传头像等。\n- **收藏：** 用户可以收藏喜欢的壁纸。\n- **JWT Token 登录：** 采用JWT Token方式进行用户身份验证，保障用户信息安全。\n\n### 后台管理系统功能：\n\n- **壁纸管理：**\n  - 壁纸管理：管理壁纸相关信息，包括增删改查。\n  - 分类管理：壁纸分类相关信息。\n- **用户管理：**\n  - 用户管理：管理用户相关信息，包括增删改查以及重置密码操作。\n- **权限管理：**\n  - 角色管理：管理系统角色，分配相应权限。\n  - 菜单管理：配置系统菜单，实现动态权限路由。\n- **日志管理：**\n  - 登陆日志：记录用户登录信息，提高系统安全性。\n  - 操作日志：记录用户操作信息，便于系统行为追溯。\n- **系统管理：**\n  - 系统配置：动态配置存储在数据库中，包括对象存储等。\n  - 文件存储相关配置：配置文件存储的相关信息。\n- **系统监控：**\n  - 实现系统监控功能，包括性能、资源使用情况等。\n\n## 5. 创新与亮点\n\n- **动态权限路由：** 利用RBAC权限模型和Spring Security及前端Vue-Router实现的动态权限路由系统，确保权限控制的灵活性。\n- **动态配置：** 使用策略模式和后台管理系统的配置菜单，实现了动态配置，包括对象存储等。\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\n- **用户自由度高：** 网站完全免费登录注册，无需积分，不限下载次数，可以自行上传与分享高质量的壁纸。\n- **JWT Token登录：** 采用JWT Token方式进行用户身份验证，增加了系统的安全性。\n\n## 6. 不足及后续计划\n\n**项目不足之处：** 由于项目时间紧迫，我们承认某些功能可能没有完全开发完成，其中包括用户上传图片审核功能。此外，系统在使用过程中可能存在一些bug，我们期待老师及同学们能够给予宝贵的意见和建议，以帮助我们不断改进和提升。\n\n- **后续计划：** 我们已经在计划中，将在未来的版本中引入一些重要的功能和改进，包括但不限于：\n  - **JustAuth第三方登录：** 提供更便捷的用户登录体验，增强用户友好性。\n  - **忘记密码找回功能**：使用阿里云短信服务或者集成邮箱实现手机号/邮箱找回密码功能。\n  - **用户上传图片审核功能：** 引入审核机制，防止恶意上传图片，提高平台内容质量。\n  - **反馈功能：** 添加用户反馈功能，促进用户参与，及时发现和解决问题。\n  - **性能优化和Bug修复：** 不断优化系统性能，修复已知和新发现的bug，提高系统稳定性。\n\n## 结语\n\n以上便是关于i壁纸的项目介绍，感谢老师们的聆听，目前项目已上线，我们欢迎大家在使用过程中提出建议和需求，共同为平台的持续改进努力。谢谢您的理解与支持！',1,'',0,0,1,'2023-12-05 00:50:08','2024-04-17 17:46:51'),(122,1,189,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','docker部署springboot项目','# docker部署springboot项目\n\n前提是服务器安装了docker及相关服务\n\n## 1.使用maven打包springboot项目\n\n​	**使用maven-package打jar包**\n\n![image-20231221011704644](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221011704644.png)\n\n## 2.编写dockerfile文件\n\n![image-20231221015601110](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221015601110.png)\n\n```dockerfile\n#依赖的父镜像\nFROM java:8\n#作者\nMAINTAINER icatw\n#jar包添加到镜像中\n# ADD wallpaper-server-1.0.jar wallpaper.jar\n#容器暴露的端口 即jar程序在容器中运行的端口\nEXPOSE 9888\n#容器启动之后要执行的命令\nENTRYPOINT [\"java\",\"-Xmx256m\",\"-Xms256m\",\"-jar\",\"/data/wallpaper.jar\"]\n```\n\n### 3.上传至服务器\n\n![image-20231221190059655](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190059655.png)\n\n![image-20231221190132391](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190132391.png)\n\n## 4.cd进入dockerfile\n\n**使用docker build -t wallpaper .**\n\n构建docker镜像\n\n## 5.运行docker容器\n\ndocker run --name wallpaper   -p 9999:9999 -d \n\n![image-20231221190834449](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190834449.png)\n\n',1,'',0,0,1,'2023-12-21 19:16:49',NULL),(123,1,197,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2023-12-25','1',1,'',0,1,1,'2023-12-25 11:44:26','2023-12-25 16:42:20'),(124,1,197,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2023-12-25','1',1,'',0,1,1,'2023-12-25 16:41:46','2023-12-25 16:42:16'),(125,1,199,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','设计模式使用之策略模式','# 设计模式使用之策略模式\n\n在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n\n在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。\n\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n\n## 介绍\n\n**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n\n**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\n\n**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。\n\n**如何解决：**将这些算法封装成一个一个的类，任意地替换。\n\n**关键代码：**实现同一个接口。\n\n**应用实例：** 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\n\n**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n\n**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。\n\n**使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n\n**注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n\n**策略模式包含以下几个核心角色：**\n\n- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。\n- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。\n- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。\n\n策略模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法。客户端代码不需要知道具体的算法细节，而是通过调用环境类来使用所选择的策略。\n\n## 实现\n\n我们将创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。\n\n*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。\n\n![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)\n\n### 步骤 1\n\n创建一个接口。\n\n**Strategy.java**\n\n``` java\npublic interface Strategy {   \n	public int doOperation(int num1, int num2); \n}\n```\n\n### 步骤 2\n\n创建实现接口的实体类。\n\n**OperationAdd.java**\n\n```java\npublic class OperationAdd implements Strategy{   \n@Override   public int doOperation(int num1, int num2) \n{return num1 + num2;} \n}\n```\n\n**OperationSubtract.java**\n\n```  java\npublic class OperationSubtract implements Strategy{   \n    @Override   public int doOperation(int num1, int num2) \n    {      return num1 - num2;   } \n}\n```\n\n**OperationMultiply.java**\n\n``` java\npublic class OperationMultiply implements Strategy{   \n    @Override   public int doOperation(int num1, int num2) \n    {      return num1 * num2;   } \n}\n```\n\n### 步骤 3\n\n创建 *Context* 类。\n\n**Context.java**\n\n``` java\npublic class Context {   \n    private Strategy strategy;    \n    public Context(Strategy strategy)\n    {this.strategy = strategy;}    \n    public int executeStrategy(int num1, int num2){      \n        return strategy.doOperation(num1, num2);} \n}\n```\n\n### 步骤 4\n\n使用 *Context* 来查看当它改变策略 *Strategy* 时的行为变化。\n\n**StrategyPatternDemo.java**\n\n``` java\npublic class StrategyPatternDemo {   \n    public static void main(String[] args) {      \n        Context context = new Context(new OperationAdd());          \n        System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5));       \n        context = new Context(new OperationSubtract());            \n        System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5));       \n        context = new Context(new OperationMultiply());          \n        System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5));   } } \n```\n\n### 步骤 5\n\n执行程序，输出结果：\n\n```tex\n10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n```\n\n## 项目中的具体应用\n\n> 现有一个需求，要求系统能够强制删除数据（物理删除）以及保存删除的关键数据，并将此功能封装，之后会有更多的模块需要扩展实现强制删除的功能，在此我们使用策略模式实现。\n\n**需要保留的关键字段我们使用自定义注解 ` ForceDeleteLog` 标识**\n\n``` java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 强制删除日志保留字段\n *\n * @author wangshun\n * @date 2024/01/24\n */\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ForceDeleteLog {\n}\n\n```\n\n**之后在实体类中需要保存记录的属性上加上这个注解即可**\n\n#### **1.定义策略接口**\n\n``` java\n/**\n * @author 王顺\n * @date 2024/1/24\n * @apiNote 强制删除策略\n */\npublic interface ForceDeleteStrategy {\n    /**\n     * 强制删除和保存\n     *\n     * @param forceDelete 强制删除\n     * @return {@link String}\n     * @throws Exception 例外\n     */\n    @Transactional(rollbackFor = Exception.class)\n    String forceDeletionAndSaving(ForceDelete forceDelete)throws Exception  ;\n}\n\n```\n\n#### 2.扩展抽象接口\n\n``` java\nimport com.chalco.contractor.forceDelete.aop.ForceDeleteLog;\nimport com.chalco.contractor.forceDelete.entity.ForceDelete;\nimport com.chalco.contractor.forceDelete.strategy.ForceDeleteStrategy;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author 王顺\n * @date 2024/1/24\n * @apiNote\n */\n@Getter\n@Setter\n@Slf4j\npublic abstract class AbstractForceDeleteStrategyImpl implements ForceDeleteStrategy {\n\n    /**\n     * 强制删除和保存\n     *\n     * @return {@link String}\n     * @throws Exception 例外\n     */\n    @Override\n    public String forceDeletionAndSaving(ForceDelete forceDelete) throws Exception {\n        if (preCheck(forceDelete)) {\n            save(forceDelete);\n            forceDelete(forceDelete);\n            return getModuleName()+\"强制删除成功！\";\n\n        }\n        return \"错误\";\n    }\n\n    public static String convertToJson(Object entity) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        Map<String, Object> jsonMap = new HashMap<>(5);\n\n        for (Field field : entity.getClass().getDeclaredFields()) {\n            field.setAccessible(true);\n\n            // 检查字段是否带有 @ForceDeleteLog 注解\n            if (field.isAnnotationPresent(ForceDeleteLog.class)) {\n                try {\n                    // 将带有 @ForceDeleteLog 注解的字段添加到 JSON 中\n                    jsonMap.put(field.getName(), field.get(entity));\n                } catch (IllegalAccessException e) {\n                    log.error(\"convertToJson error\", e);\n                }\n            }\n        }\n\n        try {\n            // 将 Map 转换为 JSON 字符串\n            return objectMapper.writeValueAsString(jsonMap);\n        } catch (Exception e) {\n            log.error(\"convertToJson error\", e);\n        }\n\n        return null;\n    }\n\n    /**\n     * 获取表名\n     *\n     * @return {@link String}\n     * @throws Exception 例外\n     */\n    public abstract String getTableName() ;\n\n    /**\n     * 获取模块名称\n     *\n     * @return {@link String}\n     * @throws Exception 例外\n     */\n    public abstract String getModuleName() ;\n\n    /**\n     * 前置校验\n     *\n     * @param forceDelete 强制删除\n     * @return boolean\n     * @throws Exception 例外\n     */\n    public abstract boolean preCheck(ForceDelete forceDelete) throws Exception;\n\n    /**\n     * 强制删除\n     *\n     * @param forceDelete 强制删除\n     * @throws Exception 例外\n     */\n    public abstract void forceDelete(ForceDelete forceDelete) throws Exception;\n\n    /**\n     * 保存\n     *\n     * @param forceDelete 强制删除\n     * @throws Exception 例外\n     */\n    public abstract void save(ForceDelete forceDelete) throws Exception;\n}\n\n```\n\n#### 3.具体的业务接口\n\n``` java\npackage com.chalco.contractor.forceDelete.strategy.impl;\n\nimport cn.hutool.core.collection.CollUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.chalco.contractor.forceDelete.entity.ErrorMsg;\nimport com.chalco.contractor.forceDelete.entity.ForceDelete;\nimport com.chalco.contractor.forceDelete.service.ForceDeleteService;\nimport com.chalco.contractor.outsourcingProjectManagement.entity.OutsourcingUnitManagement;\nimport com.chalco.contractor.outsourcingProjectManagement.mapper.OutsourcingUnitManagementMapper;\nimport com.chalco.contractor.outsourcingProjectManagement.service.MultipleUnitManagementService;\nimport com.chalco.contractor.outsourcingProjectManagement.service.OutsourcingContractService;\nimport com.chalco.contractor.outsourcingProjectManagement.service.OutsourcingUnitManagementService;\nimport com.chalco.core.exception.BusinessException;\nimport com.chalco.modules.sys.service.AppointmentService;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Setter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\n\n/**\n * @author 王顺\n * @date 2024/1/24\n * @apiNote\n */\n@Getter\n@Setter\n@RequiredArgsConstructor\n@Slf4j\n@Service(\"unitForceDeletionStrategyImpl\")\npublic class UnitForceDeleteStrategyImpl extends AbstractForceDeleteStrategyImpl {\n    private final bean bean;\n\n    @Override\n    public String getTableName()  {\n        return \"表名\";\n    }\n\n    @Override\n    public String getModuleName()  {\n        return \"模块名\";\n    }\n\n    @Override\n    public boolean preCheck(ForceDelete forceDelete) {\n        return true;\n    }\n\n    @Override\n    public void forceDelete(ForceDelete forceDelete) throws Exception {\n\n    }\n\n    @Override\n    public void save(ForceDelete forceDelete) throws Exception {\n    }\n}\n\n```\n\n**需要重写方法实现具体的业务逻辑**（略）\n\n#### 4.策略上下文\n\n``` java\n/**\n * 强制删除策略上下文\n *\n * @author wangshun\n * @date 2024/01/26\n */\n@Component\n@RequiredArgsConstructor\npublic class ForceDeleteStrategyContext {\n\n    private final Map<String, ForceDeleteStrategy> forceDeletionStrategyMap;\n\n    /**\n     * 执行强制删除策略\n     *\n     * @param forceDelete            强制删除\n     * @param forceDeleteServiceName 强制删除服务名称\n     * @return {@link String}\n     */\n    public String executeForceDeleteStrategy(ForceDelete forceDelete, String forceDeleteServiceName) throws Exception {\n        //try {\n            // 执行特定的强制删除策略\n            return forceDeletionStrategyMap.get(forceDeleteServiceName).forceDeletionAndSaving(forceDelete);\n        //} catch (Exception e) {\n        //    throw new BusinessException(\"执行强制删除策略失败\");\n        //}\n    }\n}\n```\n\n>Spring在注入集合类的同时，会将集合泛型类的实例填入集合中，作为集合的初始值。 对于list、set填入的是注入类型Spring管理的实例，对于map，Spring会将service的名字作为key，对象作为value封装进入Map。\n\n#### 5.策略枚举类\n\n``` java\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n/**\n * @author 王顺\n * @date 2024/1/24\n * @apiNote\n */\n@Getter\n@AllArgsConstructor\npublic enum ForceDeleteStrategyImplEnum {\n    /**\n     * 承包单位\n     */\n    UNIT(\"承包单位\", \"unitForceDeletionStrategyImpl\");\n\n    private final String moduleName;\n    private final String implClass;\n\n    /**\n     * 按键获取值\n     *\n     * @param key 钥匙\n     * @return {@link String}\n     */\n    public static String getValueByKey(String key) {\n        for (ForceDeleteStrategyImplEnum sampleEnum : values()) {\n            if (sampleEnum.getModuleName().equals(key)) {\n                return sampleEnum.getImplClass();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### 6.策略调用\n\n```java\n/**\n * 强制删除\n *\n * @param forceDelete ids\n * @return {@link R}<{@link Boolean}>\n */\n@RequestMapping(\"forceDelete\")\npublic R<String> forceDelete(ForceDelete forceDelete) throws Exception {\n    return R.data(forceDeleteStrategyContext.executeForceDeleteStrategy(forceDelete, ForceDeleteStrategyImplEnum.UNIT.getImplClass()));\n}\n```\n\n',1,'',0,0,1,'2024-01-29 15:46:28',NULL),(126,1,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2024-03-26','111',1,'',0,1,1,'2024-03-27 15:32:33','2024-03-28 09:41:02'),(127,1006,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2024-04-10','111',1,'',0,1,1,'2024-04-10 10:21:44','2024-04-10 10:21:44'),(128,1006,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2024-04-10','测试',1,'',0,1,1,'2024-04-10 11:43:43','2024-04-10 11:43:43'),(129,1006,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2024-04-10','测试',1,'',0,1,1,'2024-04-10 11:45:16','2024-04-10 11:45:16'),(130,1006,188,'http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg','2024-04-10','测试',1,'',0,1,1,'2024-04-10 11:47:17','2024-04-10 11:47:17'),(131,1,188,'https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvjbiryxtj21hc0u07mz.jpg','2024-04-16','test',1,'',0,1,1,'2024-04-16 16:31:55','2024-04-16 16:33:28'),(132,1,188,'https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvj5sjt88j21hc0u07hp.jpg','2024-04-17','**测试**',1,'',0,0,1,'2024-04-17 23:49:33','2024-04-17 23:49:33'),(133,1,202,'https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkchavg0j31hc0u04gv.jpg','URL中带特殊字符导致传值丢失的处理方式','我们知道发送一个http请求时，如果使用的是GET方法，请求的参数会包含在url中并通过\\&进行分割，如：http://www.example.com/index?name=name1\\&id=id2。服务端根据url中的参数获取对应的值。java编写的后台代码，可通过HttpServletRequest的方法getParameter(\"name\")获取name的值:name=name1.\n\n事实上HttpServletRequest获取参数是对字符串\"?name=name1\\&id=id2\"进行拆分，根据\"\\&\"分割出参数名称，根据\"=\"分割出参数值。那么问题来了，如果我们的name里面本身就包含有\\&或者=，如name=\"na\\&me=1\"，如果发送http请求前不做相应的处理，url就变成了http://www.example.com/index?name=na\\&me=1\\&id=id2,这个时候后台解析出来的参数就变成了：name=na;me=1;id=id2,这显然不是我们想要的结果。\n\n面对这个情况的解决方法是对url中存在歧义的字符串进行URL编码。URL编码就是使用一种安全的字符去表示不安全的或存在歧义的字符，\"na\\&me=1\"经过URL编码后的值为：na%26me%3d1，这个时候我们发送http请求的url改为：http://www.example.com/index?name=na%26me%3d1\\&id=id2，服务端进行解码后解析参数便可获得正确的值：name=\"na\\&me=1\"。\n\n#### 接收URL参数时当其中有参数值含有#的时候，后面的参数就被截断，收不到值 {#content_views}\n\n因为\"#\"代表url的结束。在请求之前先替换\"#\"为其他字符例如\"$\"然后request的时候在替换为原来那个或者进行编码。\n\n在url中直接使用一些特殊字符，如果字符为\"a-z\",\"A-Z\",\"0-9\",\".\",\"-\",\"_\",\"\\*\"，则这些字符会直接被服务器识别，维持原值，如果是字符\"+\",\"/\",\"?\",\"%\",\"#\",\"\\&\",\"=\"，则它们将会被转码。那么我们就需要转码来让服务器进行识别。\n\n编码js语法： encodeURI(URIstring)\n\n解码js语法： decodeURI(URIstring)\n\n参考：<https://blog.csdn.net/qq_22855325/article/details/75335030>\n\n<https://blog.csdn.net/weixin_34186950/article/details/92316158>\n\n[https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\\&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control](https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)\n',2,'https://blog.csdn.net/lance666/article/details/112436679',0,1,1,'2024-04-18 01:15:53','2024-04-18 01:15:53'),(137,1,202,'https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkf96kuyj31hc0u04kb.jpg','URL中带特殊字符导致传值丢失的处理方式','我们知道发送一个http请求时，如果使用的是GET方法，请求的参数会包含在url中并通过\\&进行分割，如：http://www.example.com/index?name=name1\\&id=id2。服务端根据url中的参数获取对应的值。java编写的后台代码，可通过HttpServletRequest的方法getParameter(\"name\")获取name的值:name=name1.\n\n事实上HttpServletRequest获取参数是对字符串\"?name=name1\\&id=id2\"进行拆分，根据\"\\&\"分割出参数名称，根据\"=\"分割出参数值。那么问题来了，如果我们的name里面本身就包含有\\&或者=，如name=\"na\\&me=1\"，如果发送http请求前不做相应的处理，url就变成了http://www.example.com/index?name=na\\&me=1\\&id=id2,这个时候后台解析出来的参数就变成了：name=na;me=1;id=id2,这显然不是我们想要的结果。\n\n面对这个情况的解决方法是对url中存在歧义的字符串进行URL编码。URL编码就是使用一种安全的字符去表示不安全的或存在歧义的字符，\"na\\&me=1\"经过URL编码后的值为：na%26me%3d1，这个时候我们发送http请求的url改为：http://www.example.com/index?name=na%26me%3d1\\&id=id2，服务端进行解码后解析参数便可获得正确的值：name=\"na\\&me=1\"。\n\n#### 接收URL参数时当其中有参数值含有#的时候，后面的参数就被截断，收不到值 {#content_views}\n\n因为\"#\"代表url的结束。在请求之前先替换\"#\"为其他字符例如\"$\"然后request的时候在替换为原来那个或者进行编码。\n\n在url中直接使用一些特殊字符，如果字符为\"a-z\",\"A-Z\",\"0-9\",\".\",\"-\",\"_\",\"\\*\"，则这些字符会直接被服务器识别，维持原值，如果是字符\"+\",\"/\",\"?\",\"%\",\"#\",\"\\&\",\"=\"，则它们将会被转码。那么我们就需要转码来让服务器进行识别。\n\n编码js语法： encodeURI(URIstring)\n\n解码js语法： decodeURI(URIstring)\n\n参考：<https://blog.csdn.net/qq_22855325/article/details/75335030>\n\n<https://blog.csdn.net/weixin_34186950/article/details/92316158>\n\n[https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\\&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control](https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)\n',2,'https://blog.csdn.net/lance666/article/details/112436679',0,0,1,'2024-04-18 01:38:21','2024-04-18 01:45:16'),(138,1,202,'https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxk3yu6vwj31kw0w04k5.jpg','vuepress使用简介及个人博客搭建','vuepress使用简介 {#content_views}\n-----------------------------\n\n1、vuepress概述\n------------\n\nvuepress 是 Vuejs 官方提供的一个是Vue驱动的静态网站生成器，基于Markdown语法生成网页。简单的说它就是一个快速建设文档站点的工具，在简单配置好功能后，需要做的事情就剩下写好一个个 Markdown 文档，并且可以将其发布到github。\n\nvuepress官网：[VuePress](https://vuepress.vuejs.org/zh/ \"VuePress\")，对[vuepress](https://vuepress.vuejs.org/zh/ \"vuepress\")的描述比较详细。\n\n声明：原创文章未经允许，不得转载！！！\n\n2、vuepress简介\n------------\n\n### 2.1、vuepress搭建\n\n1）**新建一个工程目录为mjxWebBlog**\n\n新建一个mjxWebBlog文件夹，并导入到Visual Studio Code中\n\n![](https://img-blog.csdnimg.cn/20210809223150627.png)\n\n2）**安装本地依赖**\n\n```bash\nyarn add -D vuepress # npm install -D vuepress\n```\n\n![](https://img-blog.csdnimg.cn/20210809232348868.png)\n\n注：官方不再推荐全局安装 npm install -g vuepress\n\n扩展：yarn和npm等都是用于构建和打包 javascript 代码的工具。npm 出现之前**，** 前端依赖项是保存到存储库中并手动下载的，而如今，大量依赖项存储在神奇的 `node_modules` 内的嵌套文件夹中，Yarn 是为了弥补 npm 的一些缺陷而出现的，为了防止拉取到不同的版本，Yarn 有一个锁定文件 (yarn.lock) 记录了被确切安装上的模块的版本号，后来npm也做了一些类似的改进新增了类似yarn.lock的 package-lock.json。\n\n**3）初始化项目**\n\n将会创建一个package.json文件\n\n```bash\nyarn init -y # npm init -y (-y免去确认)\n```\n\nnpm init -y后生成package.json文件\n\n```bash\n{\n  \"name\": \"y\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"vuepress\": \"^1.8.2\"\n  },\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n**4）创建你的第一篇文档**\n\n```bash\nmkdir docs \n\necho \'# Hello VuePress\' > docs/README.md\n```\n\n**5）在 package.json 中添加一些 scripts**\n\n```bash\n{\n  \"scripts\": {\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n注：启动脚本docs:dev 键值可以自定义修改，此处是为了和一些项目中默认脚本中自带的 dev 区分开，都是等效于执行vuepress dev doc，根据你目录中的.vuepress配置项和docs下的所有.md/.html文件做一个项目的编译和打包。\n\n6）在本地启动服务器\n\n```bash\nyarn docs:dev # npm run docs:dev\n```\n\n启动之后（如果乱码，则改下README.md的编码），效果如下：\n\n![](https://img-blog.csdnimg.cn/20210809233648100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n### 2.2、vuepress目录结构说明\n\nVuePress 遵循 **\"约定优于配置\"** 的原则，推荐的目录结构如下：\n\n```XML\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │ \n│   ├── README.md\n│   ├── guide (一般用户都在这个目录下创建网站指南,当然可以不用)\n│   │   └── README.md （指南里面的具体内容）\n│   └── config.md\n│ \n└── package.json 项目初始化时，根目录下自动生成的配置文件,定义了项目的基本配置信息及需要依赖的各个模块、指定运行脚本命令的npm命令行缩写等。\n\n```\n\n* `docs/.vuepress`: 用于存放全局的配置、组件、静态资源等。\n* `docs/.vuepress/components`: 该目录中的 Vue 组件将会被自动注册为全局组件。\n* `docs/.vuepress/theme`: 用于存放本地主题。\n* `docs/.vuepress/styles`: 用于存放样式相关的文件。\n* `docs/.vuepress/styles/index.styl`: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。\n* `docs/.vuepress/styles/palette.styl`: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\n* `docs/.vuepress/public`: 静态资源目录。\n* `docs/.vuepress/templates`: 存储 HTML 模板文件。\n* `docs/.vuepress/templates/dev.html`: 用于开发环境的 HTML 模板文件。\n* `docs/.vuepress/templates/ssr.html`: 构建时基于 Vue SSR 的 HTML 模板文件。\n* `docs/.vuepress/config.js`: 配置文件的入口文件，也可以是 `YML` 或 `toml`。\n* `docs/.vuepress/enhanceApp.js`: 客户端应用的增强。\n\n### 2.3、MarkDown语法简介\n\n为了后续更好的学习，我们需要先了解一下MarkDown相关语法。\n\nMarkDown是一种轻量级标记语言，使用易读易写的纯文本格式编写文档。2004年由约翰·格鲁伯创建。使用MarkDown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。MarkDown编写的文档，后缀名为.md或.markdown。\n\n对于MarkDown的编写，我们可以下载Typora软件玩一下，当然也可以直接在Visual Studio Code中写或者使用在线工具：[在线markdown编辑器_微信公众号markdown排版工具](https://markdown.com.cn/editor/ \"在线markdown编辑器_微信公众号markdown排版工具\")\n\n#### 2.3.1、注释语法\n\n```html\n### 1.1、代码法\n    <div style=\'display:none\'>\n        哈哈哈哈，看不到我的我隐藏的很深\n    </div>\n### 1.2、html注释语法\n    <!--哈哈哈哈，我是注释，不会在浏览器中显示-->\n### 1.3、markdown注释语法\n    [//]: # (注释，不会在浏览器中显示)\n    [^_^]: # (我是注释)\n    [//]: <> (我是注释)\n    [comment]: <> (我是注释)\n```\n\n将这段代码放到我们的项目中运行，效果如下：\n\n![](https://img-blog.csdnimg.cn/20210810214854386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 2.3.2、标题\n\nMarkdown 支持两种形式的标题：\n\n1）使用的等号来表示一级标题, 使用连字符表示二级标题（只支持两级）\n\n2）每行开头使用 1-6 井号, 对应 1-6 级标题\n\n```cs\n# 我是一级标题\n## 我是二级标题\n### 我是三级标题\n#### 我是四级标题\n##### 我是五级标题\n###### 我是六级标题\n\nThis is an H1\n===\n我是二级标题\n---\n```\n\n案例效果：\n\n![](https://img-blog.csdnimg.cn/2021081022401272.gif)\n\n#### 2.3.3、目录\n\n根据标题生成目录，语法：\\[TOC\\]\n\n![](https://img-blog.csdnimg.cn/20210810224705534.gif)\n\n#### 2.3.4、块引用\n\nMarkdown 使用 email 样式的 `>` 字符作为块引用（最好对引用文本采取强制换行并在每一行行首放一个 `>`）\n\n1）单行引用\n\n2）多行引用\n\n3）嵌套引用\n\n![](https://img-blog.csdnimg.cn/20210810225859594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 2.3.5、列表\n\nMarkdown 支持有序列表和无序列表\n\n1）有序列表：序列`.`后 保持空格\n\n2）无序列表：无序列表使用星号, 加号, 和连字符 -- 这些符号是可互换。\n\n![](https://img-blog.csdnimg.cn/20210810231656138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 2.3.6、代码块\n\n预格式化的代码块用于输出编程语言和标记语言。要在 Markdown 中插入代码块：\n\n方式一： 只需要将每一行都缩进 4 个空格或者 1 个水平制表符；\n\n方式二：使用\\`\\`\\` 或者 \\`\\`\\`javascript指定语言配置。\n\n![](https://img-blog.csdnimg.cn/20210810234921483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 2.3.7、表格\n\nmarkdown中的表格，只能是中规中矩的表格，一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的。**`:`** 代表对齐方式。\n\n```bash\n|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n|=========|===============|============|\n```\n\n案例效果：\n\n![](https://img-blog.csdnimg.cn/20210810235614312.gif)\n\n#### 2.3.8、水平线（分割线）\n\n如果一行中只有三个以上的连字符, 星号, 或者下划线则会在该位置生成一个 `<hr />` 标签。\n\n![](https://img-blog.csdnimg.cn/20210811000852760.png)\n\n注：多个---使用时前一行不能写内容，会变成二级标题\n\n#### 2.3.9、链接\n\nMarkdown 支持两种链接形式: *内联* 和 *引用。*这两种形式下链接文本的定界符都是 \\[中括号\\]。\n\n![](https://img-blog.csdnimg.cn/20210811004409504.png)\n\n#### 2.3.10、强调（粗体、斜体、删除线）\n\nMarkdown 将星号 (`*`) 和下划线 (`_`) 作为强调标记。 用 `*` 或者 `_` 包裹的文本将会用 HTML `<em>` 标签包裹; 双 `*` 或者 `_` 将会用 HTML `<strong>` 标签包裹.。\n\n```bash\n普通文字*斜体文字*普通文字\n\n普通文字**粗体文字**普通文字\n\n普通文字~~删除文字~~普通文字\n```\n\n效果：![](https://img-blog.csdnimg.cn/20210811005328201.png)\n\n#### 2.3.11、代码\n\n要输出一个代码片段, 需要使用重音符号 (`````). 不同于预格式的代码块, 代码片段只是在普通段落中标识出代码.。\n\n![](https://img-blog.csdnimg.cn/20210811005711582.png)\n\n#### 2.3.12、图片\n\nMarkdown 使用了类似链接的语法来插入图片, 包含两种形式: *内联* 和 *引用。*\n\n![](https://img-blog.csdnimg.cn/20210811012549814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 2.3.13、自动链接\n\nMarkdown 支持一种 \"自动\" 创建 URL 和 email 地址链接的简短形式: 只需用尖括号包围 URL 或 email 地址即可。\n\n![](https://img-blog.csdnimg.cn/20210811012811631.png)\n\n#### 2.3.14、反斜杠转义\n\nMarkdown 中可以使用反斜杠转义 Markdown 语法符号为字面量。Markdown 为下面字符提供反斜杠转义:\n\n```java\n\\   backslash\n`   backtick\n*   asterisk\n_   underscore\n{}  curly braces\n[]  square brackets\n()  parentheses\n#   hash mark\n+   plus sign\n-   minus sign (hyphen)\n.   dot\n!   exclamation mark\n```\n\n#### 2.3.15、复选框\n\n使用- \\[ \\]标识复选框，x表示默认选中。\n\n```bash\n- [ ] 没选中的复选框\n- [x] 选中复选框\n```\n\n效果：![](https://img-blog.csdnimg.cn/20210811013714193.png)\n\n#### 2.3.16、语义标签\n\n|  描述  |                                               效果                                                |        代码         |\n|------|-------------------------------------------------------------------------------------------------|-------------------|\n| 斜体   | \\<i\\>斜体\\</i\\>                                                                                   | `<i>斜体</i>`       |\n| 加粗   | \\<b\\>加粗\\</b\\>                                                                                   | `<b>加粗</b>`       |\n| 强调   | \\<em\\>强调\\</em\\>                                                                                 | `<em>强调</em>`     |\n| 上标   | Za                                                                                              | `Z<sup>a</sup>`   |\n| 下标   | Za                                                                                              | `Z<sub>a</sub>`   |\n| 键盘文本 | <br /> ![](https://img-blog.csdnimg.cn/img_convert/fc63d48e41e03e240f6b1d7290b54fdb.png) <br /> | `<kbd>Ctrl</kbd>` |\n\n3、默认主题设置\n--------\n\n我们看到的首页，是通过配置根路径下的README.md文件实现的、而一些，导航栏、侧边栏，则是通过配置docs/config.js实现。\n\n### 3.1、首页\n\n1）创建`public目录存放`静态资源`和`config.js配置文件\n\n在.vuepress中创建 public 文件夹和config.js 文件，形成如下结构。这也是最简单的目录格式。\n\n```XML\nmjxWebBlog\n├─── docs\n│   ├── README.md\n│   └── .vuepress\n│       ├── public\n│       └── config.js\n└── package.json\n```\n\n2）官网给默认的主题提供了一个首页（Homepage）的布局。\n\n将docs目录下的README.md中的内容替换，并在public目录下放置一张图片,再次启动。\n\n**注：根路径默认的README.md，会被编译成index.html文件。**\n\n```java\n---\nhome: true\nheroImage: /logo.jpg\nactionText: 快速上手 →\nactionLink: /zh/guide/\nfeatures:\n- title: 简洁至上\n  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n- title: Vue驱动\n  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。\n- title: 高性能\n  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。\nfooter: MIT Licensed | Copyright © 2018-present Evan You\n---\n```\n\n图片：![](https://img-blog.csdnimg.cn/20210810002022515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n效果如下：![](https://img-blog.csdnimg.cn/20210810002202508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n再添加一些基本配置：修改docs/config.js文件\n\n```javascript\nmodule.exports = {\n  // 网站的一些基本配置\n  // base:配置部署站点的基础路径，后续再介绍\n  title: \'穆瑾轩\', // 网站的标题\n  description: \'穆瑾轩测试网页\', // 网站的描述，它将会以 <meta> 标签渲染到当前页面的 HTML 中。\n  head: [\n    [\'link\', { rel: \'icon\', href: \'/logo.png\' }] // 需要被注入到当前页面的 HTML <head> 中的标签\n  ],\n}\n```\n\n案例效果：![](https://img-blog.csdnimg.cn/20210813015811593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n### 3.2、导航栏\n\n我们可以看到页面的最上面默认有一个导航栏和搜索框。关于导航栏我们可以设置：页面标题、搜索框、 导航栏Logo/链接、多语言切换、仓库链接等。\n\n#### 3.2.1、**导航栏 Logo**\n\n你可以通过 `themeConfig.logo` 增加导航栏 Logo。\n\n```javascript\n//修改 .vuepress/config.js\n\nmodule.exports = {\n  themeConfig: {\n    logo: \'/dh_logo.jpg\',\n  }\n}\n```\n\n案例效果：![](https://img-blog.csdnimg.cn/20210811232634676.png)\n\n#### 3.2.2、**导航栏链接**\n\n可以通过 `themeConfig.nav` 增加一些导航栏链接。\n\n```javascript\n// 配置导航栏logo(themeConfig.logo)\nmodule.exports = {\n  themeConfig: {\n    logo: \'/dh_logo.jpg\',\n    nav: [\n      { text: \'Home\', link: \'/\' },\n      // 可指定链接跳转模式：默认target: \'_blank\'新窗口打开，_self当前窗口打开\n      { text: \'百度\', link: \'https://www.baidu.com\' },\n      { text: \'CSDN\', link: \'https://blog.csdn.net\', target: \'_blank\' },\n      { text: \'豆瓣\', link: \'https://movie.douban.com\', target: \'_self\', rel: \'\' },\n      // 支持嵌套,形成下拉式的导航菜单\n      {\n        text: \'语言\',\n        ariaLabel: \'Language Menu\',\n        items: [\n          { text: \'中文\', link: \'/language/chinese/\' },\n          { text: \'英文\', link: \'/language/english/\' }\n        ]\n      }\n    ],\n  }\n}\n```\n\n案例效果：![](https://img-blog.csdnimg.cn/20210811235923329.gif)\n\n如果还想继续嵌套,则可以这样继续往下嵌套：{ text: \'中文\', items: \\[{ text: \'语文\', link: \'/language/chinese/\'\' }\\] }\n\n当然也不是所有的页面都需要导航栏的， 所以vuepress使用下面这个配置禁用导航栏，禁用后页面就不会出现导航栏。\n\n```javascript\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    navbar: false\n  }\n}\n```\n\n### 3.3、侧边栏\n\n想要使侧边栏（sidebar）生效，需要配置 `themeConfig.sidebar`。`sidebar`可以分为全局设置以及局部设置。\n\n如果配置单页的侧边栏，只需要使用**sidebar: \'auto\'属性即可帮我们完成自动补充侧边栏。**\n\n#### **需要一个或多个侧边栏，可以使用数组实现侧边栏分组，也可以使用对象的形式来配置**。\n\n![](https://img-blog.csdnimg.cn/20210817222905258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### **3.3.1、单页侧边栏设置方式一**\n\n**在`.vuepress/config.js`中配置属性：sidebar: \'auto\'**\n\n第一步：建立如下目录结构及文件，/blog/fontend/README.md等文件内容这里就不展示了\n\n![](https://img-blog.csdnimg.cn/20210816233042783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n详细解析：vuepress的文件寻址，**不同类型的文件都已经预设好不同的默认路径**。\n\n1）图标/图片等**静态资源**相关的，第一个 \'/\' 默认指向的是 docs/.vuepress/public/\n\n2）侧边栏/导航栏链接的markdown文件，**第一个 \'/\' 默认指向的是 docs/**，我们这里是都放置在docs/xxx里，所以通常把目录建在docs下\n\n3）嵌入在markdown中使用的Vue组件，放置在docs/.vuepress/components目录中\n\n注：为此我们的路径最好是按规范来放置文件。找不到对应的文件，则会跳出404。\n\n第二步：修改**`.vuepress/config.js中的配置如下`**\n\n```javascript\n// 配置导航栏logo(themeConfig.logo)\n// 配置导航栏logo(themeConfig.logo)\nmodule.exports = {\n  // 网站的一些基本配置\n  // base:配置部署站点的基础路径，后续再介绍\n  title: \'穆瑾轩\', // 网站的标题\n  description: \'穆瑾轩测试网页\', // 网站的描述，它将会以 <meta> 标签渲染到当前页面的 HTML 中。\n  head: [\n    [\'link\', { rel: \'icon\', href: \'/logo.jpg\' }] // 需要被注入到当前页面的 HTML <head> 中的标签\n  ],\n  // host port在本地运行就不配置了\n  themeConfig: {\n    logo: \'/dh_logo.jpg\',\n    nav: [\n      // 直接跳转，\'/\'为不添加路由，跳转至首页，以/结尾的最终对应的都是/index.html,也就是README.md文件编译后的页面\n      { text: \'Home\', link: \'/\' },\n      // 对应blog/fontend/README.md\n      { text: \'前端\', link: \'/blog/fontend/\' },\n      { text: \'后端\', link: \'/blog/backend/\' },\n      // 对应/guide/guide.md\n      { text: \'导航\', link: \'/guide/guide\' },\n      // 不指定深度，默认深度1-提取h2 最大深度-2，同一标题下最多提取到h3，想要改变深度可以指定sidebarDepth\n    ],\n    // 禁用导航栏\n    // navbar: false,\n    // 设置自动生成侧边栏\n    sidebar: \'auto\',\n  }\n}\n```\n\n第三步：重启后效果如下\n\n案例效果：![](https://img-blog.csdnimg.cn/20210812021847129.gif)\n\n#### **3.3.2、单页侧边栏设置方式二**\n\n在md文件的顶部写上下面代码：\n\n```TypeScript\n# 自动补充侧边栏\n---\nsidebar: auto\n---\n\n# 禁用侧边栏\n---\nsidebar: false\n---\n```\n\n步骤一：注释或删除**`.vuepress/config.js中`**sidebar: \'auto\'属性，并且在guide.md中加入上诉代码：\n\n![](https://img-blog.csdnimg.cn/20210817000337700.png)\n\n步骤二： 重启后再效果如下，只有加了上诉配置的才出现了导航栏\n\n![](https://img-blog.csdnimg.cn/20210817000735715.gif)\n\n#### **3.3.3、**设置侧边栏标题显示的层数\n\n官网上提到了这样一个属性：sidebarDepth，可以通过在配置文件中配置`themeConfig.sidebarDepth`来设置嵌套层级。默认情况下，侧边栏会自动显示当前页面的标题(h2\\~h3)组成的链接，所以上面的案例中我们看到都是h2和h3可以被点击。\n\nsidebarDepth可设置的值：\n\n| 值 |              说明               |\n|---|-------------------------------|\n| 0 | 禁用标题（headers）链接               |\n| 1 | 默认值,只显示`h2`的标题                |\n| 2 | 可设置的最大值，再大无效, 同时提取`h2`和`h3`标题 |\n\n***注：如果设置了` sidebar: \'auto\' `,侧边栏会显示`h2`和`h3`标题，此时sidebarDepth的值只有0是生效的(仅显示`h2`的标题)，这里需要注意一下。***\n\n第一步：`.vuepress/config.js中加入sidebarDepth: 0属性`\n\n```TypeScript\n...\nsidebar: \'auto\',\n// 设置深度，使用了sidebar: \'auto\'的话只有设置0才会生效，否则默认2\nsidebarDepth: 0,\n...\n```\n\n第二步：重启后效果如下\n\n![](https://img-blog.csdnimg.cn/20210817001920488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n#### 3.3.4、显示一个/多个侧边栏 {#item-7-3}\n\n前面呢，我们使用属性***`sidebar: \'auto\' `*** ，会自动生成单页侧边栏，单页如果我们想要将一个模块集成在一个页面呢？我们可以为***`sidebar指定一个对象属性。`***\n\n语法格式：***sidebar{目录_key:\\[子链接1,子链接2...\\]}***\n\n***第一步：声明一个对象，对象的链接为：*** ***目录/blog/fontend/***\n\n```javascript\n...\nthemeConfig: {\n    logo: \'/dh_logo.jpg\',\n    nav: [\n      // 直接跳转，\'/\'为不添加路由，跳转至首页，以/结尾的最终对应的都是/index.html,也就是README.md文件编译后的页面\n      { text: \'Home\', link: \'/\' },\n      // 对应blog/fontend/README.md\n      { text: \'前端\', link: \'/blog/fontend/\' },\n      { text: \'后端\', link: \'/blog/backend/\' },\n      // 对应/guide/guide.md\n      { text: \'导航\', link: \'/guide/guide\' },\n    ],\n    // sidebar: \'auto\',\n    sidebar: {\n      //对象的默认路径\n      \'/blog/fontend/\': [\n        \'\', //侧边栏第一个页面是：/blog/fontend/README.md,、链接文字自动获取(页面的第一个header)，即h1(前端技术)\n        \'myhtml\',  //侧边栏第二个页面是：/blog/fontend/myhtml.md,链接文字自动获取(页面的第一个header)，即h2(html 二级标题)\n        [\'myJavascript\', \'js自定义的标题\'] //侧边栏第三个页面是：/blog/fontend/myJavascript.md ,指定链接的文字，使用一个格式为 [link, text] 的数组。\n      ]\n    },\n    sidebarDepth: 2,\n...\n```\n\n第二步：重启后效果如下：\n\n![](https://img-blog.csdnimg.cn/20210817012108737.gif)\n\n备注说明：\n\nsidebar: { \'/blog/fontend/\': \\[数组中只定义字符串（文件路径），则侧边栏页面的链接文字是当前页面中的第一个header)\\]}\n\nsidebar: { \'/blog/fontend/\': \\[数组中嵌套数组，数组的第一个参数为文件路径，而第二个参数为侧边栏页面的链接文字\\]}\n\n当然也可以在.md文件中指定名字，作为自定义标题\n\n```javascript\n---\ntitle: 自定义标题\n---\n```\n\n#### 3.3.5、侧边栏分组\n\n当然还可以使用分组的形式去实现。\n\n语法格式： ![](https://img-blog.csdnimg.cn/20210817233036316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n分组：侧边栏的每个子组默认是可折叠的，你可以设置 collapsable: false 来让一个组永远都是展开状态。\n\n第一步：添加如下代码\n\n```javascript\n...\nsidebar: [\n      {\n        title: \'分组1 前端\',\n        collapsable: false,\n        children: [\n          \'/blog/fontend/myhtml\',\n          [\'/blog/fontend/myJavascript\', \'js自定义的标题\']\n        ],\n      },\n      {\n        title: \'分组2 后端\',\n        collapsable: true,\n        children: [\n          \'/blog/backend/myjava\',\n        ]\n      }\n    ],\nsidebarDepth: 2,\n...\n```\n\n第二步：重启后效果如下：\n\n![](https://img-blog.csdnimg.cn/20210817022329415.gif)\n\n### 3.4、其他配置\n\n#### 3.4.1、搜索框\n\n**3.4.1.1、内置搜索**\n\n内置搜索只会为页面的标题、h2 、 h3 以及 tags 构建搜索索引。 如果你需要全文搜索，你可以使用 Algolia 搜索。官网提供给我们的内置搜索配置项如下：\n\n```javascript\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    search: false, // 设置是否使用导航栏上的搜索框\n    searchMaxSuggestions: 10  // 搜索框显示的搜索结果数量\n  }\n}\n```\n\n1）search: false 禁用内置搜索框。false为禁用，默认为true\n\n![](https://img-blog.csdnimg.cn/20210817235407967.png)\n\n2）searchMaxSuggestions: 10，调整默认搜索框显示的搜索结果数量，最大为10\n\n![](https://img-blog.csdnimg.cn/20210817235609359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n**3.4.1.2、Algolia 搜索**\n\n第三方免费搜索服务 algolia需要注册，访问[Algolia DocSearch](https://community.algolia.com/docsearch/ \"Algolia DocSearch\")来设置。\n\n#### 3.4.2、更新时间\n\n```javascript\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    lastUpdated: \'Last Updated\', // string | boolean\n  }\n}\n```\n\n由于 `lastUpdated` 是基于 `git` 的, 所以你只能在一个基于 `git` 的项目中启用它。在本地将文件提交到本地仓库也可以看到`lastUpdated`。\n\n![](https://img-blog.csdnimg.cn/2021081801482110.png)\n\n后面的内容呢，在项目实践中边做边学\n\n4、个人博客搭建实战\n----------\n\n### 4.1、建一个博客的模板\n\n网上有很多优秀的开源博客页面，我们就直接安装好，再继续开发。我这里找到的是[vuepress-theme-reco](https://vuepress-theme-reco.recoluan.com/ \"vuepress-theme-reco\")这个博客模板。\n\n#### 4.1.1、在本地安装博客模板\n\n```bash\n# init\nnpm install @vuepress-reco/theme-cli -g\ntheme-cli init mjxWebBlog\n\n# install\ncd mjxWebBlog\nnpm install\n\n# run\nnpm run dev\n\n# build\nnpm run build\n```\n\n注：如果出现禁止执行远程脚本的错误：可以执行：Set-ExecutionPolicy -Scope CurrentUse\n\n安装步骤一：\n\n![](https://img-blog.csdnimg.cn/20210818025224682.png)\n\n安装步骤二：\n\n![](https://img-blog.csdnimg.cn/20210818031102465.png)\n\n有三个风格的主题：\n\n![](https://img-blog.csdnimg.cn/20210818025924830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n安装步骤三：执行npm install，安装依赖包node_modules\n\n![](https://img-blog.csdnimg.cn/20210818030259840.png)\n\n步骤四：启动npm run dev\n\nblog主题：\n\n![](https://img-blog.csdnimg.cn/20210818030549498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n我选择第三个模板：afternoon-grocery主题：\n\n![](https://img-blog.csdnimg.cn/20210818031648216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n步骤五：继续开发：\n\n我的博客开发到这种进度时：\n\n![](https://img-blog.csdnimg.cn/20210820011027892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n步骤六：我在gitHub上创建一个名为：[mjxol.github.io](https://github.com/mjxol/mjxol.github.io \"mjxol.github.io\")的仓库\n\n![](https://img-blog.csdnimg.cn/2021082001123286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n步骤七：在博客地址中运行npm run build,静态文件都在public目录下生成了\n\n![](https://img-blog.csdnimg.cn/20210820011307636.png)\n\n步骤八：将文件推送至远程仓库，并合并到远程仓库的main分支\n\n![](https://img-blog.csdnimg.cn/20210820020059972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n最终：我们的文件都上传到github上了\n\n![](https://img-blog.csdnimg.cn/2021082002021090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n\n### 4.2、我的博客基础版\n\n我的个人博客基础版访问地址：[穆瑾轩的博客](https://mjxol.github.io/ \"穆瑾轩的博客\")\n\n页面展示：\n\n![](https://img-blog.csdnimg.cn/20210820021400165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\n',2,'https://blog.csdn.net/xiaoxianer321/article/details/119548202',0,0,1,'2024-04-18 01:46:33','2024-04-18 01:47:20');
/*!40000 ALTER TABLE `tb_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_article_tag`
--

DROP TABLE IF EXISTS `tb_article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_article_tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `fk_article_tag_1` (`article_id`) USING BTREE,
  KEY `fk_article_tag_2` (`tag_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1014 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_article_tag`
--

LOCK TABLES `tb_article_tag` WRITE;
/*!40000 ALTER TABLE `tb_article_tag` DISABLE KEYS */;
INSERT INTO `tb_article_tag` VALUES (870,57,30),(871,57,33),(875,59,34),(876,60,35),(877,60,36),(880,65,35),(881,65,36),(882,66,35),(883,66,36),(884,67,37),(886,71,33),(887,71,38),(888,72,33),(889,72,38),(890,73,33),(891,74,33),(892,74,38),(893,75,33),(894,76,33),(895,77,33),(896,77,38),(897,78,33),(898,78,38),(899,79,33),(900,81,33),(901,82,33),(903,85,33),(906,84,33),(907,86,33),(908,87,33),(909,88,33),(910,90,33),(911,90,38),(912,91,33),(913,91,38),(916,93,39),(919,94,33),(920,94,39),(925,95,40),(926,95,41),(929,92,30),(930,92,33),(931,92,38),(932,97,41),(933,98,42),(934,99,35),(935,99,36),(936,100,34),(937,100,35),(938,101,35),(939,101,36),(940,101,43),(943,102,37),(944,103,36),(945,103,41),(946,104,36),(947,104,44),(948,105,44),(949,106,33),(950,106,36),(951,107,44),(952,108,44),(953,109,36),(954,109,44),(955,110,41),(957,111,41),(958,112,33),(959,113,33),(960,114,33),(961,115,39),(962,116,35),(963,117,33),(967,119,44),(968,120,33),(972,122,40),(974,123,44),(975,124,44),(976,125,45),(977,125,46),(979,126,47),(981,127,47),(982,128,47),(983,129,47),(984,130,47),(986,131,47),(988,56,30),(989,118,33),(990,121,30),(991,121,33),(992,121,38),(993,132,47),(998,137,48),(999,137,49),(1000,137,50),(1001,137,51),(1008,138,52),(1009,138,53),(1010,138,54),(1011,138,55),(1012,138,56),(1013,138,57);
/*!40000 ALTER TABLE `tb_article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_category`
--

DROP TABLE IF EXISTS `tb_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_category` (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=203 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_category`
--

LOCK TABLES `tb_category` WRITE;
/*!40000 ALTER TABLE `tb_category` DISABLE KEYS */;
INSERT INTO `tb_category` VALUES (188,'项目总结','2022-02-20 21:29:03','2022-03-06 00:50:45'),(189,'Java后端','2022-03-06 00:50:22','2022-05-23 22:50:32'),(191,'Bug记录','2022-03-06 00:50:58','2022-05-23 22:50:51'),(192,'大学生活','2022-03-06 00:51:07',NULL),(194,'Java面经','2022-03-31 01:55:26','2022-05-23 22:48:58'),(195,'数据结构算法','2022-04-17 02:44:29',NULL),(197,'MySQL','2022-07-07 21:54:01',NULL),(198,'代码片段','2024-01-29 11:34:19',NULL),(199,'设计模式','2024-01-29 15:46:28',NULL),(202,'其他','2024-04-18 00:06:22','2024-04-18 00:06:22');
/*!40000 ALTER TABLE `tb_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_chat_record`
--

DROP TABLE IF EXISTS `tb_chat_record`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_chat_record` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int DEFAULT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `content` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '聊天内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip地址',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'ip来源',
  `type` tinyint NOT NULL COMMENT '类型',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3015 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_chat_record`
--

LOCK TABLES `tb_chat_record` WRITE;
/*!40000 ALTER TABLE `tb_chat_record` DISABLE KEYS */;
INSERT INTO `tb_chat_record` VALUES (2991,1006,'用户1494523322402181121','https://static.talkxj.com/config/2cd793c8744199053323546875655f32.jpg','<img src= \'https://static.talkxj.com/emoji/smile.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','36.23.157.65','浙江省杭州市 电信',3,'2022-02-18 12:05:17',NULL),(2992,NULL,'117.175.17.217','https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png','hhh','117.175.17.217','四川省绵阳市 移动',3,'2022-02-18 14:42:54',NULL),(2993,NULL,'14.16.149.110','https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png','所得西内','14.16.149.110','广东省广州市 电信',3,'2022-02-18 14:44:26',NULL),(2994,NULL,'39.144.193.152','https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png','真不错','39.144.193.152','中国 移动',3,'2022-02-18 14:55:41',NULL),(2995,NULL,'43.250.201.122','https://static.talkxj.com/photos/0bca52afdb2b9998132355d716390c9f.png','hello','43.250.201.122','湖南省长沙市 联通',3,'2022-03-01 04:04:52',NULL),(2996,NULL,'58.20.30.140','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','哦买噶','58.20.30.140','湖南省长沙市 联通',3,'2022-04-19 01:27:16',NULL),(2997,NULL,'58.20.30.140','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'https://static.talkxj.com/emoji/zhichi.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','58.20.30.140','湖南省长沙市 联通',3,'2022-04-27 14:52:04',NULL),(2998,NULL,'43.250.201.95','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','哈哈哈','43.250.201.95','湖南省长沙市 联通',3,'2022-05-13 12:19:53',NULL),(2999,NULL,'58.20.30.140','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'https://static.talkxj.com/emoji/tiaopi.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','58.20.30.140','湖南省长沙市 联通',3,'2022-05-21 14:20:12',NULL),(3000,NULL,'27.39.88.171','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'https://static.talkxj.com/emoji/wulian.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','27.39.88.171','广东省东莞市 联通',3,'2022-06-07 13:21:39',NULL),(3001,NULL,'122.245.120.129','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'https://static.talkxj.com/emoji/yh.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','122.245.120.129','浙江省宁波市 电信',3,'2022-07-07 16:48:40',NULL),(3002,NULL,'106.41.247.168','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','这个博客是用什么搭的啊？','106.41.247.168','吉林省长春市 电信',3,'2022-07-21 23:10:49',NULL),(3003,1015,'Pik-W','http://thirdqq.qlogo.cn/g?b=oidb&k=KVk3Lydlfe8Jlcb1Myr3sw&s=40&t=1658564407','<img src= \'https://static.talkxj.com/emoji/tiaopi.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','118.251.251.3','湖南省湘潭市 电信',3,'2022-08-10 16:44:52',NULL),(3004,NULL,'116.162.93.171','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','111','116.162.93.171','湖南省 联通',3,'2023-12-18 13:49:39',NULL),(3005,NULL,'223.104.132.21','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','进货价多少','223.104.132.21','湖南省 移动',3,'2023-12-18 14:24:32',NULL),(3006,NULL,'223.104.132.21','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','终止交易','223.104.132.21','湖南省 移动',3,'2023-12-18 14:24:46',NULL),(3007,NULL,'223.104.132.21','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'https://static.talkxj.com/emoji/aixin.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','223.104.132.21','湖南省 移动',3,'2023-12-18 14:24:49',NULL),(3008,NULL,'116.162.93.171','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','有内鬼，交易取消','116.162.93.171','湖南省 联通',3,'2023-12-18 14:24:51',NULL),(3009,1017,'。。。。','http://thirdqq.qlogo.cn/g?b=oidb&k=GSXwupYWzwoFwRrwbfeaRg&kti=ZYGQfQAAAAI&s=40&t=1689214835','哈哈哈哈','119.39.248.27','湖南省长沙市 联通',3,'2023-12-19 20:46:22',NULL),(3010,1017,'。。。。','http://thirdqq.qlogo.cn/g?b=oidb&k=GSXwupYWzwoFwRrwbfeaRg&kti=ZYGQfQAAAAI&s=40&t=1689214835','<img src= \'https://static.talkxj.com/emoji/jingxi.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','119.39.248.27','湖南省长沙市 联通',3,'2023-12-19 20:46:29',NULL),(3011,1017,'。。。。','http://thirdqq.qlogo.cn/g?b=oidb&k=GSXwupYWzwoFwRrwbfeaRg&kti=ZYGQfQAAAAI&s=40&t=1689214835','2136***','119.39.248.27','湖南省长沙市 联通',3,'2023-12-19 20:46:37',NULL),(3012,NULL,'42.49.202.224','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','你好\n','42.49.202.224','湖南省张家界市 联通',3,'2023-12-26 01:45:13',NULL),(3013,NULL,'42.49.202.224','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'http://www.static.ica***.top/emoji/smile.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/><img src= \'http://www.static.ica***.top/emoji/smile.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','42.49.202.224','湖南省张家界市 联通',3,'2023-12-26 01:45:33',NULL),(3014,NULL,'42.49.202.224','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','<img src= \'http://www.static.ica***.top/emoji/jingxi.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>','42.49.202.224','湖南省张家界市 联通',3,'2023-12-26 01:45:43',NULL);
/*!40000 ALTER TABLE `tb_chat_record` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_comment`
--

DROP TABLE IF EXISTS `tb_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_comment` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '评论用户Id',
  `article_id` int DEFAULT NULL COMMENT '评论文章id',
  `talk_id` int DEFAULT NULL COMMENT '评论说说id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `reply_user_id` int DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int DEFAULT NULL COMMENT '父评论id',
  `type` tinyint NOT NULL COMMENT '评论类型 1.文章 2.友链 3.说说',
  `is_delete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除  0否 1是',
  `is_review` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `fk_comment_user` (`user_id`) USING BTREE,
  KEY `fk_comment_article` (`article_id`) USING BTREE,
  KEY `fk_comment_parent` (`parent_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=736 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_comment`
--

LOCK TABLES `tb_comment` WRITE;
/*!40000 ALTER TABLE `tb_comment` DISABLE KEYS */;
INSERT INTO `tb_comment` VALUES (722,1,54,NULL,'测试评论',NULL,NULL,1,0,1,'2022-01-24 23:34:25',NULL),(723,1,54,NULL,'测试回复',1,722,1,0,1,'2022-01-24 23:34:30',NULL),(724,1,NULL,49,'测试评论',NULL,NULL,3,0,1,'2022-01-24 23:35:25',NULL),(725,1005,54,NULL,'111',NULL,NULL,1,1,1,'2022-02-18 00:27:07','2024-03-28 09:51:12'),(726,1006,NULL,49,'中午好',NULL,NULL,3,1,1,'2022-02-18 12:05:05','2024-03-28 09:19:37'),(727,1008,56,NULL,'***',NULL,NULL,1,0,1,'2022-02-22 22:27:09',NULL),(728,1008,56,NULL,'666',NULL,NULL,1,0,1,'2022-02-22 22:27:18',NULL),(729,1009,56,NULL,'666',1008,728,1,0,1,'2022-02-23 14:34:08',NULL),(730,1010,115,NULL,'11111',NULL,NULL,1,0,1,'2022-10-11 20:59:03',NULL),(731,1010,115,NULL,'11111',1010,730,1,0,1,'2022-10-11 20:59:14',NULL),(732,1010,118,NULL,'1111',NULL,NULL,1,0,1,'2022-12-13 17:02:36',NULL),(733,1010,NULL,NULL,'名称：ica***のblog\n简介：一个博客网\n头像：http://ica***-blog.oss-cn-beijing.aliyun***.com/config/dde3c71e***2f112140ce6ec3797bbf27.jpg',NULL,NULL,2,0,1,'2023-12-26 01:10:05','2023-12-26 01:11:06'),(734,1010,NULL,49,'你好<img src= \'http://www.static.ica***.top/emoji/smile.jpg\' width=\'22\'height=\'20\' style=\'padding: 0 1px\'/><img src= \'http://www.static.ica***.top/emoji/smile.jpg\' width=\'22\'height=\'20\' style=\'padding: 0 1px\'/><img src= \'http://www.static.ica***.top/emoji/smile.jpg\' width=\'22\'height=\'20\' style=\'padding: 0 1px\'/>',NULL,NULL,3,0,1,'2023-12-26 01:46:13',NULL),(735,1010,118,NULL,'111<img src= \'http://www.static.icatw.top/emoji/smile.jpg\' width=\'24\'height=\'24\' style=\'margin: 0 1px;vertical-align: text-bottom\'/>',NULL,NULL,1,0,1,'2023-12-26 16:30:22',NULL);
/*!40000 ALTER TABLE `tb_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_friend_link`
--

DROP TABLE IF EXISTS `tb_friend_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_friend_link` (
  `id` int NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `fk_friend_link_user` (`link_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_friend_link`
--

LOCK TABLES `tb_friend_link` WRITE;
/*!40000 ALTER TABLE `tb_friend_link` DISABLE KEYS */;
INSERT INTO `tb_friend_link` VALUES (27,'icatwのblog','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/dde3c71e642f112140ce6ec3797bbf27.jpg','http://www.icatw.top','一个博客网','2023-12-26 01:14:34',NULL);
/*!40000 ALTER TABLE `tb_friend_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_menu`
--

DROP TABLE IF EXISTS `tb_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_menu` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单icon',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(1) NOT NULL COMMENT '排序',
  `parent_id` int DEFAULT NULL COMMENT '父id',
  `is_hidden` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=220 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_menu`
--

LOCK TABLES `tb_menu` WRITE;
/*!40000 ALTER TABLE `tb_menu` DISABLE KEYS */;
INSERT INTO `tb_menu` VALUES (1,'首页','/','/home/Home.vue','el-icon-myshouye','2021-01-26 17:06:51','2021-01-26 17:06:53',1,NULL,0),(2,'文章管理','/article-submenu','Layout','el-icon-mywenzhang-copy','2021-01-25 20:43:07','2021-01-25 20:43:09',2,NULL,0),(3,'消息管理','/message-submenu','Layout','el-icon-myxiaoxi','2021-01-25 20:44:17','2021-01-25 20:44:20',3,NULL,0),(4,'系统管理','/system-submenu','Layout','el-icon-myshezhi','2021-01-25 20:45:57','2021-01-25 20:45:59',5,NULL,0),(5,'个人中心','/setting','/setting/Setting.vue','el-icon-myuser','2021-01-26 17:22:38','2021-01-26 17:22:41',7,NULL,0),(6,'发布文章','/articles','/article/Article.vue','el-icon-myfabiaowenzhang','2021-01-26 14:30:48','2021-01-26 14:30:51',1,2,0),(7,'修改文章','/articles/*','/article/Article.vue','el-icon-myfabiaowenzhang','2021-01-26 14:31:32','2021-01-26 14:31:34',2,2,1),(8,'文章列表','/article-list','/article/ArticleList.vue','el-icon-mywenzhangliebiao','2021-01-26 14:32:13','2021-01-26 14:32:16',3,2,0),(9,'分类管理','/categories','/category/Category.vue','el-icon-myfenlei','2021-01-26 14:33:42','2021-01-26 14:33:43',4,2,0),(10,'标签管理','/tags','/tag/Tag.vue','el-icon-myicontag','2021-01-26 14:34:33','2021-01-26 14:34:36',5,2,0),(11,'评论管理','/comments','/comment/Comment.vue','el-icon-mypinglunzu','2021-01-26 14:35:31','2021-01-26 14:35:34',1,3,0),(12,'留言管理','/messages','/message/Message.vue','el-icon-myliuyan','2021-01-26 14:36:09','2021-01-26 14:36:13',2,3,0),(13,'用户列表','/users','/user/User.vue','el-icon-myyonghuliebiao','2021-01-26 14:38:09','2021-01-26 14:38:12',1,202,0),(14,'角色管理','/roles','/role/Role.vue','el-icon-myjiaoseliebiao','2021-01-26 14:39:01','2021-01-26 14:39:03',2,213,0),(15,'接口管理','/resources','/resource/Resource.vue','el-icon-myjiekouguanli','2021-01-26 14:40:14','2021-08-07 20:00:28',2,213,0),(16,'菜单管理','/menus','/menu/Menu.vue','el-icon-mycaidan','2021-01-26 14:40:54','2021-08-07 10:18:49',2,213,0),(17,'友链管理','/links','/friendLink/FriendLink.vue','el-icon-mydashujukeshihuaico-','2021-01-26 14:41:35','2021-01-26 14:41:37',3,4,0),(18,'关于我','/about','/about/About.vue','el-icon-myguanyuwo','2021-01-26 14:42:05','2021-01-26 14:42:10',4,4,0),(19,'日志管理','/log-submenu','Layout','el-icon-myguanyuwo','2021-01-31 21:33:56','2021-01-31 21:33:59',6,NULL,0),(20,'操作日志','/operation/log','/log/Operation.vue','el-icon-myguanyuwo','2021-01-31 15:53:21','2021-01-31 15:53:25',1,19,0),(201,'在线用户','/online/users','/user/Online.vue','el-icon-myyonghuliebiao','2021-02-05 14:59:51','2021-02-05 14:59:53',7,202,0),(202,'用户管理','/users-submenu','Layout','el-icon-myyonghuliebiao','2021-02-06 23:44:59','2021-02-06 23:45:03',4,NULL,0),(205,'相册管理','/album-submenu','Layout','el-icon-myimage-fill','2021-08-03 15:10:54','2021-08-07 20:02:06',5,NULL,0),(206,'相册列表','/albums','/album/Album.vue','el-icon-myzhaopian','2021-08-03 20:29:19','2021-08-04 11:45:47',1,205,0),(208,'照片管理','/albums/:albumId','/album/Photo.vue','el-icon-myzhaopian','2021-08-03 21:37:47','2021-08-05 10:24:08',1,205,1),(209,'页面管理','/pages','/page/Page.vue','el-icon-myyemianpeizhi','2021-08-04 11:36:27','2021-08-07 20:01:26',2,4,0),(210,'照片回收站','/photos/delete','/album/Delete.vue','el-icon-myhuishouzhan','2021-08-05 13:55:19',NULL,3,205,1),(213,'权限管理','/permission-submenu','Layout','el-icon-mydaohanglantubiao_quanxianguanli','2021-08-07 19:56:55','2021-08-07 19:59:40',4,NULL,0),(214,'网站管理','/website','/website/Website.vue','el-icon-myxitong','2021-08-07 20:06:41',NULL,1,4,0),(215,'说说管理','/talk-submenu','Layout','el-icon-mypinglun','2022-01-23 20:17:59','2022-01-23 20:38:06',5,NULL,0),(216,'发布说说','/talks','/talk/Talk.vue','el-icon-myfabusekuai','2022-01-23 20:18:43','2022-01-23 20:38:19',1,215,0),(217,'说说列表','/talk-list','/talk/TalkList.vue','el-icon-myiconfontdongtaidianji','2022-01-23 23:28:24','2022-01-24 00:02:48',2,215,0),(218,'修改说说','/talks/:talkId','/talk/Talk.vue','el-icon-myshouye','2022-01-24 00:10:44',NULL,3,215,1),(219,'三方登录','/oauth','/oauth/Oauth.vue','el-icon-myyonghuliebiao','2024-04-16 15:52:12','2024-04-16 15:54:16',1,4,0);
/*!40000 ALTER TABLE `tb_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_message`
--

DROP TABLE IF EXISTS `tb_message`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_message` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '头像',
  `message_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '留言内容',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户地址',
  `time` tinyint(1) DEFAULT NULL COMMENT '弹幕速度',
  `is_review` tinyint NOT NULL DEFAULT '1' COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '发布时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3969 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_message`
--

LOCK TABLES `tb_message` WRITE;
/*!40000 ALTER TABLE `tb_message` DISABLE KEYS */;
INSERT INTO `tb_message` VALUES (3938,'管理员','https://static.talkxj.com/avatar/user.png','测试留言','127.0.0.1','',9,1,'2022-01-24 23:34:41',NULL),(3939,'用户1494566402916454401','https://static.talkxj.com/config/2cd793c8744199053323546875655f32.jpg','有bug 注册登录之后 像开了两个播放器一样 一个继续唱一个重头唱','114.84.145.222','上海市 电信',7,1,'2022-02-18 14:57:49',NULL),(3940,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','66','182.149.79.37','四川省成都市 电信',7,1,'2022-04-13 22:45:13',NULL),(3941,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','666666','182.149.79.37','四川省成都市 电信',7,1,'2022-04-13 22:47:44',NULL),(3942,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','前端用的什么???大佬','125.70.178.251','四川省成都市 电信',8,1,'2022-04-13 22:48:27','2022-04-27 15:41:16'),(3943,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','123','210.45.209.249','安徽省合肥市 教育网',8,1,'2022-04-22 16:22:38',NULL),(3944,'借','http://thirdqq.qlogo.cn/g?b=oidb&k=michJ0m3WHa0jK4MZjbfIrQ&s=40&t=1631596260','111111111111测试1留言','58.20.30.140','湖南省长沙市 联通',9,1,'2022-12-13 17:04:01',NULL),(3945,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','抖音刷到你简历了，滑稽','39.144.137.211','中国 移动',7,1,'2023-01-10 15:00:55',NULL),(3946,'。。。。','http://thirdqq.qlogo.cn/g?b=oidb&k=GSXwupYWzwoFwRrwbfeaRg&kti=ZYGQfQAAAAI&s=40&t=1689214835','加油','119.39.248.27','湖南省长沙市 联通',8,1,'2023-12-19 20:47:24',NULL),(3947,'。。。。','http://thirdqq.qlogo.cn/g?b=oidb&k=GSXwupYWzwoFwRrwbfeaRg&kti=ZYGQfQAAAAI&s=40&t=1689214835','尽快更新','119.39.248.27','湖南省长沙市 联通',7,1,'2023-12-19 20:47:38',NULL),(3948,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','**','127.0.0.1','',7,1,'2024-04-15 01:05:47','2024-04-15 01:05:47'),(3949,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言22','127.0.0.1','',9,1,'2024-04-15 02:12:49','2024-04-15 02:12:49'),(3950,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言33','127.0.0.1','',8,1,'2024-04-15 02:12:49','2024-04-15 02:12:49'),(3951,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','测试留言限制11','127.0.0.1','',7,1,'2024-04-15 02:12:49','2024-04-15 02:12:49'),(3952,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言44','127.0.0.1','',7,1,'2024-04-15 02:13:47','2024-04-15 02:13:47'),(3953,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言55','127.0.0.1','',9,1,'2024-04-15 02:13:47','2024-04-15 02:13:47'),(3954,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言666','127.0.0.1','',8,1,'2024-04-15 02:14:02','2024-04-15 02:14:02'),(3955,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言777','127.0.0.1','',8,1,'2024-04-15 02:14:10','2024-04-15 02:14:10'),(3956,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','添加留言888','127.0.0.1','',9,1,'2024-04-15 02:14:17','2024-04-15 02:14:17'),(3957,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','1000','127.0.0.1','',8,1,'2024-04-15 02:14:52','2024-04-15 02:14:52'),(3958,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','111','127.0.0.1','',8,1,'2024-04-15 02:14:56','2024-04-15 02:14:56'),(3959,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','11','127.0.0.1','',7,1,'2024-04-15 02:16:21','2024-04-15 02:16:21'),(3960,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','222','127.0.0.1','',8,1,'2024-04-15 02:16:23','2024-04-15 02:16:23'),(3961,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','333','127.0.0.1','',7,1,'2024-04-15 02:16:24','2024-04-15 02:16:24'),(3962,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','333','127.0.0.1','',9,1,'2024-04-15 02:16:25','2024-04-15 02:16:25'),(3963,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','333','127.0.0.1','',9,1,'2024-04-15 02:16:25','2024-04-15 02:16:25'),(3964,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','111','127.0.0.1','',8,1,'2024-04-15 02:17:33','2024-04-15 02:17:33'),(3965,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','222','127.0.0.1','',9,1,'2024-04-15 02:17:34','2024-04-15 02:17:34'),(3966,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','222','127.0.0.1','',8,1,'2024-04-15 02:17:35','2024-04-15 02:17:35'),(3967,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','3333','127.0.0.1','',7,1,'2024-04-15 02:17:37','2024-04-15 02:17:37'),(3968,'游客','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png','333','127.0.0.1','',9,1,'2024-04-15 02:17:37','2024-04-15 02:17:37');
/*!40000 ALTER TABLE `tb_message` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_oauth_config`
--

DROP TABLE IF EXISTS `tb_oauth_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_oauth_config` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `client_id` varchar(64) DEFAULT NULL COMMENT 'client_id',
  `type` tinyint DEFAULT NULL COMMENT '三方登录type',
  `oauth_name` varchar(10) DEFAULT NULL COMMENT '三方名',
  `client_secret` varchar(64) DEFAULT NULL COMMENT 'client_secret',
  `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT NULL COMMENT '修改时间',
  `is_disable` tinyint DEFAULT '0' COMMENT '是否禁用0启用，1禁用',
  `app_name` varchar(32) DEFAULT NULL COMMENT '第三方应用名',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='三方登录配置表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_oauth_config`
--

LOCK TABLES `tb_oauth_config` WRITE;
/*!40000 ALTER TABLE `tb_oauth_config` DISABLE KEYS */;
INSERT INTO `tb_oauth_config` VALUES (2,'11',2,'qq','111','2024-04-16 11:17:15','2024-04-16 13:27:25',1,'测试QQ应用1'),(3,'0ec57074c8cb9a72d306aa0d54d33a5aa086af7cb3b0d0bb026b10bf3a27aca5',4,'gitee','79e21c2b3ab41c258d7a67cfe5a32fed99094597da754544ac5c0dca20b0711e','2024-04-16 12:45:31','2024-04-16 12:45:31',0,'gitee登录'),(4,'8310050a2b95902b2360',5,'github','5aefb667c83e59c3cf4ecc7e7bbd813c0878666e','2024-04-16 13:32:16','2024-04-16 13:32:16',0,'github登录');
/*!40000 ALTER TABLE `tb_oauth_config` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_operation_log`
--

DROP TABLE IF EXISTS `tb_operation_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_operation_log` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `opt_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1304 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_operation_log`
--

LOCK TABLES `tb_operation_log` WRITE;
/*!40000 ALTER TABLE `tb_operation_log` DISABLE KEYS */;
INSERT INTO `tb_operation_log` VALUES (1083,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"恭喜你成功运行博客，开启你的文章之旅吧。\",\"articleCover\":\"https://static.talkxj.com/articles/3dffb2fcbd541886616ab54c92570de3.jpg\",\"articleTitle\":\"测试文章\",\"categoryName\":\"测试分类\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"测试标签\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'管理员','127.0.0.1','','2022-01-24 23:33:57',NULL),(1084,'友链模块','删除','/admin/links','com.minzheng.blog.controller.FriendLinkController.deleteFriendLink','删除友链','[[26]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'管理员','175.5.32.27','湖南省永州市 电信','2022-02-18 01:52:51',NULL),(1085,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"hello world\",\"articleCover\":\"https://static.talkxj.com/articles/3dffb2fcbd541886616ab54c92570de3.jpg\",\"articleTitle\":\"测试文章\",\"categoryName\":\"测试分类\",\"id\":54,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.32.27','湖南省永州市 电信','2022-02-18 02:27:20',NULL),(1086,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"hello world\",\"articleCover\":\"https://static.talkxj.com/articles/3dffb2fcbd541886616ab54c92570de3.jpg\",\"articleTitle\":\"测试文章\",\"categoryName\":\"测试分类\",\"id\":54,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.32.27','湖南省永州市 电信','2022-02-18 02:27:40',NULL),(1087,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[54],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.32.27','湖南省永州市 电信','2022-02-18 02:27:48',NULL),(1088,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"hello world\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg\",\"articleTitle\":\"2022-02-18\",\"categoryName\":\"测试分类\",\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.32.27','湖南省永州市 电信','2022-02-18 02:28:27',NULL),(1089,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"::: hljs-center\\n\\n## 尚医通项目总结\\n\\n:::\\n# 模块说明\\n#### yygh_parent：根目录，管理子模块\\n##### common：公共模块父节点\\n###### common-util：工具类模块，所有模块都可以依赖于它\\n###### rabbit-util：rabbitmq业务封装\\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\\n##### hospital-manage：医院接口模拟端\\n##### model：实体类模块\\n##### server-gateway：服务网关\\n##### service：api接口服务父节点\\n###### service-cmn：字典api接口服务\\n###### service-hosp：医院api接口服务\\n###### service-order：订单api接口服务\\n###### service-oss：文件存储api接口服务\\n###### service-sms：短信api接口服务\\n###### service-statistics：统计api接口服务\\n###### service-task：定时任务服务\\n###### service-user：用户api接口服务\\n##### service-client：feign服务调用父节点\\n###### service-cmn-client：字典api接口\\n###### service-hosp-client：医院api接口\\n###### service-order-client：订单api接口\\n###### service-user-client：用户api接口\\n#### sql：项目涉及的sql文件\\n\\n# 1、项目介绍\\n> 段落引用尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\\n# 2、技术点\\n #### 后端:\\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\\n3. MyBatis-Plus：持久层框架\\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\\n6. EasyExcel：操作excel表格，进行行读写操作\\n7. RabbitMQ：消息中间件（订单相关操作）\\n8. HTTPClient: Http协议客户端\\n9. Nginx：负载均衡\\n10. Mysql：关系型数据库\\n11. \\n#### 前端：\\n1. Vue.js：web 界面的渐进式框架\\n2. Node.js： JavaScript 运行环境\\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\\n4. NPM：包管理器\\n5. Babel：转码器\\n6. Webpack：打包工具\\n7. ECharts：图表展示\\n#### 其他:\\n1. Lombok\\n2. Swagger2：Api接口文档工具\\n3. Docker ：容器技术\\n4. Git：代码管理工具\\n5. 阿里云oss\\n6. 阿里云短信服务\\n7. 微信登录、支付\\n8. 定时任务\\n# 3、业务流程\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\\n\\n# 4、微服务架构\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\\n\\n# 5、git地址\\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png\",\"articleTitle\":\"2022-02-20\",\"categoryName\":\"项目\",\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"项目\",\"总结\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-20 21:29:03',NULL),(1090,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"::: hljs-center\\n\\n## 尚医通项目总结\\n\\n:::\\n# 模块说明\\n#### yygh_parent：根目录，管理子模块\\n##### common：公共模块父节点\\n###### common-util：工具类模块，所有模块都可以依赖于它\\n###### rabbit-util：rabbitmq业务封装\\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\\n##### hospital-manage：医院接口模拟端\\n##### model：实体类模块\\n##### server-gateway：服务网关\\n##### service：api接口服务父节点\\n###### service-cmn：字典api接口服务\\n###### service-hosp：医院api接口服务\\n###### service-order：订单api接口服务\\n###### service-oss：文件存储api接口服务\\n###### service-sms：短信api接口服务\\n###### service-statistics：统计api接口服务\\n###### service-task：定时任务服务\\n###### service-user：用户api接口服务\\n##### service-client：feign服务调用父节点\\n###### service-cmn-client：字典api接口\\n###### service-hosp-client：医院api接口\\n###### service-order-client：订单api接口\\n###### service-user-client：用户api接口\\n#### sql：项目涉及的sql文件\\n\\n# 1、项目介绍\\n> 段落引用尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\\n# 2、技术点\\n #### 后端:\\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\\n3. MyBatis-Plus：持久层框架\\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\\n6. EasyExcel：操作excel表格，进行行读写操作\\n7. RabbitMQ：消息中间件（订单相关操作）\\n8. HTTPClient: Http协议客户端\\n9. Nginx：负载均衡\\n10. Mysql：关系型数据库\\n11. \\n#### 前端：\\n1. Vue.js：web 界面的渐进式框架\\n2. Node.js： JavaScript 运行环境\\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\\n4. NPM：包管理器\\n5. Babel：转码器\\n6. Webpack：打包工具\\n7. ECharts：图表展示\\n#### 其他:\\n1. Lombok\\n2. Swagger2：Api接口文档工具\\n3. Docker ：容器技术\\n4. Git：代码管理工具\\n5. 阿里云oss\\n6. 阿里云短信服务\\n7. 微信登录、支付\\n8. 定时任务\\n# 3、业务流程\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\\n\\n# 4、微服务架构\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\\n\\n# 5、git地址\\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png\",\"articleTitle\":\"尚医通项目总结\",\"categoryName\":\"项目\",\"id\":56,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-20 21:30:29',NULL),(1091,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":1,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/88bfb372ca678d63f9696ecf1ddbf1b1.jpg\",\"pageLabel\":\"home\",\"pageName\":\"首页\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:08:38',NULL),(1092,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":2,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/33899742b51a6553d34effa18c6aef8f.jpg\",\"pageLabel\":\"archive\",\"pageName\":\"归档\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:11:35',NULL),(1093,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":1,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/c36646b6effe06ccfe2727f1603ec692.jpg\",\"pageLabel\":\"home\",\"pageName\":\"首页\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:23:02',NULL),(1094,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":2,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/db7779cffcdac02828fa7dedd6833d1c.jpg\",\"pageLabel\":\"archive\",\"pageName\":\"归档\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:23:28',NULL),(1095,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":3,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/2904b329e08607f13e50d22582c9716d.jpg\",\"pageLabel\":\"category\",\"pageName\":\"分类\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:23:40',NULL),(1096,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":4,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/458219609a7e9f5579d8ba87c7d65d5c.jpg\",\"pageLabel\":\"tag\",\"pageName\":\"标签\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:23:58',NULL),(1097,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":5,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/93fecbb5ce7e9f907d1895ce2914d1e2.jpg\",\"pageLabel\":\"album\",\"pageName\":\"相册\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:24:11',NULL),(1098,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":6,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/02e0b77f5d157dff5bc7b912fa173113.jpg\",\"pageLabel\":\"link\",\"pageName\":\"友链\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:24:24',NULL),(1099,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":7,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/df9c1307704f20ebaf55d7a0ffffe126.jpg\",\"pageLabel\":\"about\",\"pageName\":\"关于\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:24:38',NULL),(1100,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":8,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/db7779cffcdac02828fa7dedd6833d1c.jpg\",\"pageLabel\":\"message\",\"pageName\":\"留言\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:25:06',NULL),(1101,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":8,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/88b67fe99351c59bca1635e02bbc1683.jpg\",\"pageLabel\":\"message\",\"pageName\":\"留言\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:25:15',NULL),(1102,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":9,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/eff6141712fb3af80d00595a19d9d5e0.jpg\",\"pageLabel\":\"user\",\"pageName\":\"个人中心\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:25:37',NULL),(1103,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":10,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/d8afa7b4d72f0765e8a1cae491582411.jpg\",\"pageLabel\":\"articleList\",\"pageName\":\"文章列表\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:25:48',NULL),(1104,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":904,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/02e0b77f5d157dff5bc7b912fa173113.jpg\",\"pageLabel\":\"talk\",\"pageName\":\"说说\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:25:58',NULL),(1105,'页面模块','新增或修改','/admin/pages','com.minzheng.blog.controller.PageController.saveOrUpdatePage','保存或更新页面','[{\"id\":904,\"pageCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/b6ca16c4768b3e963997131f64e49b63.jpg\",\"pageLabel\":\"talk\",\"pageName\":\"说说\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:28:57',NULL),(1106,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"::: hljs-center\\n\\n**梦想是做一个浪漫的程序员~**\\n\\n:::\\n\\nq:762188827\\ngitee：[gitee](https://gitee.com/icatw)\\nGitHub：[GitHub](https://github.com/icatw)\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:37:45',NULL),(1107,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"\\n\\n**梦想是做一个浪漫的程序员~**\\n\\n\\n\\nq:762188827\\ngitee：[gitee](https://gitee.com/icatw)\\nGitHub：[GitHub](https://github.com/icatw)\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-02-28 23:39:16',NULL),(1108,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# <center> **花花世界博客总结**</center>\\n# 一、项目背景\\n基于大二下期开学前两周的javaweb实训而开发的博客项目\\n# 二、技术架构\\n## 项目总体采用主流的springboot+vue前后端分离开发\\n### 后端技术：\\n1. springboot+mybatis-plus作为快速开发\\n2. 采用redis缓存用户信息以及文章信息，加快网站响应速度\\n3. 集成spring security作为后台权限控制以及用户认证\\n4. lombok 小辣椒用于简化bean开发\\n5. 阿里云oss，存储文章图片\\n6. jwt+redis，使用token令牌的登陆方式，加快访问认证速度\\n7. ThreadLocal 本地线程池保存用户信息\\n由于博客比较简洁故使用单体架构减少开发成本\\n# 三、开发环境\\n- Maven\\n- Idea 2021.3\\n- Mysql8.0+Navicat\\n- VS Code\\n- 谷歌浏览器\\n# 四、项目截图\\n1.前台结构\\n![博客前台后端结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f4af97d2cf7284b7f21605ed0b9c23e6.png)\\n2.后台管理系统结构\\n![后台管理系统结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b57b63451dbd35a63e2b96886d2a4f13.png)\\n3.博客首页\\n![博客首页.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/deeed83ae27fbb65b10eeca90edbb0f4.png)\\n4.后台管理系统\\n![后台管理系统页面.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/498bf5709c2289cbb29ceb69c1ccf9e8.png)\\n5.数据库结构\\n![数据库.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/41631d4e88bf8d0b502a7bbf1c15aee5.png)\\n# 五、项目功能\\n发表文章、评论、登录注册、音乐播放器\\n（音乐播放器从凌晨两点肝到了凌晨四点从肝出来）\\n# 六、项目源码\\ngitee地址：[gitee](https://gitee.com/icatw/blog-parent)\\nGitHub地址：[GitHub](https://github.com/icatw/blog-parent)\\n欢迎star！\\n# 七、个人总结\\n### 1、锻炼了团队协作能力\\n### 2、学习了spring security的使用，了解了权限认证流程\\n### 3、加强了开发能力，对springboot+mp的使用更为熟练（虽然但是，技术上还是有很大的差距，熟练度有待加强，还是要多做项目多练手）\\n### 4、了解了jwt+redis作为缓存用户登陆信息的使用\\n### 5、再次感谢花花世界团队~\\n# 很高兴你能看到这里 谢谢！\\n# 大二学期的java课程就告一段落啦！\\n最后 在此立个小flag \\n- 早睡早起\\n- 早日完成谷粒商城\\n- 多敲代码多总结多思考\\n\\n很喜欢老师说的一句话：“只要在敲代码就是进步”\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/399f7c02ac3ca36bd18fe67de0fada06.png\",\"articleTitle\":\"花花世界博客总结\",\"categoryName\":\"项目\",\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"大学生活\",\"springboot\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:49:33',NULL),(1109,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"学习记录\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:50:23',NULL),(1110,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"项目总结\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:50:31',NULL),(1111,'分类模块','删除','/admin/categories','com.minzheng.blog.controller.CategoryController.deleteCategories','删除分类','[[190]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:50:40',NULL),(1112,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"项目总结\",\"id\":188}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:50:45',NULL),(1113,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"各种bug\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:50:58',NULL),(1114,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"大学生活\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:51:07',NULL),(1115,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[55],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:51:56',NULL),(1116,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# <center> **花花世界博客总结**</center>\\n# 一、项目背景\\n基于大二下期开学前两周的javaweb实训而开发的博客项目\\n# 二、技术架构\\n## 项目总体采用主流的springboot+vue前后端分离开发\\n### 后端技术：\\n1. springboot+mybatis-plus作为快速开发\\n2. 采用redis缓存用户信息以及文章信息，加快网站响应速度\\n3. 集成spring security作为后台权限控制以及用户认证\\n4. lombok 小辣椒用于简化bean开发\\n5. 阿里云oss，存储文章图片\\n6. jwt+redis，使用token令牌的登陆方式，加快访问认证速度\\n7. ThreadLocal 本地线程池保存用户信息\\n由于博客比较简洁故使用单体架构减少开发成本\\n# 三、开发环境\\n- Maven\\n- Idea 2021.3\\n- Mysql8.0+Navicat\\n- VS Code\\n- 谷歌浏览器\\n# 四、项目截图\\n1.前台结构\\n![博客前台后端结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f4af97d2cf7284b7f21605ed0b9c23e6.png)\\n2.后台管理系统结构\\n![后台管理系统结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b57b63451dbd35a63e2b96886d2a4f13.png)\\n3.博客首页\\n![博客首页.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/deeed83ae27fbb65b10eeca90edbb0f4.png)\\n4.后台管理系统\\n![后台管理系统页面.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/498bf5709c2289cbb29ceb69c1ccf9e8.png)\\n5.数据库结构\\n![数据库.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/41631d4e88bf8d0b502a7bbf1c15aee5.png)\\n# 五、项目功能\\n发表文章、评论、登录注册、音乐播放器\\n（音乐播放器从凌晨两点肝到了凌晨四点从肝出来）\\n# 六、项目源码\\ngitee地址：[gitee](https://gitee.com/icatw/blog-parent)\\nGitHub地址：[GitHub](https://github.com/icatw/blog-parent)\\n欢迎star！\\n# 七、个人总结\\n### 1、锻炼了团队协作能力\\n### 2、学习了spring security的使用，了解了权限认证流程\\n### 3、加强了开发能力，对springboot+mp的使用更为熟练（虽然但是，技术上还是有很大的差距，熟练度有待加强，还是要多做项目多练手）\\n### 4、了解了jwt+redis作为缓存用户登陆信息的使用\\n### 5、再次感谢花花世界团队~\\n# 很高兴你能看到这里 谢谢！\\n# 大二学期的java课程就告一段落啦！\\n最后 在此立个小flag \\n- 早睡早起\\n- 早日完成谷粒商城\\n- 多敲代码多总结多思考\\n\\n很喜欢老师说的一句话：“只要在敲代码就是进步”\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/399f7c02ac3ca36bd18fe67de0fada06.png\",\"articleTitle\":\"花花世界博客总结\",\"categoryName\":\"项目总结\",\"id\":57,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:52:36',NULL),(1117,'文章模块','删除','/admin/articles','com.minzheng.blog.controller.ArticleController.deleteArticles','物理删除文章','[[55,54]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:52:59',NULL),(1118,'分类模块','删除','/admin/categories','com.minzheng.blog.controller.CategoryController.deleteCategories','删除分类','[[187]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:53:06',NULL),(1119,'标签模块','删除','/admin/tags','com.minzheng.blog.controller.TagController.deleteTag','删除标签','[[29]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 00:53:14',NULL),(1120,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"# <center>梦想是成为一个浪漫的程序员</center> #\\n### 个人简介\\n**编程小白**，一名就读于长沙的在校大二学生，软件技术专业，主修**java后端**\\n### 兴趣爱好:\\n- 喜欢钻研技术解决问题\\n- 编程，喜欢做出东西之后的**成就感**\\n- 听歌（尤其是**薛之谦**的歌)\\n- **猫猫狗狗**、花草树木以及一些可可爱爱的东西\\n### 联系方式：\\nQQ:**762188827**\\ngitee：**[gitee](https://gitee.com/icatw)**\\nGitHub：**[GitHub](https://github.com/icatw)**\\n欢迎与我交流~\\n**个人微信**：\\n![个人微信.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d729cb701da0db0f7146025c611ef332.png)\\n\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 01:12:25',NULL),(1121,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"# <center>梦想是成为一个浪漫的程序员</center> #\\n### 个人简介\\n**编程小白**，一名就读于长沙的在校大二学生，软件技术专业，主修**java后端**\\n### 兴趣爱好:\\n- 喜欢钻研技术解决问题\\n- 编程，喜欢做出东西之后的**成就感**\\n- 听歌（尤其是**薛之谦**的歌)\\n- **猫猫狗狗**、花草树木以及一些可可爱爱的东西\\n### 联系方式：\\nQQ:**762188827**\\n\\nGitee：**[Gitee](https://gitee.com/icatw)**\\n\\nGitHub：**[GitHub](https://github.com/icatw)**\\n\\n欢迎与我交流~\\n\\n**个人微信**：\\n![个人微信.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d729cb701da0db0f7146025c611ef332.png)\\n\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 01:16:02',NULL),(1122,'相册模块','新增或修改','/admin/photos/albums','com.minzheng.blog.controller.PhotoAlbumController.saveOrUpdatePhotoAlbum','保存或更新相册','[{\"albumCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/photos/b6ca16c4768b3e963997131f64e49b63.jpg\",\"albumDesc\":\"记录大学生活~\",\"albumName\":\"我的大学\",\"status\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 01:22:25',NULL),(1123,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# <center> **花花世界博客总结**</center>\\n# 一、项目背景\\n基于大二下期开学前两周的javaweb实训而开发的博客项目\\n# 二、技术架构\\n## 项目总体采用主流的springboot+vue前后端分离开发\\n### 后端技术：\\n1. springboot+mybatis-plus作为快速开发\\n2. 采用redis缓存用户信息以及文章信息，加快网站响应速度\\n3. 集成spring security作为后台权限控制以及用户认证\\n4. lombok 小辣椒用于简化bean开发\\n5. 阿里云oss，存储文章图片\\n6. jwt+redis，使用token令牌的登陆方式，加快访问认证速度\\n7. ThreadLocal 本地线程池保存用户信息\\n由于博客比较简洁故使用单体架构减少开发成本\\n# 三、开发环境\\n- Maven\\n- Idea 2021.3\\n- Mysql8.0+Navicat\\n- VS Code\\n- 谷歌浏览器\\n# 四、项目截图\\n1.前台结构\\n![博客前台后端结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f4af97d2cf7284b7f21605ed0b9c23e6.png)\\n2.后台管理系统结构\\n![后台管理系统结构.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b57b63451dbd35a63e2b96886d2a4f13.png)\\n3.博客首页\\n![博客首页.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/deeed83ae27fbb65b10eeca90edbb0f4.png)\\n4.后台管理系统\\n![后台管理系统页面.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/498bf5709c2289cbb29ceb69c1ccf9e8.png)\\n5.数据库结构\\n![数据库.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/41631d4e88bf8d0b502a7bbf1c15aee5.png)\\n# 五、项目功能\\n发表文章、评论、登录注册、音乐播放器\\n（音乐播放器从凌晨两点肝到了凌晨四点从肝出来）\\n# 六、项目源码\\n- gitee地址：\\n后端：[后端](https://gitee.com/icatw/blog-parent)\\n前端：[前端](https://gitee.com/icatw/blog-app)\\n\\n- GitHub地址：\\n后端：[后端](https://github.com/icatw/blog-parent)\\n前端：[前端](https://github.com/icatw/blog-app)\\n\\n欢迎star！\\n# 七、个人总结\\n### 1、锻炼了团队协作能力\\n### 2、学习了spring security的使用，了解了权限认证流程\\n### 3、加强了开发能力，对springboot+mp的使用更为熟练（虽然但是，技术上还是有很大的差距，熟练度有待加强，还是要多做项目多练手）\\n### 4、了解了jwt+redis作为缓存用户登陆信息的使用\\n### 5、再次感谢花花世界团队~\\n# 很高兴你能看到这里 谢谢！\\n# 大二学期的java课程就告一段落啦！\\n最后 在此立个小flag \\n- 早睡早起\\n- 早日完成谷粒商城\\n- 多敲代码多总结多思考\\n\\n很喜欢老师说的一句话：“只要在敲代码就是进步”\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/399f7c02ac3ca36bd18fe67de0fada06.png\",\"articleTitle\":\"花花世界博客总结\",\"categoryName\":\"项目总结\",\"id\":57,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 10:22:13',NULL),(1124,'文章模块','修改','/admin/articles/top','com.minzheng.blog.controller.ArticleController.updateArticleTop','修改文章置顶','[{\"id\":56,\"isTop\":0}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-06 10:22:20',NULL),(1125,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"设计模式\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-07 20:09:51',NULL),(1126,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>ThreadPoolExecutor线程池\\n## 一、线程池\\n### 1.为什么要使用线程池\\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\\n>阿里开发手册有一段描述：\\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\\n\\n简单的说就是把线程统一管理。\\n\\n#### 线程池优势：\\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\\n（4）提供更强大的功能，延时定时线程池。\\n### 2. 线程池分类\\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\\n### 3. 选择\\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\\n### 4. 总结\\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\\n***\\n## 二、ThreadPoolExecutor的7大参数\\n### （一）7大参数\\n#### 1. 构造方法源码\\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\\n```java\\npublic ThreadPoolExecutor(int corePoolSize,\\n                              int maximumPoolSize,\\n                              long keepAliveTime,\\n                              TimeUnit unit,\\n                              BlockingQueue<Runnable> workQueue,\\n                              ThreadFactory threadFactory,\\n                              RejectedExecutionHandler handler) {\\n        if (corePoolSize < 0 ||\\n            maximumPoolSize <= 0 ||\\n            maximumPoolSize < corePoolSize ||\\n            keepAliveTime < 0)\\n            throw new IllegalArgumentException();\\n        if (workQueue == null || threadFactory == null || handler == null)\\n            throw new NullPointerException();\\n        this.acc = System.getSecurityManager() == null ?\\n                null :\\n                AccessController.getContext();\\n        this.corePoolSize = corePoolSize;\\n        this.maximumPoolSize = maximumPoolSize;\\n        this.workQueue = workQueue;\\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\\n        this.threadFactory = threadFactory;\\n        this.handler = handler;\\n    }\\n```\\n#### 2. 官方注释\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\\n### （二）参数详解\\n#### 1. **corePoolSize 线程池核心线程大小**\\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\\n\\n#### 2. **maximumPoolSize 线程池最大线程数量**\\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\\n#### 3. **keepAliveTime 空闲线程存活时间**\\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\\n#### 4. **unit 空闲线程存活时间单位**\\nkeepAliveTime的计量单位\\n#### 5. **workQueue 工作队列**\\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\\n##### (1) ArrayBlockingQueue\\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\\n##### (2) LinkedBlockingQuene\\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\\n##### (3) SynchronousQuene\\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\\n##### (4) PriorityBlockingQueue\\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\\n#### 6. **threadFactory 线程工厂**\\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\\n7. **handler 拒绝策略**\\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\\n##### (1) CallerRunsPolicy\\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\\n##### (2) DiscardPolicy\\n该策略下，直接丢弃任务，什么都不做。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\\n##### (3) AbortPolicy\\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\\n\\n##### (4) DiscardOldestPolicy\\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\\n![image.png](7)\\n***\\n### 三、使用（基于springboot）\\n#### （一） 配置\\n##### 1. 自定义配置类\\n``` java\\n@Configuration\\npublic class MyThreadConfig {\\n    @Bean\\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\\n        return new ThreadPoolExecutor(pool.getCoreSize(),\\n                pool.getMaxSize(),\\n                pool.getKeepAliveTime(),\\n                TimeUnit.SECONDS,\\n                new LinkedBlockingDeque<>(100000),\\n                Executors.defaultThreadFactory(),\\n                new ThreadPoolExecutor.AbortPolicy());\\n    }\\n}\\n```\\n##### 2. 自定义配置文件类\\n``` java\\n@ConfigurationProperties(prefix = \\\"gulimall.thread\\\")\\n@Component\\n@Data\\npublic class ThreadPoolConfigProperties {\\n    private Integer coreSize;\\n    private Integer maxSize;\\n    private Integer keepAliveTime;\\n}\\n```\\n##### 3. 抽取配置文件application.properties\\n```\\n#线程池配置\\ngulimall.thread.core-size=20\\ngulimall.thread.max-size=200\\ngulimall.thread.keep-alive-time=10\\n```\\n#### （二） 实践\\n##### 1. bean自动注入\\n```java\\n @Autowired\\n    ThreadPoolExecutor executor;\\n```\\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\\n```java\\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\\n\\t\\t//异步线程任务1\\n                //1、远程查询当前要添加的商品的信息\\n                R skuInfo = productFeignService.getSkuInfo(skuId);\\n                SkuInfoVo data = skuInfo.getData(\\\"skuInfo\\\", new TypeReference<SkuInfoVo>() {\\n                });\\n                cartItemVo.setCheck(true);\\n                cartItemVo.setCount(num);\\n                cartItemVo.setImage(data.getSkuDefaultImg());\\n                cartItemVo.setTitle(data.getSkuTitle());\\n                cartItemVo.setPrice(data.getPrice());\\n                cartItemVo.setSkuId(skuId);\\n            }, executor);\\n```\\n***\\n```java\\n\\t//3、远程查询sku的组合信息\\n\\t//异步线程任务2\\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\\n            }, executor);\\n```\\n***\\n``` java\\n//异步编排，等待所有异步线程任务结束\\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\\n```\\n***\\n### 四、总结\\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\\n#### 1. 优点\\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\\n\\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\\n#### 2. 使用场景\\n**适用于高并发多线程场景**\\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\\n\",\"articleCover\":\"\",\"articleTitle\":\"java并发多线程，线程池【ThreadPoolExecutor】的使用\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:05:52',NULL),(1127,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>ThreadPoolExecutor线程池\\n## 一、线程池\\n### 1.为什么要使用线程池\\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\\n>阿里开发手册有一段描述：\\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\\n\\n简单的说就是把线程统一管理。\\n\\n#### 线程池优势：\\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\\n（4）提供更强大的功能，延时定时线程池。\\n### 2. 线程池分类\\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\\n### 3. 选择\\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\\n### 4. 总结\\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\\n***\\n## 二、ThreadPoolExecutor的7大参数\\n### （一）7大参数\\n#### 1. 构造方法源码\\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\\n```java\\npublic ThreadPoolExecutor(int corePoolSize,\\n                              int maximumPoolSize,\\n                              long keepAliveTime,\\n                              TimeUnit unit,\\n                              BlockingQueue<Runnable> workQueue,\\n                              ThreadFactory threadFactory,\\n                              RejectedExecutionHandler handler) {\\n        if (corePoolSize < 0 ||\\n            maximumPoolSize <= 0 ||\\n            maximumPoolSize < corePoolSize ||\\n            keepAliveTime < 0)\\n            throw new IllegalArgumentException();\\n        if (workQueue == null || threadFactory == null || handler == null)\\n            throw new NullPointerException();\\n        this.acc = System.getSecurityManager() == null ?\\n                null :\\n                AccessController.getContext();\\n        this.corePoolSize = corePoolSize;\\n        this.maximumPoolSize = maximumPoolSize;\\n        this.workQueue = workQueue;\\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\\n        this.threadFactory = threadFactory;\\n        this.handler = handler;\\n    }\\n```\\n#### 2. 官方注释\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\\n### （二）参数详解\\n#### 1. **corePoolSize 线程池核心线程大小**\\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\\n\\n#### 2. **maximumPoolSize 线程池最大线程数量**\\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\\n#### 3. **keepAliveTime 空闲线程存活时间**\\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\\n#### 4. **unit 空闲线程存活时间单位**\\nkeepAliveTime的计量单位\\n#### 5. **workQueue 工作队列**\\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\\n##### (1) ArrayBlockingQueue\\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\\n##### (2) LinkedBlockingQuene\\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\\n##### (3) SynchronousQuene\\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\\n##### (4) PriorityBlockingQueue\\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\\n#### 6. **threadFactory 线程工厂**\\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\\n7. **handler 拒绝策略**\\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\\n##### (1) CallerRunsPolicy\\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\\n##### (2) DiscardPolicy\\n该策略下，直接丢弃任务，什么都不做。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\\n##### (3) AbortPolicy\\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\\n\\n##### (4) DiscardOldestPolicy\\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\\n![image.png](7)\\n***\\n### 三、使用（基于springboot）\\n#### （一） 配置\\n##### 1. 自定义配置类\\n``` java\\n@Configuration\\npublic class MyThreadConfig {\\n    @Bean\\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\\n        return new ThreadPoolExecutor(pool.getCoreSize(),\\n                pool.getMaxSize(),\\n                pool.getKeepAliveTime(),\\n                TimeUnit.SECONDS,\\n                new LinkedBlockingDeque<>(100000),\\n                Executors.defaultThreadFactory(),\\n                new ThreadPoolExecutor.AbortPolicy());\\n    }\\n}\\n```\\n##### 2. 自定义配置文件类\\n``` java\\n@ConfigurationProperties(prefix = \\\"gulimall.thread\\\")\\n@Component\\n@Data\\npublic class ThreadPoolConfigProperties {\\n    private Integer coreSize;\\n    private Integer maxSize;\\n    private Integer keepAliveTime;\\n}\\n```\\n##### 3. 抽取配置文件application.properties\\n```\\n#线程池配置\\ngulimall.thread.core-size=20\\ngulimall.thread.max-size=200\\ngulimall.thread.keep-alive-time=10\\n```\\n#### （二） 实践\\n##### 1. bean自动注入\\n```java\\n @Autowired\\n    ThreadPoolExecutor executor;\\n```\\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\\n```java\\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\\n\\t\\t//异步线程任务1\\n                //1、远程查询当前要添加的商品的信息\\n                R skuInfo = productFeignService.getSkuInfo(skuId);\\n                SkuInfoVo data = skuInfo.getData(\\\"skuInfo\\\", new TypeReference<SkuInfoVo>() {\\n                });\\n                cartItemVo.setCheck(true);\\n                cartItemVo.setCount(num);\\n                cartItemVo.setImage(data.getSkuDefaultImg());\\n                cartItemVo.setTitle(data.getSkuTitle());\\n                cartItemVo.setPrice(data.getPrice());\\n                cartItemVo.setSkuId(skuId);\\n            }, executor);\\n```\\n***\\n```java\\n\\t//3、远程查询sku的组合信息\\n\\t//异步线程任务2\\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\\n            }, executor);\\n```\\n***\\n``` java\\n//异步编排，等待所有异步线程任务结束\\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\\n```\\n***\\n### 四、总结\\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\\n#### 1. 优点\\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\\n\\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\\n#### 2. 使用场景\\n**适用于高并发多线程场景**\\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f43c49ff7cf3506a528ac439a810e374.jpg\",\"articleTitle\":\"java并发多线程，线程池【ThreadPoolExecutor】的使用\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"多线程\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:10:48',NULL),(1128,'文章模块','修改','/admin/articles/top','com.minzheng.blog.controller.ArticleController.updateArticleTop','修改文章置顶','[{\"id\":57,\"isTop\":0}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:11:15',NULL),(1129,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>ThreadPoolExecutor线程池\\n## 一、线程池\\n### 1.为什么要使用线程池\\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\\n>阿里开发手册有一段描述：\\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\\n\\n简单的说就是把线程统一管理。\\n\\n#### 线程池优势：\\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\\n（4）提供更强大的功能，延时定时线程池。\\n### 2. 线程池分类\\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\\n### 3. 选择\\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\\n### 4. 总结\\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\\n***\\n## 二、ThreadPoolExecutor的7大参数\\n### （一）7大参数\\n#### 1. 构造方法源码\\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\\n```java\\npublic ThreadPoolExecutor(int corePoolSize,\\n                              int maximumPoolSize,\\n                              long keepAliveTime,\\n                              TimeUnit unit,\\n                              BlockingQueue<Runnable> workQueue,\\n                              ThreadFactory threadFactory,\\n                              RejectedExecutionHandler handler) {\\n        if (corePoolSize < 0 ||\\n            maximumPoolSize <= 0 ||\\n            maximumPoolSize < corePoolSize ||\\n            keepAliveTime < 0)\\n            throw new IllegalArgumentException();\\n        if (workQueue == null || threadFactory == null || handler == null)\\n            throw new NullPointerException();\\n        this.acc = System.getSecurityManager() == null ?\\n                null :\\n                AccessController.getContext();\\n        this.corePoolSize = corePoolSize;\\n        this.maximumPoolSize = maximumPoolSize;\\n        this.workQueue = workQueue;\\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\\n        this.threadFactory = threadFactory;\\n        this.handler = handler;\\n    }\\n```\\n#### 2. 官方注释\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\\n### （二）参数详解\\n#### 1. **corePoolSize 线程池核心线程大小**\\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\\n\\n#### 2. **maximumPoolSize 线程池最大线程数量**\\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\\n#### 3. **keepAliveTime 空闲线程存活时间**\\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\\n#### 4. **unit 空闲线程存活时间单位**\\nkeepAliveTime的计量单位\\n#### 5. **workQueue 工作队列**\\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\\n##### (1) ArrayBlockingQueue\\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\\n##### (2) LinkedBlockingQuene\\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\\n##### (3) SynchronousQuene\\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\\n##### (4) PriorityBlockingQueue\\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\\n#### 6. **threadFactory 线程工厂**\\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\\n7. **handler 拒绝策略**\\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\\n##### (1) CallerRunsPolicy\\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\\n##### (2) DiscardPolicy\\n该策略下，直接丢弃任务，什么都不做。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\\n##### (3) AbortPolicy\\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\\n\\n##### (4) DiscardOldestPolicy\\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\\n![image.png](7)\\n***\\n### 三、使用（基于springboot）\\n#### （一） 配置\\n##### 1. 自定义配置类\\n``` java\\n@Configuration\\npublic class MyThreadConfig {\\n    @Bean\\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\\n        return new ThreadPoolExecutor(pool.getCoreSize(),\\n                pool.getMaxSize(),\\n                pool.getKeepAliveTime(),\\n                TimeUnit.SECONDS,\\n                new LinkedBlockingDeque<>(100000),\\n                Executors.defaultThreadFactory(),\\n                new ThreadPoolExecutor.AbortPolicy());\\n    }\\n}\\n```\\n##### 2. 自定义配置文件类\\n``` java\\n@ConfigurationProperties(prefix = \\\"gulimall.thread\\\")\\n@Component\\n@Data\\npublic class ThreadPoolConfigProperties {\\n    private Integer coreSize;\\n    private Integer maxSize;\\n    private Integer keepAliveTime;\\n}\\n```\\n##### 3. 抽取配置文件application.properties\\n```\\n#线程池配置\\ngulimall.thread.core-size=20\\ngulimall.thread.max-size=200\\ngulimall.thread.keep-alive-time=10\\n```\\n#### （二） 实践\\n##### 1. bean自动注入\\n```java\\n @Autowired\\n    ThreadPoolExecutor executor;\\n```\\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\\n```java\\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\\n\\t\\t//异步线程任务1\\n                //1、远程查询当前要添加的商品的信息\\n                R skuInfo = productFeignService.getSkuInfo(skuId);\\n                SkuInfoVo data = skuInfo.getData(\\\"skuInfo\\\", new TypeReference<SkuInfoVo>() {\\n                });\\n                cartItemVo.setCheck(true);\\n                cartItemVo.setCount(num);\\n                cartItemVo.setImage(data.getSkuDefaultImg());\\n                cartItemVo.setTitle(data.getSkuTitle());\\n                cartItemVo.setPrice(data.getPrice());\\n                cartItemVo.setSkuId(skuId);\\n            }, executor);\\n```\\n***\\n```java\\n\\t//3、远程查询sku的组合信息\\n\\t//异步线程任务2\\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\\n            }, executor);\\n```\\n***\\n``` java\\n//异步编排，等待所有异步线程任务结束\\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\\n```\\n***\\n### 四、总结\\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\\n#### 1. 优点\\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\\n\\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\\n#### 2. 使用场景\\n**适用于高并发多线程场景**\\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f43c49ff7cf3506a528ac439a810e374.jpg\",\"articleTitle\":\"java高并发多线程，线程池【ThreadPoolExecutor】的使用\",\"categoryName\":\"学习记录\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:11:45',NULL),(1130,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>ThreadPoolExecutor线程池\\n## 一、线程池\\n### 1.为什么要使用线程池\\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\\n>阿里开发手册有一段描述：\\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\\n\\n简单的说就是把线程统一管理。\\n\\n#### 线程池优势：\\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\\n（4）提供更强大的功能，延时定时线程池。\\n### 2. 线程池分类\\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\\n### 3. 选择\\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\\n### 4. 总结\\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\\n***\\n## 二、ThreadPoolExecutor的7大参数\\n### （一）7大参数\\n#### 1. 构造方法源码\\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\\n```java\\npublic ThreadPoolExecutor(int corePoolSize,\\n                              int maximumPoolSize,\\n                              long keepAliveTime,\\n                              TimeUnit unit,\\n                              BlockingQueue<Runnable> workQueue,\\n                              ThreadFactory threadFactory,\\n                              RejectedExecutionHandler handler) {\\n        if (corePoolSize < 0 ||\\n            maximumPoolSize <= 0 ||\\n            maximumPoolSize < corePoolSize ||\\n            keepAliveTime < 0)\\n            throw new IllegalArgumentException();\\n        if (workQueue == null || threadFactory == null || handler == null)\\n            throw new NullPointerException();\\n        this.acc = System.getSecurityManager() == null ?\\n                null :\\n                AccessController.getContext();\\n        this.corePoolSize = corePoolSize;\\n        this.maximumPoolSize = maximumPoolSize;\\n        this.workQueue = workQueue;\\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\\n        this.threadFactory = threadFactory;\\n        this.handler = handler;\\n    }\\n```\\n#### 2. 官方注释\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\\n### （二）参数详解\\n#### 1. **corePoolSize 线程池核心线程大小**\\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\\n\\n#### 2. **maximumPoolSize 线程池最大线程数量**\\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\\n#### 3. **keepAliveTime 空闲线程存活时间**\\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\\n#### 4. **unit 空闲线程存活时间单位**\\nkeepAliveTime的计量单位\\n#### 5. **workQueue 工作队列**\\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\\n##### (1) ArrayBlockingQueue\\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\\n##### (2) LinkedBlockingQuene\\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\\n##### (3) SynchronousQuene\\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\\n##### (4) PriorityBlockingQueue\\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\\n#### 6. **threadFactory 线程工厂**\\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\\n7. **handler 拒绝策略**\\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\\n##### (1) CallerRunsPolicy\\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\\n##### (2) DiscardPolicy\\n该策略下，直接丢弃任务，什么都不做。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\\n##### (3) AbortPolicy\\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\\n\\n##### (4) DiscardOldestPolicy\\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bef4f09fe171e35c830b4647cabd460.png)\\n***\\n### 三、使用（基于springboot）\\n#### （一） 配置\\n##### 1. 自定义配置类\\n``` java\\n@Configuration\\npublic class MyThreadConfig {\\n    @Bean\\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\\n        return new ThreadPoolExecutor(pool.getCoreSize(),\\n                pool.getMaxSize(),\\n                pool.getKeepAliveTime(),\\n                TimeUnit.SECONDS,\\n                new LinkedBlockingDeque<>(100000),\\n                Executors.defaultThreadFactory(),\\n                new ThreadPoolExecutor.AbortPolicy());\\n    }\\n}\\n```\\n##### 2. 自定义配置文件类\\n``` java\\n@ConfigurationProperties(prefix = \\\"gulimall.thread\\\")\\n@Component\\n@Data\\npublic class ThreadPoolConfigProperties {\\n    private Integer coreSize;\\n    private Integer maxSize;\\n    private Integer keepAliveTime;\\n}\\n```\\n##### 3. 抽取配置文件application.properties\\n```\\n#线程池配置\\ngulimall.thread.core-size=20\\ngulimall.thread.max-size=200\\ngulimall.thread.keep-alive-time=10\\n```\\n#### （二） 实践\\n##### 1. bean自动注入\\n```java\\n @Autowired\\n    ThreadPoolExecutor executor;\\n```\\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\\n```java\\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\\n\\t\\t//异步线程任务1\\n                //1、远程查询当前要添加的商品的信息\\n                R skuInfo = productFeignService.getSkuInfo(skuId);\\n                SkuInfoVo data = skuInfo.getData(\\\"skuInfo\\\", new TypeReference<SkuInfoVo>() {\\n                });\\n                cartItemVo.setCheck(true);\\n                cartItemVo.setCount(num);\\n                cartItemVo.setImage(data.getSkuDefaultImg());\\n                cartItemVo.setTitle(data.getSkuTitle());\\n                cartItemVo.setPrice(data.getPrice());\\n                cartItemVo.setSkuId(skuId);\\n            }, executor);\\n```\\n***\\n```java\\n\\t//3、远程查询sku的组合信息\\n\\t//异步线程任务2\\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\\n            }, executor);\\n```\\n***\\n``` java\\n//异步编排，等待所有异步线程任务结束\\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\\n```\\n***\\n### 四、总结\\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\\n#### 1. 优点\\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\\n\\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\\n#### 2. 使用场景\\n**适用于高并发多线程场景**\\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f43c49ff7cf3506a528ac439a810e374.jpg\",\"articleTitle\":\"java高并发多线程，线程池【ThreadPoolExecutor】的使用\",\"categoryName\":\"学习记录\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:15:15',NULL),(1131,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>ThreadPoolExecutor线程池\\n## 一、线程池\\n### 1.为什么要使用线程池\\n<b>当我们需要实现并发、异步等操作时，可以使用线程池。</b>\\n>阿里开发手册有一段描述：\\n >>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\\n 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\\n\\n简单的说就是把线程统一管理。\\n\\n#### 线程池优势：\\n （1）降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；\\n（2）提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；\\n（3）方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。\\n（4）提供更强大的功能，延时定时线程池。\\n### 2. 线程池分类\\n&emsp;　在 Java 语言中，并发编程都是依靠线程池完成的，而线程池的创建方式又有很多，但从大的分类来说，线程池的创建总共分为两大类：手动方式使用 **ThreadPoolExecutor**创建线程池和使用 **Executors** 执行器自动创建线程池。\\n### 3. 选择\\n&emsp;　在<b>《阿里巴巴java开发手册》</b>中指出了<b>线程资源必须通过线程池提供</b>，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，<b>使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</b>\\n### 4. 总结\\n线程池的创建方式总共分为两大类：<b>手动使用 ThreadPoolExecutor 创建线程池</b>和<b>自动使用 Executors 执行器创建线程池</b>的方式。其中<b>使用 Executors 自动创建线程的方式，因为线程个数或者任务个数不可控，可能会导致内存溢出的风险，所以在创建线程池时，建议使用 ThreadPoolExecutor 的方式来创建。</b>\\n***\\n## 二、ThreadPoolExecutor的7大参数\\n### （一）7大参数\\n#### 1. 构造方法源码\\n通过阅读**ThreadPoolExecutor源码**会发现构造方法中有**7个参数**，分别是**corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。**\\n```java\\npublic ThreadPoolExecutor(int corePoolSize,\\n                              int maximumPoolSize,\\n                              long keepAliveTime,\\n                              TimeUnit unit,\\n                              BlockingQueue<Runnable> workQueue,\\n                              ThreadFactory threadFactory,\\n                              RejectedExecutionHandler handler) {\\n        if (corePoolSize < 0 ||\\n            maximumPoolSize <= 0 ||\\n            maximumPoolSize < corePoolSize ||\\n            keepAliveTime < 0)\\n            throw new IllegalArgumentException();\\n        if (workQueue == null || threadFactory == null || handler == null)\\n            throw new NullPointerException();\\n        this.acc = System.getSecurityManager() == null ?\\n                null :\\n                AccessController.getContext();\\n        this.corePoolSize = corePoolSize;\\n        this.maximumPoolSize = maximumPoolSize;\\n        this.workQueue = workQueue;\\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\\n        this.threadFactory = threadFactory;\\n        this.handler = handler;\\n    }\\n```\\n#### 2. 官方注释\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e85f55ed689605b20d19a0ce81ca99f6.png)\\n### （二）参数详解\\n#### 1. **corePoolSize 线程池核心线程大小**\\n线程池中会维护一个最小的线程数量，即时这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。<b>默认说的最小线程数量即是corePoolSize。</b>\\n\\n#### 2. **maximumPoolSize 线程池最大线程数量**\\n一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximumPoolSize指定。\\n#### 3. **keepAliveTime 空闲线程存活时间**\\n一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定\\n#### 4. **unit 空闲线程存活时间单位**\\nkeepAliveTime的计量单位\\n#### 5. **workQueue 工作队列**\\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：\\n##### (1) ArrayBlockingQueue\\n基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\\n##### (2) LinkedBlockingQuene\\n基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\\n##### (3) SynchronousQuene\\n一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\\n##### (4) PriorityBlockingQueue\\n具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\\n#### 6. **threadFactory 线程工厂**\\n创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\\n7. **handler 拒绝策略**\\n当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c0c0879782261895ec12d5ae01fb1af6.png)\\n##### (1) CallerRunsPolicy\\n该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0bfa4f6b0556820ae3efc16317930bd7.png)\\n##### (2) DiscardPolicy\\n该策略下，直接丢弃任务，什么都不做。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f72704ababeb056bb6b2df245b9528e7.png)\\n##### (3) AbortPolicy\\n该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1daf4f8a24815c2a23f20c37dcc4a2f6.png)\\n\\n##### (4) DiscardOldestPolicy\\n该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bef4f09fe171e35c830b4647cabd460.png)\\n***\\n### 三、使用（基于springboot）\\n#### （一） 配置\\n##### 1. 自定义配置类\\n``` java\\n@Configuration\\npublic class MyThreadConfig {\\n    @Bean\\n    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {\\n        return new ThreadPoolExecutor(pool.getCoreSize(),\\n                pool.getMaxSize(),\\n                pool.getKeepAliveTime(),\\n                TimeUnit.SECONDS,\\n                new LinkedBlockingDeque<>(100000),\\n                Executors.defaultThreadFactory(),\\n                new ThreadPoolExecutor.AbortPolicy());\\n    }\\n}\\n```\\n##### 2. 自定义配置文件类\\n``` java\\n@ConfigurationProperties(prefix = \\\"gulimall.thread\\\")\\n@Component\\n@Data\\npublic class ThreadPoolConfigProperties {\\n    private Integer coreSize;\\n    private Integer maxSize;\\n    private Integer keepAliveTime;\\n}\\n```\\n##### 3. 抽取配置文件application.properties\\n```text\\n#线程池配置\\ngulimall.thread.core-size=20\\ngulimall.thread.max-size=200\\ngulimall.thread.keep-alive-time=10\\n```\\n#### （二） 实践\\n##### 1. bean自动注入\\n```java\\n @Autowired\\n    ThreadPoolExecutor executor;\\n```\\n##### 2. 基于ThreadPoolExecutor的异步编排CompletableFuture\\n```java\\n CompletableFuture<Void> getSkuInfoTask = CompletableFuture.runAsync(() -> {\\n\\t\\t//异步线程任务1\\n                //1、远程查询当前要添加的商品的信息\\n                R skuInfo = productFeignService.getSkuInfo(skuId);\\n                SkuInfoVo data = skuInfo.getData(\\\"skuInfo\\\", new TypeReference<SkuInfoVo>() {\\n                });\\n                cartItemVo.setCheck(true);\\n                cartItemVo.setCount(num);\\n                cartItemVo.setImage(data.getSkuDefaultImg());\\n                cartItemVo.setTitle(data.getSkuTitle());\\n                cartItemVo.setPrice(data.getPrice());\\n                cartItemVo.setSkuId(skuId);\\n            }, executor);\\n```\\n***\\n```java\\n\\t//3、远程查询sku的组合信息\\n\\t//异步线程任务2\\n            CompletableFuture<Void> getSkuAttrValues = CompletableFuture.runAsync(() -> {\\n                List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);\\n                cartItemVo.setSkuAttrValues(skuSaleAttrValues);\\n            }, executor);\\n```\\n***\\n``` java\\n//异步编排，等待所有异步线程任务结束\\n            CompletableFuture.allOf(getSkuInfoTask, getSkuAttrValues).get();\\n```\\n***\\n### 四、总结\\n**提交任务给ThreadPoolExecutor，当工作线程数<核心线程数时，此时会新建工作线程。当工作线程数>核心线程数时，此时会把任务交给队列。当队列中无法放入任务时，此时会执行饱和策略**\\n#### 1. 优点\\n- 降低资源消耗：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，通过重复利用已创建的线程可以降低线程创建和销毁造成的消耗。\\n\\n- 提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。\\n- 提高线程的可管理性：线程池提供了一种限制、管理资源的策略，维护一些基本的线程统计信息，如已完成任务的数量等。通过线程池可以对线程资源进行统一的分配、监控和调优。\\n- **可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。（ThreadPoolExecutor特有）**\\n#### 2. 使用场景\\n**适用于高并发多线程场景**\\n>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。\\n池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f43c49ff7cf3506a528ac439a810e374.jpg\",\"articleTitle\":\"java高并发多线程，线程池【ThreadPoolExecutor】的使用\",\"categoryName\":\"学习记录\",\"id\":59,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-03-28 03:17:15',NULL),(1132,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"java面试\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','203.168.22.70','广东省广州市 电信','2022-03-31 01:55:26',NULL),(1133,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# <center>equals与==的区别\\n## equals\\n**equals用来比较的是两个对象的内容是否相等**，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。\\n## ==\\n**== 比较的是变量(栈)内存中存放的对象的(堆)内存地址**，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。\\n1. 比较的是操作符两端的操作数是否是同一个对象。\\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\\n\\n### 例：\\n```java\\npublic class equalsTest {\\n    public static void main(String[] args) {\\n        String s1 = \\\"abc\\\";\\n        String s2 = s1;\\n        String s5 = \\\"abc\\\";\\n        String s3 = new String(\\\"abc\\\");\\n        String s4 = new String(\\\"abc\\\");\\n        System.out.println(\\\"==comparison:\\\"+(s1==s5));\\n        System.out.println(\\\"==comparison:\\\"+(s1==s2));\\n        System.out.println(\\\"Using equals method :\\\"+s1.equals(s2));\\n        System.out.println(\\\"==comparison:\\\"+s3==s4);\\n        System.out.println(\\\"Using equals method :\\\"+s3.equals(s4));\\n    }\\n}\\n```\\n### 结果：\\n```java\\n==comparison:true\\n==comparison:true\\nUsing equals method :true\\nfalse\\nUsing equals method :true\\n```\\n## 总结\\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针\\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/fbb61a1551e0dae8fd0d3cfb9936de17.jpg\",\"articleTitle\":\"java基础面试题：equals与==的区别\",\"categoryName\":\"java面试\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"java基础\",\"面经八股文\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','203.168.22.70','广东省广州市 电信','2022-03-31 02:13:43',NULL),(1134,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 1、 Java语言有哪些特点\\n1. 简单易学、有丰富的类库\\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\\n3. 与平台无关性（JVM是Java跨平台使用的根本）\\n4. 可靠安全\\n5. 支持多线程\\n## 2、面向对象和面向过程的区别\\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\\n\\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\\n## 3 、八种基本数据类型的大小，以及他们的封装类\\n|基本类型 |大小（字节）|默认值|封装类|\\n|-|-|-|-|\\n|byte|1|(byte)0|Byte|\\n|short|2|(short)0|Short|\\n|int|4|0|Integer|\\n|long|8|0L|Long|\\n|float|4|0.0f|Float|\\n|double|8|0.0d|Double|\\n|boolean|-|false|Boolean|\\n|char|2|\\\\u0000(null)|Char|\\n注：\\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\\n\\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\\n\\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\\n## 4、标识符的命名规则。\\n<b>标识符的含义：</b>\\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\\n\\n<b>命名规则：（硬性要求）</b>\\n- 标识符可以包含英文字母，0-9的数字，$以及_\\n- 标识符不能以数字开头\\n- 标识符不是关键字\\n\\n\\n<b>命名规范：（非硬性要求）</b>\\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\\n- 方法名规范：同变量名。\\n## 5、instanceof 关键字的作用\\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\\n``` java\\nboolean result = obj instanceof Class\\n```\\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\\n\\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\\n``` java\\nint i = 0;\\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\\nSystem.out.println(i instanceof Object);//编译不通过\\n```\\n``` java\\nInteger integer = new Integer(1);\\nSystem.out.println(integer instanceof Integer);//true\\n\\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\\nfalse。\\nSystem.out.println(null instanceof Object);\\n```\\n## 6、Java自动装箱与拆箱\\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\\nvalueOf(int) 方法</b>\\n\\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\\n``` java\\nInteger i = new Integer(10);\\n```\\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\\n样就可以了：\\n``` java\\nInteger i = 10;\\n```\\n<b><i>面试题1： 以下代码会输出什么？</i></b>\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tInteger i1 = 100;\\n\\t\\tInteger i2 = 100;\\n\\t\\tInteger i3 = 200;\\n\\t\\tInteger i4 = 200;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n运行结果：\\n``` java\\ntrue\\nfalse\\n```\\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\\n``` java\\npublic static Integer valueOf(int i) {\\n\\tif(i >= -128 && i <= IntegerCache.high)\\n\\t\\treturn IntegerCache.cache[i + 128];\\n\\telse\\n\\t\\treturn new Integer(i);\\n}\\n\\n```\\n\\n其中IntegerCache类的实现为：\\n``` java\\n    private static class IntegerCache {\\n        static final int low = -128;\\n        static final int high;\\n        static final Integer cache[];\\n\\n        static {\\n            // high value may be configured by property\\n            int h = 127;\\n            String integerCacheHighPropValue =\\n                sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\");\\n            if (integerCacheHighPropValue != null) {\\n                try {\\n                    int i = parseInt(integerCacheHighPropValue);\\n                    i = Math.max(i, 127);\\n                    // Maximum array size is Integer.MAX_VALUE\\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\\n                } catch( NumberFormatException nfe) {\\n                    // If the property cannot be parsed into an int, ignore it.\\n                }\\n            }\\n            high = h;\\n\\n            cache = new Integer[(high - low) + 1];\\n            int j = low;\\n            for(int k = 0; k < cache.length; k++)\\n                cache[k] = new Integer(j++);\\n\\n            // range [-128, 127] must be interned (JLS7 5.1.7)\\n            assert IntegerCache.high >= 127;\\n        }\\n\\n        private IntegerCache() {}\\n    }\\n```\\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\\n\\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\\n\\n***面试题2：以下代码输出什么***\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tDouble i1 = 100.0;\\n\\t\\tDouble i2 = 100.0;\\n\\t\\tDouble i3 = 200.0;\\n\\t\\tDouble i4 = 200.0;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n\\n运行结果：\\n``` java\\nfalse\\nfalse\\n```\\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\\n## 7、 重载和重写的区别\\n<b>重写(Override)</b>\\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\\n``` java\\npublic class Father {\\npublic static void main(String[] args) {\\n\\t// TODO Auto-generated method stub\\n\\tSon s = new Son();\\n\\ts.sayHello();\\n}\\npublic void sayHello() {\\n\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n}\\nclass Son extends Father{\\n\\t@Override\\n\\tpublic void sayHello() {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tSystem.out.println(\\\"hello by \\\");\\n\\t}\\n}\\n```\\n重写 总结：\\n1.发生在父类与子类之间\\n2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\\n3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\\n4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\\n重载（Overload）\\n在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）\\n则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来\\n判断重载。\\n重载 总结：\\n1.重载Overload是一个类中多态性的一种表现\\n2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\\n3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\\n8、 equals与==的区别\\n== ：\\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是\\n指相同一个对象。比较的是真正意义上的指针操作。\\n1、比较的是操作符两端的操作数是否是同一个对象。\\n2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\\n3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\\nequals：\\npublic class Father {\\npublic static void main(String[] args) {\\n// TODO Auto-generated method stub\\nFather s = new Father();\\ns.sayHello();\\ns.sayHello(\\\"wintershii\\\");\\n}\\npublic void sayHello() {\\nSystem.out.println(\\\"Hello\\\");\\n}\\npublic void sayHello(String name) {\\nSystem.out.println(\\\"Hello\\\" + \\\" \\\" + name);\\n}\\n}\\nequals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以\\n适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\\nequals方法返回的却是==的判断。\\n总结：\\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的\\nequals object可能为null 则空指针\\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排\\n查老代码使用“==”，替换成equals\\n9、 Hashcode的作用\\njava的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中\\n插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法\\n就会比较满。\\n于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对\\n象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就\\n可以确定该对象应该存储的那个区域。\\n hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合\\n要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。\\n如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上\\n已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地\\n址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\\n10、String、String StringBuffer 和 StringBuilder 的区别是什\\n么?\\nString是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符\\n数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的\\nString对象。\\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接\\n+后面的字符。\\nStringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder\\n抽象类中我们可以看到\\nprivate final char value[];\\n/**\\n* The value is used for character storage.\\n*/\\nchar[] value;\\n他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和\\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是\\n线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\",\"articleCover\":\"\",\"articleTitle\":\"java基础面试题（一）\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-14 21:51:54',NULL),(1135,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 1、 Java语言有哪些特点\\n1. 简单易学、有丰富的类库\\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\\n3. 与平台无关性（JVM是Java跨平台使用的根本）\\n4. 可靠安全\\n5. 支持多线程\\n## 2、面向对象和面向过程的区别\\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\\n\\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\\n## 3 、八种基本数据类型的大小，以及他们的封装类\\n|基本类型 |大小（字节）|默认值|封装类|\\n|-|-|-|-|\\n|byte|1|(byte)0|Byte|\\n|short|2|(short)0|Short|\\n|int|4|0|Integer|\\n|long|8|0L|Long|\\n|float|4|0.0f|Float|\\n|double|8|0.0d|Double|\\n|boolean|-|false|Boolean|\\n|char|2|\\\\u0000(null)|Char|\\n注：\\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\\n\\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\\n\\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\\n## 4、标识符的命名规则。\\n<b>标识符的含义：</b>\\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\\n\\n<b>命名规则：（硬性要求）</b>\\n- 标识符可以包含英文字母，0-9的数字，$以及_\\n- 标识符不能以数字开头\\n- 标识符不是关键字\\n\\n\\n<b>命名规范：（非硬性要求）</b>\\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\\n- 方法名规范：同变量名。\\n## 5、instanceof 关键字的作用\\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\\n``` java\\nboolean result = obj instanceof Class\\n```\\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\\n\\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\\n``` java\\nint i = 0;\\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\\nSystem.out.println(i instanceof Object);//编译不通过\\n```\\n``` java\\nInteger integer = new Integer(1);\\nSystem.out.println(integer instanceof Integer);//true\\n\\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\\nfalse。\\nSystem.out.println(null instanceof Object);\\n```\\n## 6、Java自动装箱与拆箱\\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\\nvalueOf(int) 方法</b>\\n\\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\\n``` java\\nInteger i = new Integer(10);\\n```\\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\\n样就可以了：\\n``` java\\nInteger i = 10;\\n```\\n<b><i>面试题1： 以下代码会输出什么？</i></b>\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tInteger i1 = 100;\\n\\t\\tInteger i2 = 100;\\n\\t\\tInteger i3 = 200;\\n\\t\\tInteger i4 = 200;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n运行结果：\\n``` java\\ntrue\\nfalse\\n```\\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\\n``` java\\npublic static Integer valueOf(int i) {\\n\\tif(i >= -128 && i <= IntegerCache.high)\\n\\t\\treturn IntegerCache.cache[i + 128];\\n\\telse\\n\\t\\treturn new Integer(i);\\n}\\n\\n```\\n\\n其中IntegerCache类的实现为：\\n``` java\\n    private static class IntegerCache {\\n        static final int low = -128;\\n        static final int high;\\n        static final Integer cache[];\\n\\n        static {\\n            // high value may be configured by property\\n            int h = 127;\\n            String integerCacheHighPropValue =\\n                sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\");\\n            if (integerCacheHighPropValue != null) {\\n                try {\\n                    int i = parseInt(integerCacheHighPropValue);\\n                    i = Math.max(i, 127);\\n                    // Maximum array size is Integer.MAX_VALUE\\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\\n                } catch( NumberFormatException nfe) {\\n                    // If the property cannot be parsed into an int, ignore it.\\n                }\\n            }\\n            high = h;\\n\\n            cache = new Integer[(high - low) + 1];\\n            int j = low;\\n            for(int k = 0; k < cache.length; k++)\\n                cache[k] = new Integer(j++);\\n\\n            // range [-128, 127] must be interned (JLS7 5.1.7)\\n            assert IntegerCache.high >= 127;\\n        }\\n\\n        private IntegerCache() {}\\n    }\\n```\\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\\n\\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\\n\\n***面试题2：以下代码输出什么***\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tDouble i1 = 100.0;\\n\\t\\tDouble i2 = 100.0;\\n\\t\\tDouble i3 = 200.0;\\n\\t\\tDouble i4 = 200.0;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n\\n运行结果：\\n``` java\\nfalse\\nfalse\\n```\\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\\n## 7、 重载和重写的区别\\n<b>重写(Override)</b>\\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\\n``` java\\npublic class Father {\\npublic static void main(String[] args) {\\n\\t// TODO Auto-generated method stub\\n\\tSon s = new Son();\\n\\ts.sayHello();\\n}\\npublic void sayHello() {\\n\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n}\\nclass Son extends Father{\\n\\t@Override\\n\\tpublic void sayHello() {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tSystem.out.println(\\\"hello by \\\");\\n\\t}\\n}\\n```\\n<b>重写总结：</b>\\n1. 发生在父类与子类之间\\n2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\\n3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\\n4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\\n\\n\\n<b>重载（Overload）</b>\\n在一个类中，同名的方法如果有不同的参数列表<b>（参数类型不同、参数个数不同甚至是参数顺序不同）</b>则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<b>不能通过返回类型是否相同来判断重载。</b>\\n\\n``` java\\npublic class Father {\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tFather s = new Father();\\n\\t\\ts.sayHello();\\n\\t\\ts.sayHello(\\\"wintershii\\\");\\n\\t}\\n\\tpublic void sayHello() {\\n\\t\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n\\tpublic void sayHello(String name) {\\n\\t\\tSystem.out.println(\\\"Hello\\\" + \\\" \\\" + name);\\n\\t}\\n}\\n```\\n<b>重载总结：</b>\\n1. 重载Overload是一个类中多态性的一种表现\\n2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\\n3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\\n## 8、 equals与==的区别\\n<b>== ：</b>\\n\\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，**用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。**\\n1. 比较的是操作符两端的操作数是否是同一个对象。\\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\\n\\n<b>equals：</b>\\n\\n&emsp;&emsp;equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\\nequals方法返回的却是==的判断。\\n\\n<b>总结：</b>\\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针。\\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\\n## 9、 Hashcode的作用\\n&emsp;&emsp;**java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复**。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。\\n\\n&emsp;&emsp;于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。\\n\\n&emsp;&emsp;hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\\n## 10、String、String StringBuffer 和 StringBuilder 的区别是什么?\\n\\n**String是只读字符串，它并不是基本数据类型，而是一个对象**。从底层源码来看是一个final类型的字符\\n数组，所引用的字符串不能被改变，**一经定义，无法再增删改。每次对String的操作都会生成新的String对象**。\\n``` java\\nprivate final char value[];\\n```\\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。\\n\\n**StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类**，从AbstractStringBuilder抽象类中我们可以看到\\n``` java\\n/**\\n* The value is used for character storage.\\n*/\\nchar[] value;\\n```\\n他们的底层都是可变的字符数组，**所以在进行频繁的字符串操作时，建议使用StringBuffer和\\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的**。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b6ca16c4768b3e963997131f64e49b63.jpg\",\"articleTitle\":\"java基础面试题（一）\",\"categoryName\":\"java面试\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-14 22:13:05',NULL),(1136,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 11、ArrayList和linkedList的区别\\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\\n<p>例如：</p>\\n\\n``` java\\nint[] a = new int[4];//推介使用int[] 这种方式初始化\\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\\n```\\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\\n\\n**List有两个重要的实现类：ArrayList和LinkedList**\\n\\n**ArrayList: 可以看作是能够自动增长容量的数组**\\n\\n**ArrayList的toArray方法返回一个数组**\\n\\n**ArrayList的asList方法返回一个列表**\\n**ArrayList底层的实现是Array, 数组扩容实现**\\n\\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\\n\\n## 12、 HashMap和HashTable的区别\\n1. **两者父类不同**\\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\\n\\nHashMap源码：\\n``` java\\npublic class HashMap<K,V> extends AbstractMap<K,V>\\n    implements Map<K,V>, Cloneable, Serializable {\\n\\n...\\n}\\n```\\nHashTable源码：\\n``` java\\npublic class Hashtable<K,V>\\n    extends Dictionary<K,V>\\n    implements Map<K,V>, Cloneable, java.io.Serializable {\\n\\n...\\n}\\n```\\n2. **对外提供的接口不同**\\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\\n\\n3. **对null的支持不同**\\n**Hashtable：key和value都不能为null**。\\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\\n\\n4. **安全性不同**\\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\\n\\n5. **初始容量大小和每次扩充容量大小不同**\\n6. **计算hash值的方法不同**\\n\\n## 13、Collection包结构，与Collections的区别\\n\\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\\n\\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\\n\\n## 14、Java的四种引用，强弱软虚\\n- 强引用\\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\\n式：\\n``` java\\nString str = new String(\\\"str\\\");\\n```\\n\\n- 软引用\\n软引用在内存不足时，会被回收，使用方式：\\n``` java\\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\\n// 这里的软引用指的是指向new String(\\\"str\\\")的引用，也就是SoftReference类中T\\nSoftReference<String> wrf = new SoftReference<String>(new String(\\\"str\\\"));\\n```\\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\\n- 弱引用\\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\\n``` java\\nWeakReference<String> wrf = new WeakReference<String>(str);\\n```\\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\\n- 虚引用\\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\\n``` java\\nPhantomReference<String> prf = new PhantomReference<String>(new\\nString(\\\"str\\\"), new ReferenceQueue<>());\\n```\\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\\n这类动作，但是这个方式即不安全又低效\\n\\n\\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\\n( SoftReference 等)**。\\n\\n## 15、泛型常用特点\\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\\n\\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\\n``` java\\nList<Integer> iniData = new ArrayList<>()\\n```\\n**使用泛型的好处**：\\n\\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\\n\\n## 16、Java创建对象有几种方式？\\nJava中提供了以下四种创建对象的方式：\\n- new创建新对象\\n- 通过反射机制\\n- 采用clone机制\\n- 通过序列化机制\\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\\n\\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\\n下几种方式来处理:\\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\\n\\n## 18、深拷贝和浅拷贝的区别是什么？\\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\\n\\n## 19、final有哪些用法？\\n- 被final修饰的类无法被继承\\n- 被final修饰的方法无法被重写\\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\\n- 被final修饰的常量，在编译阶段会存入常量池中\\n\\n\\n除此之外，编译器对final域要遵守的两个重排序规则更好：\\n\\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\\n\",\"articleCover\":\"\",\"articleTitle\":\"java基础面试题（二）\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-15 21:37:47',NULL),(1137,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 11、ArrayList和linkedList的区别\\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\\n<p>例如：</p>\\n\\n``` java\\nint[] a = new int[4];//推介使用int[] 这种方式初始化\\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\\n```\\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\\n\\n**List有两个重要的实现类：ArrayList和LinkedList**\\n\\n**ArrayList: 可以看作是能够自动增长容量的数组**\\n\\n**ArrayList的toArray方法返回一个数组**\\n\\n**ArrayList的asList方法返回一个列表**\\n**ArrayList底层的实现是Array, 数组扩容实现**\\n\\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\\n\\n## 12、 HashMap和HashTable的区别\\n1. **两者父类不同**\\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\\n\\nHashMap源码：\\n``` java\\npublic class HashMap<K,V> extends AbstractMap<K,V>\\n    implements Map<K,V>, Cloneable, Serializable {\\n\\n...\\n}\\n```\\nHashTable源码：\\n``` java\\npublic class Hashtable<K,V>\\n    extends Dictionary<K,V>\\n    implements Map<K,V>, Cloneable, java.io.Serializable {\\n\\n...\\n}\\n```\\n2. **对外提供的接口不同**\\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\\n\\n3. **对null的支持不同**\\n**Hashtable：key和value都不能为null**。\\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\\n\\n4. **安全性不同**\\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\\n\\n5. **初始容量大小和每次扩充容量大小不同**\\n6. **计算hash值的方法不同**\\n\\n## 13、Collection包结构，与Collections的区别\\n\\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\\n\\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\\n\\n## 14、Java的四种引用，强弱软虚\\n- 强引用\\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\\n式：\\n``` java\\nString str = new String(\\\"str\\\");\\n```\\n\\n- 软引用\\n软引用在内存不足时，会被回收，使用方式：\\n``` java\\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\\n// 这里的软引用指的是指向new String(\\\"str\\\")的引用，也就是SoftReference类中T\\nSoftReference<String> wrf = new SoftReference<String>(new String(\\\"str\\\"));\\n```\\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\\n- 弱引用\\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\\n``` java\\nWeakReference<String> wrf = new WeakReference<String>(str);\\n```\\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\\n- 虚引用\\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\\n``` java\\nPhantomReference<String> prf = new PhantomReference<String>(new\\nString(\\\"str\\\"), new ReferenceQueue<>());\\n```\\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\\n这类动作，但是这个方式即不安全又低效\\n\\n\\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\\n( SoftReference 等)**。\\n\\n## 15、泛型常用特点\\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\\n\\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\\n``` java\\nList<Integer> iniData = new ArrayList<>()\\n```\\n**使用泛型的好处**：\\n\\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\\n\\n## 16、Java创建对象有几种方式？\\nJava中提供了以下四种创建对象的方式：\\n- new创建新对象\\n- 通过反射机制\\n- 采用clone机制\\n- 通过序列化机制\\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\\n\\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\\n下几种方式来处理:\\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\\n\\n## 18、深拷贝和浅拷贝的区别是什么？\\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\\n\\n## 19、final有哪些用法？\\n- 被final修饰的类无法被继承\\n- 被final修饰的方法无法被重写\\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\\n- 被final修饰的常量，在编译阶段会存入常量池中\\n\\n\\n除此之外，编译器对final域要遵守的两个重排序规则更好：\\n\\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\\n## 20、static都有哪些用法?\\nstatic关键字有两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.\\n\\n除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:\\n``` java\\npublic class PreCache{\\n\\tstatic{\\n\\t\\t//执行相关操作，静态初始化\\n\\t}\\n}\\n```\\n此外static也多用于修饰内部类,此时称之为静态内部类.\\n\\n最后一种用法就是静态导包,即 ```import static .import static```是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:\\n``` java\\nimport static java.lang.Math.*;\\npublic class Test{\\n\\tpublic static void main(String[] args){\\n\\t//System.out.println(Math.sin(20));传统做法\\n\\tSystem.out.println(sin(20));//静态导包作法\\n\\t}\\n}\\n\\n```\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"java基础面试题（二）\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-15 21:41:29',NULL),(1138,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 11、ArrayList和linkedList的区别\\n<p><b>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的</b>。</p>\\n<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,\\n(因为删除数据以后, 需要把后面所有的数据前移)</p>\\n<p><b>缺点：数组初始化必须指定初始化的长度，否则报错</b></p>\\n<p>例如：</p>\\n\\n``` java\\nint[] a = new int[4];//推介使用int[] 这种方式初始化\\nint c[] = {23,43,56,78};//长度：4，索引范围：[0,3]\\n```\\n**List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection**。\\n\\n**List有两个重要的实现类：ArrayList和LinkedList**\\n\\n**ArrayList: 可以看作是能够自动增长容量的数组**\\n\\n**ArrayList的toArray方法返回一个数组**\\n\\n**ArrayList的asList方法返回一个列表**\\n**ArrayList底层的实现是Array, 数组扩容实现**\\n\\n**LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**\\n\\n## 12、 HashMap和HashTable的区别\\n1. **两者父类不同**\\n**HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类**。不过它们都实现了同时**实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口**。\\n\\nHashMap源码：\\n``` java\\npublic class HashMap<K,V> extends AbstractMap<K,V>\\n    implements Map<K,V>, Cloneable, Serializable {\\n\\n...\\n}\\n```\\nHashTable源码：\\n``` java\\npublic class Hashtable<K,V>\\n    extends Dictionary<K,V>\\n    implements Map<K,V>, Cloneable, java.io.Serializable {\\n\\n...\\n}\\n```\\n2. **对外提供的接口不同**\\nHashtable比HashMap多提供了elements() 和contains() 两个方法。\\n elements() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中value的枚举。\\ncontains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，containsValue() 就只是调用了一下contains() 方法。\\n\\n3. **对null的支持不同**\\n**Hashtable：key和value都不能为null**。\\n**HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key。值对应的key为null**。\\n\\n4. **安全性不同**\\nHashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。\\nHashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。\\n虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。\\n当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。\\nConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。\\n\\n5. **初始容量大小和每次扩充容量大小不同**\\n6. **计算hash值的方法不同**\\n\\n## 13、Collection包结构，与Collections的区别\\n\\nCollection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；\\n\\nCollections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。\\n\\n## 14、Java的四种引用，强弱软虚\\n- 强引用\\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方\\n式：\\n``` java\\nString str = new String(\\\"str\\\");\\n```\\n\\n- 软引用\\n软引用在内存不足时，会被回收，使用方式：\\n``` java\\n// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，\\n// 这里的软引用指的是指向new String(\\\"str\\\")的引用，也就是SoftReference类中T\\nSoftReference<String> wrf = new SoftReference<String>(new String(\\\"str\\\"));\\n```\\n&emsp;&emsp;可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\\n- 弱引用\\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：\\n``` java\\nWeakReference<String> wrf = new WeakReference<String>(str);\\n```\\n可用场景：Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\\n- 虚引用\\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：\\n``` java\\nPhantomReference<String> prf = new PhantomReference<String>(new\\nString(\\\"str\\\"), new ReferenceQueue<>());\\n```\\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做\\n这类动作，但是这个方式即不安全又低效\\n\\n\\n**上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\\n( SoftReference 等)**。\\n\\n## 15、泛型常用特点\\n泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：\\n> “泛型” 意味着编写的代码可以被不同类型的对象所重用。\\n\\n“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如\\n``` java\\nList<Integer> iniData = new ArrayList<>()\\n```\\n**使用泛型的好处**：\\n\\n以集合来举例，**使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合**，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。\\n\\n## 16、Java创建对象有几种方式？\\nJava中提供了以下四种创建对象的方式：\\n- new创建新对象\\n- 通过反射机制\\n- 采用clone机制\\n- 通过序列化机制\\n## 17、有没有可能两个不相等的对象有两个相同的hashcode\\n\\n有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以\\n下几种方式来处理:\\n- 拉链法：:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.\\n- 开放地址法：一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入\\n- 再哈希：又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.\\n\\n## 18、深拷贝和浅拷贝的区别是什么？\\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.**换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.**\\n- 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.**换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.**\\n\\n## 19、final有哪些用法？\\n- 被final修饰的类无法被继承\\n- 被final修饰的方法无法被重写\\n- 被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变。\\n- 被final修饰的方法，JVM会尝试将其内联，以提高运行效率\\n- 被final修饰的常量，在编译阶段会存入常量池中\\n\\n\\n除此之外，编译器对final域要遵守的两个重排序规则更好：\\n\\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\\n## 20、static都有哪些用法?\\nstatic关键字有两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.\\n\\n除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:\\n``` java\\npublic class PreCache{\\n\\tstatic{\\n\\t\\t//执行相关操作，静态初始化\\n\\t}\\n}\\n```\\n此外static也多用于修饰内部类,此时称之为静态内部类.\\n\\n最后一种用法就是静态导包,即 ```import static .import static```是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:\\n``` java\\nimport static java.lang.Math.*;\\npublic class Test{\\n\\tpublic static void main(String[] args){\\n\\t//System.out.println(Math.sin(20));传统做法\\n\\tSystem.out.println(sin(20));//静态导包作法\\n\\t}\\n}\\n\\n```\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f8f00bcc0d1424975a35eb231d9f9cde.jpg\",\"articleTitle\":\"java基础面试题（二）\",\"categoryName\":\"java面试\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-15 21:42:19',NULL),(1139,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 21、3*0.1==0.3的返回值是什么\\nfalse，因为有些浮点数不能完全精确的表示出来（精度问题）\\n\\n## 22、a=a+b与a+=b有什么区别吗？\\n<b>```+=```操作符会进行隐式自动类型转换</b>，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，<b>而a=a+b则不会自动进行类型转换</b>，如：\\n``` java\\nbyte a = 127;\\nbyte b = 127;\\nb = a + b; // 报编译错误:cannot convert from int to byte\\nb += a;\\n```\\n以下代码是否有错，有的话怎么改？\\n``` java\\nshort s1=1;\\ns1 = s1 + 1; \\n```\\n有错误，因为1为int型，short类型在进行运算时会自动提升为int类型,也就是说 ```s1+1``` 的运算结果是int类型,而s1是short类型,此时编译器会报错.\\n\\n正确写法：\\n``` java\\nshort s1 = 1;\\ns1 += 1;\\n```\\n<b>+=操作符会对右边的表达式结果强转匹配左边的数据类型</b>\\n\\n## 23、try catch finally，try里有return，finally还执行么？\\n**执行，并且finally的执行早于try里面的return**\\n\\n**结论**：\\n1. 不管有没有出现异常，finally块中的代码都会执行\\n2. 当try和catch中有return中，finally仍然会执行\\n3. finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保\\n存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的\\n4. finally中最好不要包含return，否则程序会提前退出，返回值为finally块中的return值，而不是try或catch中保存的返回值\\n\\n## 24、Excption与Error包结构\\nJava可抛出(Throwable)的结构分为三种类型：**被检查的异常(CheckedException)，运行时异常\\n(RuntimeException)，错误(Error)**。\\n1. 运行时异常\\n**定义:RuntimeException及其子类都被称为运行时异常。**\\n<p>特点:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既\\\"没有通过throws声明抛出它\\\"，也\\\"没有用try-catch语句捕获它\\\"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常（java.util包下面的所有的集合类都是快速失败的，“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Fail-safe，java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。\\nConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。）等，都属于运行时异常。</p>\\n\\n常见的五种运行时异常：\\nClassCastException（类转换异常）\\nIndexOutOfBoundsException（数组越界）\\nNullPointerException（空指针异常）\\nArrayStoreException（数据存储异常，操作数组是类型不一致）\\nBufferOverflowException\\n\\n2. 被检查异常\\n**定义:Exception类本身，以及Exception的子类中除了\\\"运行时异常\\\"之外的其它子类都属于被检查异常**\\n\\n特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的\\n\\n如：\\nIOException\\nFileNotFoundException\\nSQLException\\n被检查的异常适用于那些不是因程序引起的错误情况，\\n比如：\\n读取文件时文件不存在引发的FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException 。\\n\\n3. 错误\\n**定义 : Error类及其子类**。\\n\\n特点 : 和运行时异常一样，编译器也不会对错误进行检查。\\n当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。\\nOutOfMemoryError、ThreadDeath。\\nJava虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等\\n\\n## 25、OOM你遇到过哪些情况，SOF你遇到过哪些情况\\n**OOM**：\\n1. OutOfMemoryError异常\\n\\n\\n除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。\\n\\nJava Heap 溢出：\\n\\n一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。\\n\\njava堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。\\n\\n出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。\\n\\n如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。\\n\\n如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。\\n\\n2. 虚拟机栈和本地方法栈溢出\\n\\n\\n如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。\\n\\n如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常\\n\\n这里需要注意当栈的大小越大可分配的线程数就越少。\\n\\n3. 运行时常量池溢出\\n\\n异常信息：java.lang.OutOfMemoryError:PermGenspace\\n\\n如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。\\n\\n4. 方法区溢出\\n\\n方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。\\n\\n异常信息：java.lang.OutOfMemoryError:PermGenspace\\n方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。\\n\\n**SOF（堆栈溢出StackOverflow）**：\\n\\n- StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。\\n因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。\\n**栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大**\\n\\n## 26、简述线程、程序、进程的基本概念。以及他们之间关系是什么?\\n\\n**线程与进程相似，但线程是一个比进程更小的执行单位**。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，**线程也被称为轻量级进程**。\\n\\n**程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码**。\\n\\n**进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的**。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\\n\\n## 27、线程有哪些基本状态？\\n Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c215fe0eb4996fc14aefd73c412bb6e9.png)\\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/17118c32c11f932819aa138f5e7bb71c.png)\\n> 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava：Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ae96eb1fbd464707f2983b29338b8d63.png)\\n\\n当线程执行 wait() 方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis） 方法或 wait（long millis） 方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable的 run() 方法之后将会进入到 TERMINATED（终止） 状态。\\n## 28、Java 序列化中如果有些字段不想进行序列化，怎么办？\\n对于不想进行序列化的变量，使用transient 关键字修饰。\\n\\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。\\n## 29、Java 中 IO 流\\nJava中IO流分为几种？\\n- 按照流的流向分，可以分为输入流和输出流；\\n- 按照操作单元划分，可以划分为字节流和字符流；\\n- 按照流的角色划分为节点流和处理流。\\n## 30、Java反射的作用与原理\\n1. **定义**\\n**反射机制是在运行时，对于任意一个类，都能够知到这个类的所有属性和方法**；对于任意个对象，都能够调用他的意任意一个方法，在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。\\n> 这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。\\n\\n2. **哪里会用到反射机制**？\\n**jdbc就是典型的反射**\\n``` java\\nClass.forName(\'com.mysql.cj.jdbc.Driver.class\');//加载MySQL的驱动类\\n```\\n这就是反射。如hibernate，struts等框架使用反射实现的。\\n\\n3. **反射的实现方式**\\n第一步：获取Class对象，有4中方法：\\n1）Class.forName(“类的路径”)；\\n2）类名.class\\n3）对象名.getClass()\\n4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象\\n\\n4. **实现Java反射的类**：\\n1）Class：表示正在运行的Java应用程序中的类和接口\\n注意： 所有获取对象的信息都需要Class类来实现。\\n2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。\\n3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限\\n4）Method：提供类或接口中某个方法的信息\\n5. **反射机制的优缺点**：\\n**优点**：\\n1）能够运行时动态获取类的实例，提高灵活性；\\n2）与动态编译结合\\n**缺点**：\\n1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。\\n解决方案：\\n1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；\\n2、多次创建一个类的实例时，有缓存会快很多\\n3、ReflectASM工具类，通过字节码生成的方式加快反射速度\\n2）相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）\\n## 31、说说List,Set,Map三者的区别？\\n- **List(对付顺序的好帮手)**： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\\n- **Set(注重独一无二的性质)**: **不允许重复的集合**。不会有多个元素引用相同的对象。\\n- **Map(用Key来搜索的专家)**: **使用键值对存储**。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\\n\\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2904b329e08607f13e50d22582c9716d.jpg\",\"articleTitle\":\"java基础面试题（三）\",\"categoryName\":\"java面试\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-17 00:32:43',NULL),(1140,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 二分查找法\\n### 前提:\\n只能用于升序数组\\n\\n### 定义：\\n在升序数组nums中寻找目标值target，对于特定下标i，比较nums[i]和target的大小：\\n- 如果nums[i]=targer，则下标i为要寻找的下标；\\n- 如果nums[i]>targer，则target只能是在下标i的左侧；\\n- 如果nums[i]<targer，则target在下标i的右侧。\\n\\n二分查找的做法为，定义查找的范围```[left,right]```，初始查找范围是整个数组，每次取查找范围的中点```mid``` ``` (mid的值为(left+right)/2) ``` ，比较nums[mid]和target的大小，如果相等则mid为要寻找的下标，如果target>nums[mid]，则使right=mid-1，否则，left=mid+1\\n\\n### 例子：\\n**LeetCode 704.二分查找**：\\n> 给定一个 ```  n``` 个元素有序的（升序）整型数组 ```nums``` 和一个目标值 ```target```  ，写一个函数搜索 ```nums``` 中的 ```target```，如果目标值存在返回下标，否则返回 ```-1```。\\n\\n示例1：\\n``` text\\n输入: nums = [-1,0,3,5,9,12], target = 9\\n输出: 4\\n解释: 9 出现在 nums 中并且下标为 4\\n```\\n\\n示例2：\\n``` text\\n输入: nums = [-1,0,3,5,9,12], target = 2\\n输出: -1\\n解释: 2 不存在 nums 中因此返回 -1\\n```\\n提示1：\\n``` text\\n1.你可以假设 nums 中的所有元素是不重复的。\\n2.n 将在 [1, 10000]之间。\\n3.nums 的每个元素都将在 [-9999, 9999]之间。\\n```\\n**Java题解**：\\n``` java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n    //初始化left为第一个，0\\n    int left=0;\\n    //初始化right为最后一个，nums.length-1\\n    int right=nums.length-1;\\n    while(left<=right){\\n\\t//定义中间值下标\\n        int mid=(left+right)/2;\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n        else if(nums[mid]>target){\\n            right=mid-1;\\n        } else {\\n            left=mid+1;\\n        }\\n    }\\n    return -1;\\n   }\\n}\\n```\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8867125f0009f89c4db3a889365e0f5d.jpg\",\"articleTitle\":\"二分查找法入门\",\"categoryName\":\"数据结构算法\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"算法\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-17 02:44:29',NULL),(1141,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 栈\\n### 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n### 栈的实现\\n这里基于**Java链表**实现\\n\\n#### 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n#### 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n#### 案例\\n##### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n##### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|--|--|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n\\n## 队列\\n### 理论基础：\\n**队列（queue）**，是一种先进先出（FIFO，First In First Out）的数据结构，\\n\\n\",\"articleCover\":\"\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-18 01:35:03',NULL),(1142,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 栈\\n## 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n### 栈的实现\\n这里基于**Java链表**实现\\n\\n### 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n### 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n### 案例\\n#### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n#### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|:--:|:--:|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n**需求**：\\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\\n分析：\\n> 1.创建一个栈对象oprands存储操作数\\n2.从左往右遍历逆波兰表达式，得到每一个字符串\\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\\n5.使用该运算符计算o1和o2，得到结果result\\n6.把该结果压入oprands栈中\\n7.遍历结束后，拿出栈中最终的结果返回\\n\\n流程图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\\n\\n**代码实现**：\\n``` java\\n/**\\n * 逆波兰表示法\\n *\\n * @author icatw\\n * @date 2022/04/17\\n */\\npublic class ReversePolishNotation {\\n    public static void main(String[] args) {\\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\\n        String[] notation = {\\\"3\\\", \\\"17\\\", \\\"15\\\", \\\"-\\\", \\\"*\\\", \\\"18\\\", \\\"6\\\", \\\"/\\\", \\\"+\\\"};\\n        int result = calculate(notation);\\n        System.out.println(\\\"逆波兰表达式的结果为：\\\" + result);\\n    }\\n\\n    /**\\n     * @param notation 逆波兰表达式的数组表示方式\\n     * @return 逆波兰表达式的计算结果\\n     */\\n    public static int calculate(String[] notation) {\\n        //1、定义一个栈用来存储操作数\\n        Stack<Integer> operands = new Stack<>();\\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\\n        for (int i = 0; i < notation.length; i++) {\\n            String curr = notation[i];\\n            //3、判断当前元素是运算符还是操作数\\n            Integer o1;\\n            Integer o2;\\n            Integer result;\\n            switch (curr) {\\n                case \\\"+\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 + o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"-\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 - o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"*\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 * o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"/\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 / o1;\\n                    operands.push(result);\\n                    break;\\n                default:\\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\\n                    operands.push(Integer.valueOf(curr));\\n                    break;\\n            }\\n\\n            //5、操作数，把该操作数压入栈中\\n\\n        }\\n        Integer pop = operands.pop();\\n        System.out.println(pop);\\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\\n        return pop;\\n    }\\n}\\n```\\n# 队列\\n## 理论基础：\\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\\n## API设计\\n|类名|Queue|\\n|-|-|\\n|构造方法|public Queue()：创建Queue对象|\\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\\n|内部结点类|private class Node|\\n## 代码实现\\n基于Java链表\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/4/18\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Queue<T> implements Iterable<T> {\\n    //记录首结点\\n    private Node head;\\n    //记录最后一个结点\\n    private Node last;\\n    //记录队列中元素的个数\\n    private int N;\\n\\n    public Queue() {\\n        head = new Node(null, null);\\n        last = null;\\n        N = 0;\\n    }\\n\\n    //判断队列是否为空\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    //返回队列中元素的个数\\n    public int size() {\\n        return N;\\n    }\\n\\n    //向队列中插入元素t\\n    public void enqueue(T t) {\\n        //1、当前尾结点，last为null\\n        if (last == null) {\\n            last = new Node(t, null);\\n            head.next = last;\\n        }\\n        //    2、当前尾结点不为null\\n        else {\\n            Node oldLast = this.last;\\n            Node newNode = new Node(t, null);\\n            last = newNode;\\n            oldLast.next = last;\\n        }\\n        N++;\\n    }\\n\\n    //从队列中拿出一个元素\\n    public T dequeue() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        Node oldFirst = head.next;\\n        head.next = oldFirst.next;\\n        N--;\\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\\n        if (isEmpty()) {\\n            last = null;\\n        }\\n        return oldFirst.item;\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\",\"articleCover\":\"\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-18 02:27:46',NULL),(1143,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 栈\\n## 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n## 栈的实现\\n这里基于**Java链表**实现\\n\\n## 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n## 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|:--:|:--:|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n**需求**：\\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\\n分析：\\n> 1.创建一个栈对象oprands存储操作数\\n2.从左往右遍历逆波兰表达式，得到每一个字符串\\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\\n5.使用该运算符计算o1和o2，得到结果result\\n6.把该结果压入oprands栈中\\n7.遍历结束后，拿出栈中最终的结果返回\\n\\n流程图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\\n\\n**代码实现**：\\n``` java\\n/**\\n * 逆波兰表示法\\n *\\n * @author icatw\\n * @date 2022/04/17\\n */\\npublic class ReversePolishNotation {\\n    public static void main(String[] args) {\\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\\n        String[] notation = {\\\"3\\\", \\\"17\\\", \\\"15\\\", \\\"-\\\", \\\"*\\\", \\\"18\\\", \\\"6\\\", \\\"/\\\", \\\"+\\\"};\\n        int result = calculate(notation);\\n        System.out.println(\\\"逆波兰表达式的结果为：\\\" + result);\\n    }\\n\\n    /**\\n     * @param notation 逆波兰表达式的数组表示方式\\n     * @return 逆波兰表达式的计算结果\\n     */\\n    public static int calculate(String[] notation) {\\n        //1、定义一个栈用来存储操作数\\n        Stack<Integer> operands = new Stack<>();\\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\\n        for (int i = 0; i < notation.length; i++) {\\n            String curr = notation[i];\\n            //3、判断当前元素是运算符还是操作数\\n            Integer o1;\\n            Integer o2;\\n            Integer result;\\n            switch (curr) {\\n                case \\\"+\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 + o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"-\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 - o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"*\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 * o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"/\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 / o1;\\n                    operands.push(result);\\n                    break;\\n                default:\\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\\n                    operands.push(Integer.valueOf(curr));\\n                    break;\\n            }\\n\\n            //5、操作数，把该操作数压入栈中\\n\\n        }\\n        Integer pop = operands.pop();\\n        System.out.println(pop);\\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\\n        return pop;\\n    }\\n}\\n```\\n# 队列\\n## 理论基础：\\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\\n## API设计\\n|类名|Queue|\\n|-|-|\\n|构造方法|public Queue()：创建Queue对象|\\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\\n|内部结点类|private class Node|\\n## 代码实现\\n基于Java链表\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/4/18\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Queue<T> implements Iterable<T> {\\n    //记录首结点\\n    private Node head;\\n    //记录最后一个结点\\n    private Node last;\\n    //记录队列中元素的个数\\n    private int N;\\n\\n    public Queue() {\\n        head = new Node(null, null);\\n        last = null;\\n        N = 0;\\n    }\\n\\n    //判断队列是否为空\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    //返回队列中元素的个数\\n    public int size() {\\n        return N;\\n    }\\n\\n    //向队列中插入元素t\\n    public void enqueue(T t) {\\n        //1、当前尾结点，last为null\\n        if (last == null) {\\n            last = new Node(t, null);\\n            head.next = last;\\n        }\\n        //    2、当前尾结点不为null\\n        else {\\n            Node oldLast = this.last;\\n            Node newNode = new Node(t, null);\\n            last = newNode;\\n            oldLast.next = last;\\n        }\\n        N++;\\n    }\\n\\n    //从队列中拿出一个元素\\n    public T dequeue() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        Node oldFirst = head.next;\\n        head.next = oldFirst.next;\\n        N--;\\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\\n        if (isEmpty()) {\\n            last = null;\\n        }\\n        return oldFirst.item;\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### LeetCode 225. 用队列实现栈\\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\\n实现 MyStack 类：\\nvoid push(int x) 将元素 x 压入栈顶。\\nint pop() 移除并返回栈顶元素。\\nint top() 返回栈顶元素。\\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\\n\\n**代码实现**：\\n``` java\\nclass MyStack {\\n\\n    Queue<Integer> queue1;\\n    Queue<Integer> queue2;\\n\\n    public MyStack() {\\n        queue1 = new LinkedList<Integer>();\\n        queue2 = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue2.offer(x);\\n        while (!queue1.isEmpty()) {\\n            queue2.offer(queue1.poll());\\n        }\\n        Queue<Integer> temp = queue1;\\n        queue1 = queue2;\\n        queue2 = temp;\\n    }\\n    \\n    public int pop() {\\n        return queue1.poll();\\n    }\\n    \\n    public int top() {\\n        return queue1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue1.isEmpty();\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d8afa7b4d72f0765e8a1cae491582411.jpg\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"categoryName\":\"数据结构算法\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-18 02:47:44',NULL),(1144,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot+vue解决跨域问题的两种方法\\n### 第一种解决方案\\n这种方案是直接的解决跨域问题的方案，就是吧 Vue 编译后的代码放到 Spring-boot 的 `resources/static` 目录下（当然你的 axios 的 BaseURL 改成 /api 类似这样不需要域名前缀了）。也就是前后端使用一个服务，这样自然不会有跨域问题了。实际上这已经不算是前后端分离了，只是前后端分离开发 :D)。\\n\\n### 第二种解决方案\\n第二种解决方案当然是使用官方提供的方法：CORS。Spring 下有两种方式使用 CORS：\\n\\n1. 使用注解\\n在需要提供前端跨域请求的接口上使用注解\\n\\n```\\n@CrossOrigin(origins = {\\\"http://localhost:8080\\\", \\\"null\\\"})\\n@RequestMapping(value = \\\"/helloword\\\", method = RequestMethod.Post)\\npublic String helloword() {\\n    return \\\"{\\\\\\\"message\\\\\\\": \\\\\\\"helloword\\\\\\\"}\\\";\\n}\\n```\\n这种方式是在接口级上控制跨域访问，在前后端分离的架构下，这种方式显得不大合适。\\n\\n2. 在配置类中设置 CORS\\n```\\n@Configuration\\npublic class WebMvcConfig extends WebMvcConfigurerAdapter {\\n  @Override\\n  public void addCorsMappings(CorsRegistry registry) {\\n    registry.addMapping(\\\"/**\\\")\\n            .allowedOrigins(\\\"http://localhost:8080\\\")\\n            .allowedMethods(\\\"POST\\\", \\\"GET\\\", \\\"PUT\\\", \\\"OPTIONS\\\", \\\"DELETE\\\")\\n            .maxAge(3600)\\n            .allowCredentials(true);\\n  }\\n}\\n```\\n`http://localhost:8080` 是你的 Vue 项目的服务地址和端口号，这样 Spring boot 后端服务就允许 Vue 前端跨域反问所有接口了。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg\",\"articleTitle\":\"springboot+vue跨域问题\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"vue\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 13:16:56',NULL),(1145,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot+vue解决跨域问题的两种方法\\n### 第一种解决方案\\n这种方案是直接的解决跨域问题的方案，就是吧 Vue 编译后的代码放到 Spring-boot 的 `resources/static` 目录下（当然你的 axios 的 BaseURL 改成 /api 类似这样不需要域名前缀了）。也就是前后端使用一个服务，这样自然不会有跨域问题了。实际上这已经不算是前后端分离了，只是前后端分离开发 :D)。\\n\\n### 第二种解决方案\\n第二种解决方案当然是使用官方提供的方法：CORS。Spring 下有两种方式使用 CORS：\\n\\n1. 使用注解\\n在需要提供前端跨域请求的接口上使用注解\\n\\n```\\n@CrossOrigin(origins = {\\\"http://localhost:8080\\\", \\\"null\\\"})\\n@RequestMapping(value = \\\"/helloword\\\", method = RequestMethod.Post)\\npublic String helloword() {\\n    return \\\"{\\\\\\\"message\\\\\\\": \\\\\\\"helloword\\\\\\\"}\\\";\\n}\\n```\\n这种方式是在接口级上控制跨域访问，在前后端分离的架构下，这种方式显得不大合适。\\n\\n2. 在配置类中设置 CORS\\n```\\n@Configuration\\npublic class WebMvcConfig extends WebMvcConfigurerAdapter {\\n  @Override\\n  public void addCorsMappings(CorsRegistry registry) {\\n    registry.addMapping(\\\"/**\\\")\\n            .allowedOrigins(\\\"http://localhost:8080\\\")\\n            .allowedMethods(\\\"POST\\\", \\\"GET\\\", \\\"PUT\\\", \\\"OPTIONS\\\", \\\"DELETE\\\")\\n            .maxAge(3600)\\n            .allowCredentials(true);\\n  }\\n}\\n```\\n`http://localhost:8080` 是你的 Vue 项目的服务地址和端口号，这样 Spring boot 后端服务就允许 Vue 前端跨域反问所有接口了。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg\",\"articleTitle\":\"springboot+vue跨域问题\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 13:17:02',NULL),(1146,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[71],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 13:17:58',NULL),(1147,'留言模块','修改','/admin/messages/review','com.minzheng.blog.controller.MessageController.updateMessagesReview','审核留言','[{\"idList\":[3942],\"isReview\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 15:41:16',NULL),(1148,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot集成swagger-ui+knife4j可视化api接口文档\\n\\n### springboot集成swagger-ui\\nswagger-ui官网：[swagger-ui官网](https://swagger.io/tools/swagger-ui/)\\n1. 引pom\\n``` java\\n        <dependency>\\n            <groupId>io.springfox</groupId>\\n            <artifactId>springfox-boot-starter</artifactId>\\n            <version>3.0.0</version>\\n        </dependency>\\n```\\n2. 改配置\\n添加配置文件\\n``` java\\n/**\\n * 配置\\n *\\n * @author 76218\\n * @date 2022/04/27\\n */\\n@Configuration\\n@EnableOpenApi\\npublic class SwaggerConfig {\\n\\n\\n    /**\\n     * 创建API应用\\n     * apiInfo() 增加API相关信息\\n     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，\\n     * 本例采用指定扫描的包路径来定义指定要建立API的目录。\\n     *\\n     * @return\\n     */\\n    @Bean\\n    public Docket restApi() {\\n        return new Docket(DocumentationType.SWAGGER_2)\\n                .groupName(\\\"标准接口\\\")\\n                .apiInfo(apiInfo(\\\"Spring Boot中使用Swagger2构建RESTful APIs\\\", \\\"1.0\\\"))\\n                .useDefaultResponseMessages(true)\\n                .forCodeGeneration(false)\\n                .select()\\n                .apis(RequestHandlerSelectors.basePackage(\\\"cn.icatw.springboot.controller\\\"))\\n                .paths(PathSelectors.any())\\n                .build();\\n    }\\n\\n    /**\\n     * 创建该API的基本信息（这些基本信息会展现在文档页面中）\\n     * 访问地址：http://ip:port/swagger-ui.html\\n     *\\n     * @return\\n     */\\n    private ApiInfo apiInfo(String title, String version) {\\n        return new ApiInfoBuilder()\\n                .title(title)\\n                .description(\\\"icatw: http://www.icatw.top\\\")\\n                .termsOfServiceUrl(\\\"http://www.icatw.top\\\")\\n                .contact(new Contact(\\\"icatw\\\", \\\"http://www.icatw.top\\\", \\\"762188827@qq.com\\\"))\\n                .version(version)\\n                .build();\\n    }\\n\\n\\n}\\n```\\n3. 添加注解\\n- @Api(tags = \\\"用户模块\\\")：api模块信息\\n- @ApiOperation(value = \\\"新增或修改用户信息\\\")：接口信息\\n\\n``` java\\n/**\\n * (SysUser)表控制层\\n *\\n * @author icatw\\n * @since 2022-04-26 08:37:23\\n */\\n@Api(tags = \\\"用户模块\\\")\\n@RestController\\n@RequestMapping(\\\"sysUser\\\")\\npublic class SysUserController {\\n    /**\\n     * 服务对象\\n     */\\n    @Autowired\\n    private SysUserService userService;\\n\\n    /**\\n     * 保存\\n     *\\n     * @param user 用户\\n     * @return boolean\\n     */\\n    @ApiOperation(value = \\\"新增或修改用户信息\\\")\\n    @PostMapping\\n    public boolean save(@RequestBody SysUser user) {\\n        // 新增或者更新\\n        return userService.saveOrUpdate(user);\\n    }\\n}\\n\\n```\\n\\n4. 测试\\n重启springboot项目 访问 `http://ip:port/swagger-ui.html`\\nhttp://localhost:9090/swagger-ui/index.html\\n\\n效果\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6893461959b9f38ec30233eb3545e850.png)\\n\\n### springboot集成knife4j\\n个人认为knife4j更为美观\\nknife4j官网： [knife4j官网](https://doc.xiaominfo.com/)\\n1. 引pom\\n<dependency>\\n            <groupId>com.github.xiaoymin</groupId>\\n            <artifactId>knife4j-spring-boot-starter</artifactId>\\n            <version>2.0.7</version>\\n        </dependency>\\n\\n2. 改配置\\n``` java\\n\\n/**\\n * knife4j配置\\n *\\n * @author icatw\\n * @date 2022/04/27\\n */\\n@Configuration\\n@EnableSwagger2WebMvc\\npublic class Knife4jConfiguration {\\n\\n    @Bean(value = \\\"defaultApi2\\\")\\n    public Docket defaultApi2() {\\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\\n                .apiInfo(new ApiInfoBuilder()\\n                        //.title(\\\"swagger-bootstrap-ui-demo RESTful APIs\\\")\\n                        .description(\\\"icatwの后台管理系统api接口\\\")\\n                        .termsOfServiceUrl(\\\"http://www.icatw.top/\\\")\\n                        .contact(new Contact(\\\"icatw\\\",\\\"http://www.icatw.top/\\\",\\\"762188827@qq.com\\\"))\\n                        .version(\\\"1.0\\\")\\n                        .build())\\n                //分组名称\\n                .groupName(\\\"2.X版本\\\")\\n                .select()\\n                //这里指定Controller扫描包路径\\n                .apis(RequestHandlerSelectors.basePackage(\\\"cn.icatw.springboot.controller\\\"))\\n                .paths(PathSelectors.any())\\n                .build();\\n        return docket;\\n    }\\n}\\n```\\n3. 添加注解\\n> 注解方式同swagger\\n\\n4. 重启测试\\n`http://localhost:9090/doc.html`\\n效果图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f9cad759caf6cac5caa21aca5af62337.png)\\n\\n完成！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1962ead9290560146a571c4ce2f281b.png\",\"articleTitle\":\"springboot集成可视化api接口文档\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 15:55:38',NULL),(1149,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot集成EasyPoi实现Excel数据导入导出\\n\\n> 在我们平时工作中经常会遇到要操作Excel的功能，比如导出个用户信息或者订单信息的Excel报表。你肯定听说过POI这个东西，可以实现。但是POI实现的API确实很麻烦，它需要写那种逐行解析的代码（类似Xml解析）。今天给大家推荐一款非常好用的Excel导入导出工具EasyPoi，希望对大家有所帮助！\\n\\n### EasyPoi简介 \\n用惯了SpringBoot的朋友估计会想到，有没有什么办法可以直接定义好需要导出的数据对象，然后添加几个注解，直接自动实现Excel导入导出功能？\\n\\nEasyPoi正是这么一款工具，如果你不太熟悉POI，想简单地实现Excel操作，用它就对了！\\n\\nEasyPoi的目标不是替代POI，而是让一个不懂导入导出的人也能快速使用POI完成Excel的各种操作，而不是看很多API才可以完成这样的工作。\\n\\n### 集成\\n> 在SpringBoot中集成EasyPoi非常简单，只需添加如下一个依赖即可，真正的开箱即用\\n\\n``` java\\n<dependency>\\n    <groupId>cn.afterturn</groupId>\\n    <artifactId>easypoi-spring-boot-starter</artifactId>\\n    <version>4.4.0</version>\\n</dependency>\\n```\\n\\n### 使用\\n> 接下来介绍下EasyPoi的使用，以用户信息的导入导出为例，实现下简单的单表导出\\n### 简单导出\\n\\n>我们以会员信息列表导出为例，使用EasyPoi来实现下导出功能，看看是不是够简单！\\n- 首先创建一个用户对象sysUser，封装用户信息；\\n``` java\\n/**\\n * (SysUser)表实体类\\n *\\n * @author icatw\\n * @since 2022-04-26 08:37:23\\n */\\n@EqualsAndHashCode(callSuper = true)\\n@Data\\npublic class SysUser extends Model<SysUser> {\\n    /**\\n     * id\\n     */\\n    @Excel(name = \\\"ID\\\", width = 10)\\n    @TableId(type = IdType.AUTO)\\n    private Integer id;\\n    /**\\n     * 用户名\\n     */\\n    @Excel(name = \\\"用户名\\\",width = 20,needMerge = true)\\n    private String username;\\n    /**\\n     * 密码\\n     */\\n    @JsonIgnore\\n    @Excel(name = \\\"密码\\\",width = 20,needMerge = true)\\n    private String password;\\n    /**\\n     * 昵称\\n     */\\n    @Excel(name = \\\"昵称\\\",width = 20,needMerge = true)\\n    private String nickname;\\n    /**\\n     * 电子邮件\\n     */\\n    @Excel(name = \\\"邮箱\\\",width = 20,needMerge = true)\\n    private String email;\\n    /**\\n     * 电话\\n     */\\n    @Excel(name = \\\"手机号\\\",width = 20,needMerge = true,desensitizationRule = \\\"3_4\\\")\\n    private String phone;\\n    /**\\n     * 地址\\n     */\\n    @Excel(name = \\\"地址\\\",width = 20,needMerge = true)\\n    private String address;\\n    /**\\n     * 创建时间\\n     */\\n    @Excel(name = \\\"注册时间\\\",width = 20,format = \\\"yyyy-MM-dd\\\")\\n    private Date createTime;\\n    /**\\n     * 头像\\n     */\\n    private String avatarUrl;\\n}\\n```\\n- 在此我们就可以看到EasyPoi的核心注解`@Excel`，通过在对象上添加`@Excel`注解，可以将对象信息直接导出到Excel中去，下面对注解中的属性做个介绍；\\n   - name：Excel中的列名；\\n   - width：指定列的宽度；\\n  - needMerge：是否需要纵向合并单元格；\\n  - format：当属性为时间类型时，设置时间的导出导出格式；\\n  - desensitizationRule：数据脱敏处理，3_4表示只显示字符串的前3位和后4位，其他  为*号；\\n  - replace：对属性进行替换；\\n  - suffix：对数据添加后缀。 \\n- 接下来在Controller中添加一个接口，用于导出用户列表到Excel，具体代码如下；\\n``` java\\n    /**\\n     * 导出用户列表\\n     *\\n     * @param map      地图\\n     * @param request  请求\\n     * @param response 响应\\n     */\\n    @ApiOperation(value = \\\"导出会员列表Excel\\\")\\n    @GetMapping(\\\"/export\\\")\\n    public void exportUserList(ModelMap map,\\n                               HttpServletRequest request,\\n                               HttpServletResponse response) {\\n        List<SysUser> memberList = userService.list();//此处为mp查询所有用户信息\\n\\t//先查询出用户信息封装为对象再进行导出\\n        ExportParams params = new ExportParams(\\\"用户信息列表\\\", \\\"用户信息列表\\\", ExcelType.XSSF);\\n        map.put(NormalExcelConstants.DATA_LIST, memberList);\\n        map.put(NormalExcelConstants.CLASS, SysUser.class);\\n        map.put(NormalExcelConstants.PARAMS, params);\\n        map.put(NormalExcelConstants.FILE_NAME, \\\"用户信息\\\");\\n        PoiBaseView.render(map, request, response, NormalExcelConstants.EASYPOI_EXCEL_VIEW);\\n    }\\n```\\n之后通过访问url即可导出Excel文件\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/77b92b1ebd73af5f4ef82cc5b6783d41.png)\\n\\n### 简单导入\\n>导入功能实现起来也非常简单，下面以vue的会员信息列表的导入为例\\n- 首先在controller中添加导入的接口\\n``` java\\n    /**\\n     * 导入成员列表\\n     *\\n     * @param file 文件\\n     * @return {@link List}<{@link SysUser}>\\n     * @throws Exception 异常\\n     */\\n    @ApiOperation(\\\"从Excel导入会员列表\\\")\\n    @PostMapping(\\\"/import\\\")\\n    public List<SysUser> importMemberList(@RequestPart(\\\"file\\\") MultipartFile file) throws Exception {\\n        ImportParams params = new ImportParams();\\n        params.setTitleRows(1);\\n        params.setHeadRows(1);\\n        List<SysUser> list = ExcelImportUtil.importExcel(\\n                file.getInputStream(),\\n                SysUser.class, params);\\n        log.info(list.toString());\\n        userService.saveOrUpdateBatch(list);\\n        return userService.list();\\n    }\\n```\\n- 在vue项目中添加导入按钮\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/03fcbd2e20825782fbc2da8d02c611ea.png)\\n导入按钮（element-ui中的文件上传）代码如下：\\n``` java\\n<el-upload\\n          class=\\\"upload-demo\\\"\\n          action=\\\"http://localhost:9090/sysUser/import\\\"\\n          :show-file-list=\\\"false\\\" accept=\\\"xlsx\\\" :on-success=\\\"handleExcelImportSuccess\\\" style=\\\"display: inline-block\\\">\\n        <el-button type=\\\"primary\\\" class=\\\"ml-5\\\">导入 <i class=\\\"el-icon-bottom\\\"></i></el-button>\\n      </el-upload>\\n```\\n``` text\\naction后接请求接口\\n:on-success=\\\"handleExcelImportSuccess\\\"  绑定导入成功之后的事件\\n```\\n``` java\\n   //导入Excel\\n    handleExcelImportSuccess() {\\n      this.$message.success(\\\"导入成功\\\")\\n      this.load()\\n    }\\n```\\n### 总结\\n使用easyPoi导入导出Excel数据是十分的简单的！\\n\\n### 参考资料 \\n项目官网：https://gitee.com/lemur/easypoi\\n\\n### 项目源码地址 \\nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easypo\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/84c756229e2049a2ab5e97d3ee3fb708.png\",\"articleTitle\":\"springboot集成EasyPoi实现Excel数据导入导出\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-04-27 21:18:48',NULL),(1150,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot前后端分离项目的统一配置\\n### 统一返回对象Result\\n``` java\\n/**\\n * 统一返回对象R\\n *\\n * @author icatw\\n * @since 2022-05-04 19:23:27\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class R {\\n\\n    private Integer code;\\n    private String msg;\\n    private Object data;\\n\\n    public static R ok() {\\n        return new R(ResultStatusEnum.SUCCESS.getCode(), \\\"\\\", null);\\n    }\\n\\n    public static R ok(Object data) {\\n        return new R(ResultStatusEnum.SUCCESS.getCode(), \\\"\\\", data);\\n    }\\n\\n    public static R fail(Integer code, String msg) {\\n        return new R(code, msg, null);\\n    }\\n\\n    public static R fail() {\\n        return new R(ResultStatusEnum.SYSTEM_EXCEPTION.getCode(), ResultStatusEnum.SYSTEM_EXCEPTION.getMessage(), null);\\n    }\\n\\n}\\n```\\n### 统一响应结果状态枚举类\\n``` java\\nimport lombok.AllArgsConstructor;\\nimport lombok.Getter;\\nimport lombok.NoArgsConstructor;\\nimport lombok.Setter;\\n\\n/**\\n * 响应结果状态枚举类\\n *\\n * @author icatw\\n * @date 2022/04/28\\n */\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic enum ResultStatusEnum {\\n    /**\\n     * 请求成功\\n     */\\n    SUCCESS(200, \\\"请求成功！\\\"),\\n\\n    /**\\n     * 密码错误\\n     */\\n    PASSWORD_NOT_MATCHING(300, \\\"用户名或密码错误\\\"),\\n    /**\\n     * 用户存在\\n     */\\n    USER_EXISTS(301, \\\"该用户名已存在\\\"),\\n    NO_TOKEN_EXCEPTION(302, \\\"没有token，请重新登陆\\\"),\\n    TOKEN_VERIFICATION_FAILED(303, \\\"token验证失败，请重新登录\\\"),\\n    NOT_USER(304, \\\"用户不存在，请重新登录\\\"),\\n    /**\\n     * 系统异常\\n     */\\n    SYSTEM_EXCEPTION(401, \\\"系统错误\\\"),\\n    /**\\n     * 其他异常\\n     */\\n    OTHER_EXCEPTION(500, \\\"其他错误\\\");\\n\\n    @Getter\\n    @Setter\\n    private int code;\\n\\n    @Getter\\n    @Setter\\n    private String message;\\n}\\n```\\n### 自定义异常\\n``` java\\n/**\\n * 自定义异常\\n *\\n * @author icatw\\n * @date 2022/04/28\\n */\\n@Getter\\npublic class CustomException extends RuntimeException {\\n    private int code;\\n    private String message;\\n\\n    public CustomException(int code, String message) {\\n        this.code = code;\\n        this.message = message;\\n    }\\n\\n    public CustomException(ResultStatusEnum resultStatusEnum) {\\n        this.code = resultStatusEnum.getCode();\\n        this.message = resultStatusEnum.getMessage();\\n    }\\n}\\n\\n```\\n\\n### 全局异常处理\\n``` java\\n/**\\n * 全局异常处理\\n *\\n * @author icatw\\n * @date 2022/4/28\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@ControllerAdvice\\npublic class GlobalExceptionHandle {\\n    @ResponseBody\\n    @ExceptionHandler(CustomException.class)\\n    public R handleCustomException(CustomException customException) {\\n\\n        return R.fail(customException.getCode(), customException.getMessage());\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/81ed78be39afb3fc4d1b4bcf46d7aff7.png\",\"articleTitle\":\"springboot统一结果返回集\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-04 20:20:59',NULL),(1151,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 记一次springboot跨域携带请求头token的问题\\n<p>今天在学习springboot+vue前后台分离后台管理系统的时候遇到的一个bug\\n，使用postman测试接口时可以得到后端传来的请求头，可前端死活接收不到token</p>\\n问题如下图\\n\\n\\n### postman可以请求成功\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/64141a10b524283cf2d070ccb9e173e2.png)\\n### 后端也有响应返回给前端请求头\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/771c4215439f569e1f4f697bf4dd5e0c.png)\\n\\n### 前端请求携带不上token\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d3a6f28b3d7e98a3b1d9c55cfe37329f.png)\\n### 检查前端axios请求\\n贴上axios.js的代码\\n``` java\\nimport axios from \\\"axios\\\";\\nimport router from \\\"./router\\\";\\nimport Element from \\\"element-ui\\\"\\n\\naxios.defaults.baseURL = \\\"http://localhost:8081\\\"\\n\\nconst request = axios.create({\\n    timeout: 5000,\\n    headers: {\\n        \'Content-Type\': \\\"application/json; charset=utf-8\\\"\\n    }\\n})\\n\\nrequest.interceptors.request.use(config => {\\n    config.headers[\'Authorization\'] = localStorage.getItem(\\\"token\\\")\\n    return config\\n})\\n\\nrequest.interceptors.response.use(\\n    response => {\\n\\n        console.log(\\\"response ->\\\" + response)\\n\\n        let res = response.data\\n\\n        if (res.code === 200) {\\n            return response\\n        } else {\\n            Element.Message.error(!res.msg ? \'系统异常\' : res.msg)\\n            return Promise.reject(response.data.msg)\\n        }\\n    },\\n    error => {\\n\\n        console.log(error)\\n\\n        if (error.response.data) {\\n            error.massage = error.response.data.msg\\n        }\\n\\n        if (error.response.status === 401) {\\n            router.push(\\\"/login\\\")\\n        }\\n\\n        Element.Message.error(error.massage, {duration: 3000})\\n        return Promise.reject(error)\\n    }\\n)\\n\\nexport default request\\n\\n```\\n可以看出前端vue发送请求是设置了headers的\\n\\n### 检查后端spring security\\n\\n``` java\\npackage cn.icatw.admin.security;\\n\\nimport cn.hutool.json.JSONUtil;\\nimport cn.icatw.admin.common.R;\\nimport cn.icatw.admin.utils.JwtUtil;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.Authentication;\\nimport org.springframework.security.web.authentication.AuthenticationSuccessHandler;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.servlet.ServletException;\\nimport javax.servlet.ServletOutputStream;\\nimport javax.servlet.http.HttpServletRequest;\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\n/**\\n * @author icatw\\n * @date 2022/5/5\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class LoginSuccessHandler implements AuthenticationSuccessHandler {\\n    @Autowired\\n    JwtUtil jwtUtil;\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        response.setContentType(\\\"application/json;charset=UTF-8\\\");\\n        ServletOutputStream outputStream = response.getOutputStream();\\n\\n        // 生成jwt，并放置到请求头中\\n        String jwt = jwtUtil.generateToken(authentication.getName());\\n        log.info(\\\"token为---------------------------------------\\\"+jwt);\\n        response.setHeader(jwtUtil.getHeader(), jwt);\\n\\n        R result = R.ok(\\\"\\\");\\n\\n        outputStream.write(JSONUtil.toJsonStr(result).getBytes(\\\"UTF-8\\\"));\\n\\n        outputStream.flush();\\n        outputStream.close();\\n    }\\n}\\n\\n```\\n这里也是设置成功了请求头\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/11bc45f83e2272d7e4864290ef677f7d.png)\\n\\n### 最后发现是跨域配置的问题...\\n原配置代码\\n``` java\\npackage cn.icatw.springboot.config;\\n\\nimport org.springframework.web.cors.CorsConfiguration;\\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\\nimport org.springframework.web.filter.CorsFilter;\\n\\n//@Configuration\\npublic class CorsConfig {\\n\\n    // 当前跨域请求最大有效时长。这里默认1天\\n    private static final long MAX_AGE = 24 * 60 * 60;\\n\\n    //@Bean\\n    public CorsFilter corsFilter() {\\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\\n        corsConfiguration.addAllowedOrigin(\\\"http://localhost:8080\\\"); // 1 设置访问源地址\\n        corsConfiguration.addAllowedHeader(\\\"*\\\"); // 2 设置访问源请求头\\n        corsConfiguration.addAllowedMethod(\\\"*\\\"); // 3 设置访问源请求方法\\n        corsConfiguration.setMaxAge(MAX_AGE);\\n        source.registerCorsConfiguration(\\\"/**\\\", corsConfiguration); // 4 对接口配置跨域设置\\n        return new CorsFilter(source);\\n    }\\n}\\n\\n```\\n修改后的跨域配置\\n``` java\\n/**\\n * 跨域配置\\n *\\n * @author icatw\\n * @date 2022/05/06\\n */\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    private CorsConfiguration buildConfig() {\\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\\n        corsConfiguration.addAllowedOrigin(\\\"*\\\");\\n        corsConfiguration.addAllowedHeader(\\\"*\\\");\\n        corsConfiguration.addAllowedMethod(\\\"*\\\");\\n        corsConfiguration.addExposedHeader(\\\"Authorization\\\");\\n        return corsConfiguration;\\n    }\\n\\n    @Bean\\n    public CorsFilter corsFilter() {\\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\\n        source.registerCorsConfiguration(\\\"/**\\\", buildConfig());\\n        return new CorsFilter(source);\\n    }\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n        registry.addMapping(\\\"/**\\\")\\n                .allowedOrigins(\\\"*\\\")\\n//          .allowCredentials(true)\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                .maxAge(3600);\\n    }\\n\\n}\\n```\\n加上 `corsConfiguration.addExposedHeader(\\\"Authorization\\\");`之后便能成功携带请求头访问\\n\\n又是被自己蠢哭的一次....\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9a2fceb5460b1e87030b4f1c9d817c3a.png\",\"articleTitle\":\"记一次springboot跨域携带请求头token的问题\",\"categoryName\":\"各种bug\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','111.23.44.229','湖南省长沙市 移动','2022-05-06 09:53:37',NULL),(1152,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"### vue中axios 的delete和post,put在传值上有点区别\\npost和put有三个参数，url,data和config，所以在使用这两个时，可以写成`axios.post(api,{id:1}),axios.put(api,{id:1})`,但是delete只有两个参数：url和config，data在config中，所以需要写成 `axios.delete(api,{data:{id:1}})`\\n\\n如：\\n1. 如果是服务端将参数当作Java对象来封装接收则 参数格式为：{data: param}\\n``` java\\nvar ids = []\\n      id ? ids.push(id) : this.multipleSelection.forEach(row => {\\n        ids.push(row.id)\\n      })\\n      console.log(ids)\\n      this.$axios.delete(\\\"/sys/role/\\\", {data:ids}).then(res => {\\n```\\n后端请求应该为：\\n``` java\\n    /**\\n     * 单条/批量删除数据\\n     */\\n    @ApiOperation(value = \\\"单条/批量删除数据 \\\")\\n    @DeleteMapping\\n    @PreAuthorize(\\\"hasAuthority(\'sys:role:delete\')\\\")\\n    @Transactional(rollbackFor = Exception.class)\\n    public R delete(@RequestBody List<Long> ids) {\\n        this.sysRoleService.removeByIds(ids);\\n        //同步删除中间表记录\\n        sysUserRoleService.remove(new QueryWrapper<SysUserRole>()\\n                .in(\\\"role_id\\\", ids));\\n        sysRoleMenuService.remove(new QueryWrapper<SysRoleMenu>()\\n                .in(\\\"role_id\\\", ids));\\n        //同步删除缓存权限信息\\n        for (Long id : ids) {\\n            sysUserService.clearUserAuthorityInfoByRoleId(id);\\n        }\\n        return R.ok();\\n    }\\n```\\n2. 如果服务端将参数当做url 参数 接收，则格式为：{params: param}，这样发送的url将变为http:www.XXX.com?a=…&b=…\\n\\n后端请求则应为路径变量\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg\",\"articleTitle\":\"vue的axios delete请求参数\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-06 14:40:01',NULL),(1153,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"### vue中axios 的delete和post,put在传值上有点区别\\npost和put有三个参数，url,data和config，所以在使用这两个时，可以写成`axios.post(api,{id:1}),axios.put(api,{id:1})`,但是delete只有两个参数：url和config，data在config中，所以需要写成 `axios.delete(api,{data:{id:1}})`\\n\\n如：\\n1. 如果是服务端将参数当作Java对象来封装接收则 参数格式为：{data: param}\\n``` java\\nvar ids = []\\n      id ? ids.push(id) : this.multipleSelection.forEach(row => {\\n        ids.push(row.id)\\n      })\\n      console.log(ids)\\n      this.$axios.delete(\\\"/sys/role/\\\", {data:ids}).then(res => {\\n```\\n后端请求应该为：\\n``` java\\n    /**\\n     * 单条/批量删除数据\\n     */\\n    @ApiOperation(value = \\\"单条/批量删除数据 \\\")\\n    @DeleteMapping\\n    @PreAuthorize(\\\"hasAuthority(\'sys:role:delete\')\\\")\\n    @Transactional(rollbackFor = Exception.class)\\n    public R delete(@RequestBody List<Long> ids) {\\n        this.sysRoleService.removeByIds(ids);\\n        //同步删除中间表记录\\n        sysUserRoleService.remove(new QueryWrapper<SysUserRole>()\\n                .in(\\\"role_id\\\", ids));\\n        sysRoleMenuService.remove(new QueryWrapper<SysRoleMenu>()\\n                .in(\\\"role_id\\\", ids));\\n        //同步删除缓存权限信息\\n        for (Long id : ids) {\\n            sysUserService.clearUserAuthorityInfoByRoleId(id);\\n        }\\n        return R.ok();\\n    }\\n```\\n2. 如果服务端将参数当做url 参数 接收，则格式为：{params: param}，这样发送的url将变为http:www.XXX.com?a=…&b=…\\n\\n后端请求则应为路径变量\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg\",\"articleTitle\":\"vue的axios delete请求参数\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-06 14:40:05',NULL),(1154,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[77],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-06 14:40:18',NULL),(1155,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Springboot循环依赖如何解决\\n今天在做后台管理系统的时候遇到了循环依赖的问题，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/274832222934dde59f563225f57ade7e.png)\\n于是便开始了百度(面向百度编程)...，在浏览十分钟之后找到了一种最简单的解决方法：\\n在注入的service上加上`@Lazy`注解\\n``` java\\n    @Autowired\\n    @Lazy\\n    SysUserService sysUserService;\\n//存粹是为了方便，主要是懒...\\n```\\n下面是借鉴学习大佬的一篇博客([springboot循环依赖问题](https://blog.csdn.net/qq_18298439/article/details/88818418))\\n## 1.循环依赖是什么？\\nBean A 依赖 B，Bean B 依赖 A这种情况下出现循环依赖。\\nBean A → Bean B → Bean A\\n更复杂的间接依赖造成的循环依赖如下。\\nBean A → Bean B → Bean C → Bean D → Bean E → Bean A\\n\\n## 2.循环依赖会产生什么结果？\\n当Spring正在加载所有Bean时，Spring尝试以能正常创建Bean的顺序去创建Bean。\\n例如，有如下依赖:\\nBean A → Bean B → Bean C\\nSpring先创建beanC，接着创建bean B（将C注入B中)，最后创建bean A(将B注入A中)。\\n\\n但当存在循环依赖时，Spring将无法决定先创建哪个bean。这种情况下，Spring将产生异常BeanCurrentlyInCreationException。\\n\\n## 3.普通注入之间的循环依赖\\n比如：我现在有一个ServiceA需要调用ServiceB的方法，那么ServiceA就依赖于ServiceB，那在ServiceB中再调用ServiceA的方法，就形成了循环依赖。Spring在初始化bean的时候就不知道先初始化哪个，bean就会报错。\\n``` java\\npublic class ClassA {\\n \\n@Autowired\\n \\nClassB classB;\\n \\n}\\n \\npublic class ClassB {\\n \\n@Autowired\\n \\nClassA classA\\n \\n}\\n```\\n如何解决循环依赖，最好的方法是重构代码，进行解耦，如果没有时间重构，可以使用下面的方法：\\n (1). 在你的配置文件中，在互相依赖的两个bean的任意一个加上lazy-init属性\\n``` java\\n<bean id=\\\"ServiceDependent1\\\" class=\\\"org.xyz.ServiceDependent1\\\" lazy-init=\\\"true\\\"> \\n \\n<constructor-arg ref=\\\"Service\\\"/> </bean>  \\n \\n <bean id=\\\"ServiceDependent2\\\" class=\\\"org.xyz.ServiceDependent2\\\" lazy-init=\\\"true\\\"> \\n \\n<constructor-arg ref=\\\"Service\\\"/> </bean>   \\n```\\n(2).在你注入bean时，在互相依赖的两个bean上加上@Lazy注解也可以\\n``` java\\n@Autowired     \\n \\n@Lazy      \\n \\nprivate ClassA classA; \\n \\n \\n@Autowired \\n \\n@Lazy      \\n \\nprivate ClassB classB; \\n```\\n\\n## 4. 构造器注入循环依赖实例\\n首先定义两个相互通过构造器注入依赖的bean。\\n``` java\\n@Component\\npublic class CircularDependencyA {\\n \\n    private CircularDependencyB circB;\\n \\n    @Autowired\\n    public CircularDependencyA(CircularDependencyB circB) {\\n        this.circB = circB;\\n    }\\n}\\n```\\n``` java\\n@Component\\npublic class CircularDependencyB {\\n \\n    private CircularDependencyA circA;\\n \\n    @Autowired\\n    public CircularDependencyB(CircularDependencyA circA) {\\n        this.circA = circA;\\n    }\\n}\\n```\\n\\n``` java\\n@Configuration\\n@ComponentScan(basePackages = { \\\"com.baeldung.circulardependency\\\" })\\npublic class TestConfig {\\n}\\n```\\n\\n``` java\\n\\n@RunWith(SpringJUnit4ClassRunner.class)\\n@ContextConfiguration(classes = { TestConfig.class })\\npublic class CircularDependencyTest {\\n \\n    @Test\\n    public void givenCircularDependency_whenConstructorInjection_thenItFails() {\\n        // Empty test; we just want the context to load\\n    }\\n}\\n```\\n运行方法givenCircularDependency_whenConstructorInjection_thenItFails将会产生异常：BeanCurrentlyInCreationException: Error creating bean with name ‘circularDependencyA’:\\nRequested bean is currently in creation: Is there an unresolvable circular reference?\\n\\n## 如何解决\\n（1）重新设计\\n\\n重新设计结构，消除循环依赖。\\n\\n（2）使用注解 `@Lazy`\\n\\n一种最简单的消除循环依赖的方式是通过延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象完成注入。\\n``` java\\n@Component\\npublic class CircularDependencyA {\\n \\n    private CircularDependencyB circB;\\n \\n    @Autowired\\n    public CircularDependencyA(@Lazy CircularDependencyB circB) {\\n        this.circB = circB;\\n    }\\n}\\n```\\n使用`@Lazy`后，运行代码，可以看到异常消除。\\n\\n（3）使用Setter/Field注入\\nSpring文档建议的一种方式是使用setter注入。当依赖最终被使用时才进行注入。对前文的样例代码少做修改，来观察测试效果。\\n``` java\\n@Component\\npublic class CircularDependencyA {\\n \\n    private CircularDependencyB circB;\\n \\n    @Autowired\\n    public void setCircB(CircularDependencyB circB) {\\n        this.circB = circB;\\n    }\\n \\n    public CircularDependencyB getCircB() {\\n        return circB;\\n    }\\n}\\n```\\n``` java\\n@Component\\npublic class CircularDependencyB {\\n \\n    private CircularDependencyA circA;\\n \\n    private String message = \\\"Hi!\\\";\\n \\n    @Autowired\\n    public void setCircA(CircularDependencyA circA) {\\n        this.circA = circA;\\n    }\\n \\n    public String getMessage() {\\n        return message;\\n    }\\n}\\n```\\n``` java\\n@RunWith(SpringJUnit4ClassRunner.class)\\n@ContextConfiguration(classes = { TestConfig.class })\\npublic class CircularDependencyTest {\\n \\n    @Autowired\\n    ApplicationContext context;\\n \\n    @Bean\\n    public CircularDependencyA getCircularDependencyA() {\\n        return new CircularDependencyA();\\n    }\\n \\n    @Bean\\n    public CircularDependencyB getCircularDependencyB() {\\n        return new CircularDependencyB();\\n    }\\n \\n    @Test\\n    public void givenCircularDependency_whenSetterInjection_thenItWorks() {\\n        CircularDependencyA circA = context.getBean(CircularDependencyA.class);\\n \\n        Assert.assertEquals(\\\"Hi!\\\", circA.getCircB().getMessage());\\n    }\\n}\\n```\\n\\n（4） 使用@PostConstruct\\n``` java\\n@Component\\npublic class CircularDependencyA {\\n \\n    @Autowired\\n    private CircularDependencyB circB;\\n \\n    @PostConstruct\\n    public void init() {\\n        circB.setCircA(this);\\n    }\\n \\n    public CircularDependencyB getCircB() {\\n        return circB;\\n    }\\n}\\n \\n```\\n\\n``` java\\n@Component\\npublic class CircularDependencyB {\\n \\n    private CircularDependencyA circA;\\n     \\n    private String message = \\\"Hi!\\\";\\n \\n    public void setCircA(CircularDependencyA circA) {\\n        this.circA = circA;\\n    }\\n     \\n    public String getMessage() {\\n        return message;\\n    }\\n \\n```\\n\\n（5）实现ApplicationContextAware与InitializingBean\\n\\n``` java\\n@Component\\npublic class CircularDependencyA implements ApplicationContextAware, InitializingBean {\\n \\n    private CircularDependencyB circB;\\n \\n    private ApplicationContext context;\\n \\n    public CircularDependencyB getCircB() {\\n        return circB;\\n    }\\n \\n    @Override\\n    public void afterPropertiesSet() throws Exception {\\n        circB = context.getBean(CircularDependencyB.class);\\n    }\\n \\n    @Override\\n    public void setApplicationContext(final ApplicationContext ctx) throws BeansException {\\n        context = ctx;\\n    }\\n}\\n```\\n``` java\\n@Component\\npublic class CircularDependencyB {\\n \\n    private CircularDependencyA circA;\\n \\n    private String message = \\\"Hi!\\\";\\n \\n    @Autowired\\n    public void setCircA(CircularDependencyA circA) {\\n        this.circA = circA;\\n    }\\n \\n    public String getMessage() {\\n        return message;\\n    }\\n}\\n```\\n## 总结：我认为对于个人开发使用`@Lazy`或者setter注入的方式会更为简单方便！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/140a0e8e8883c566c717a918ca85cda1.png\",\"articleTitle\":\"springboot循环依赖及解决方法\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"https://blog.csdn.net/qq_18298439/article/details/88818418\",\"status\":1,\"tagNameList\":[],\"type\":2}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-09 14:17:20',NULL),(1156,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1\",\"articleCover\":\"\",\"articleTitle\":\"2022-05-11\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-11 13:51:33',NULL),(1157,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[80],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-11 13:51:47',NULL),(1158,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[69,68,64,63,61,58],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-11 13:52:00',NULL),(1159,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 问题描述：\\nSpringBoot项目中集成了knife4j，在将SpringBoot更新到2.6.0后启动项目报错 Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException，导致系统不能正常启动。\\n详细报错如下：\\n``` java\\nError starting ApplicationContext. To display the conditions report re-run your application with \'debug\' enabled.\\n2021-12-23 16:52:35.735 ERROR 15348 --- [           main] o.s.boot.SpringApplication               : Application run failed\\n\\norg.springframework.context.ApplicationContextException: Failed to start bean \'documentationPluginsBootstrapper\'; nested exception is java.lang.NullPointerException\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:181)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:54)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:356)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor$$Lambda$778/18341126.accept(Unknown Source)\\n\\tat java.lang.Iterable.forEach(Iterable.java:75)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:155)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:123)\\n\\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:935)\\n\\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586)\\n\\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145)\\n\\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:730)\\n\\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:302)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1301)\\n\\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1290)\\n\\tat com.chqiuu.test.TestApplication.main(TestApplication.java:23)\\nCaused by: java.lang.NullPointerException: null\\n\\tat springfox.documentation.spring.web.WebMvcPatternsRequestConditionWrapper.getPatterns(WebMvcPatternsRequestConditionWrapper.java:56)\\n\\tat springfox.documentation.RequestHandler.sortedPaths(RequestHandler.java:113)\\n\\tat springfox.documentation.spi.service.contexts.Orderings.lambda$byPatternsCondition$3(Orderings.java:89)\\n\\tat springfox.documentation.spi.service.contexts.Orderings$$Lambda$796/7205235.apply(Unknown Source)\\n\\tat java.util.Comparator.lambda$comparing$77a9974f$1(Comparator.java:469)\\n\\tat java.util.Comparator$$Lambda$68/3330950.compare(Unknown Source)\\n\\tat java.util.TimSort.countRunAndMakeAscending(TimSort.java:351)\\n\\tat java.util.TimSort.sort(TimSort.java:230)\\n\\tat java.util.Arrays.sort(Arrays.java:1512)\\n\\tat java.util.ArrayList.sort(ArrayList.java:1454)\\n\\tat java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:387)\\n\\tat java.util.stream.Sink$ChainedReference.end(Sink.java:258)\\n\\tat java.util.stream.Sink$ChainedReference.end(Sink.java:258)\\n\\tat java.util.stream.Sink$ChainedReference.end(Sink.java:258)\\n\\tat java.util.stream.Sink$ChainedReference.end(Sink.java:258)\\n\\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)\\n\\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\\n\\tat java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\\n\\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\\n\\tat java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\\n\\tat springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:81)\\n\\tat springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper$$Lambda$790/3038834.apply(Unknown Source)\\n\\tat java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\\n\\tat java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374)\\n\\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)\\n\\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\\n\\tat java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\\n\\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\\n\\tat java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\\n\\tat springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.withDefaults(AbstractDocumentationPluginsBootstrapper.java:107)\\n\\tat springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.buildContext(AbstractDocumentationPluginsBootstrapper.java:91)\\n\\tat springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.bootstrapDocumentationPlugins(AbstractDocumentationPluginsBootstrapper.java:82)\\n\\tat springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:100)\\n\\tat org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:178)\\n\\t... 15 common frames omitted\\n\\n```\\n## 解决方案：\\n这个问题困扰了我很久，也在网上找了好多资料，也有些人说springboot版本升级的导致的问题。\\n找到的解决办法有两种： \\n1. 将springboot降级到2.5.7，但这也只是暂时解决问题的办法，不是长久之计；\\n2. 从SpringFox迁移到SpringDoc，这种方式虽然可以处理问题，但对于已经上线的项目来说改动量还是有点大。\\n这上面两种解决方案都不是我最想要的，最近对Spring Boot 2.6.0的文档进行研究发现，2.6.0开始使用基于PathPatternParser的路径匹配，而Springfox版本一直没有更新还是使用的AntPathMatcher导致了这个问题，要处理问题也很简单，修改yaml文件，将SpringBoot路劲匹配模式修改为AntPathMatcher就可以了，配置如下：`spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER`\\n\\n修改application.yml文件配置\\n``` java\\nspring:\\n  mvc:\\n    pathmatch:\\n      matching-strategy: ANT_PATH_MATCHER\\n\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png\",\"articleTitle\":\"SpringBoot2.6.0集成knife4j启动报错问题处理\",\"categoryName\":\"各种bug\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-11 14:48:13',NULL),(1160,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot集成谷歌kaptcha验证码功能\\n\\n### 引入maven依赖\\n``` java\\n  <!--        谷歌验证码-->\\n        <dependency>\\n            <groupId>com.github.axet</groupId>\\n            <artifactId>kaptcha</artifactId>\\n            <version>0.0.9</version>\\n        </dependency>\\n```\\n### kaptcha配置类\\n\\n``` java\\n/**\\n * 验证码配置\\n *\\n * @author icatw\\n * @date 2022/5/11\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Configuration\\npublic class CaptchaConfig {\\n    @Bean\\n    public DefaultKaptcha getDefaultKaptcha() {\\n        //验证码生成器\\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\\n        //配置\\n        Properties properties = new Properties();\\n        //是否有边框\\n        properties.setProperty(\\\"kaptcha.border\\\", \\\"yes\\\");\\n        //设置边框颜色\\n        properties.setProperty(\\\"kaptcha.border.color\\\", \\\"105,179,90\\\");\\n        //边框粗细度，默认为1\\n        // properties.setProperty(\\\"kaptcha.border.thickness\\\",\\\"1\\\");\\n        //验证码\\n        properties.setProperty(\\\"kaptcha.session.key\\\", \\\"code\\\");\\n        //验证码文本字符颜色 默认为黑色\\n        properties.setProperty(\\\"kaptcha.textproducer.font.color\\\", \\\"blue\\\");\\n        //设置字体样式\\n        properties.setProperty(\\\"kaptcha.textproducer.font.names\\\", \\\"宋体,楷体,微软雅黑\\\");\\n        //字体大小，默认40\\n        properties.setProperty(\\\"kaptcha.textproducer.font.size\\\", \\\"30\\\");\\n        //验证码文本字符内容范围 默认为abced2345678gfynmnpwx\\n        // properties.setProperty(\\\"kaptcha.textproducer.char.string\\\", \\\"\\\");\\n        //字符长度，默认为5\\n        properties.setProperty(\\\"kaptcha.textproducer.char.length\\\", \\\"5\\\");\\n        //字符间距 默认为2\\n        properties.setProperty(\\\"kaptcha.textproducer.char.space\\\", \\\"4\\\");\\n        //验证码图片宽度 默认为200\\n        properties.setProperty(\\\"kaptcha.image.width\\\", \\\"100\\\");\\n        //验证码图片高度 默认为40\\n        properties.setProperty(\\\"kaptcha.image.height\\\", \\\"40\\\");\\n        Config config = new Config(properties);\\n        defaultKaptcha.setConfig(config);\\n        return defaultKaptcha;\\n    }\\n}\\n```\\n### Controller层使用\\n\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/5/11\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Slf4j\\n@RestController\\npublic class CaptchaController {\\n    @Autowired\\n    private DefaultKaptcha defaultKaptcha;\\n\\n    @ApiOperation(value = \\\"验证码\\\")\\n    @GetMapping(value = \\\"/captcha\\\",produces = \\\"image/jpeg\\\")\\n    public void captcha(HttpServletRequest request, HttpServletResponse response) {\\n        // 定义response输出类型为image/jpeg类型\\n        response.setDateHeader(\\\"Expires\\\", 0);\\n        // Set standard HTTP/1.1 no-cache headers.\\n        response.setHeader(\\\"Cache-Control\\\", \\\"no-store, no-cache, mustrevalidate\\\");\\n        // Set IE extended HTTP/1.1 no-cache headers (use addHeader).\\n        response.addHeader(\\\"Cache-Control\\\", \\\"post-check=0, pre-check=0\\\");\\n        // Set standard HTTP/1.0 no-cache header.\\n        response.setHeader(\\\"Pragma\\\", \\\"no-cache\\\");\\n        // return a jpeg\\n        response.setContentType(\\\"image/jpeg\\\");\\n        //---------------生成验证码begin\\n        //获取验证码文本内容\\n        String text = defaultKaptcha.createText();\\n        log.info(\\\"验证码内容为：\\\" + text);\\n        //将验证码文本内容放入session，//TODO 可优化为存入redis\\n        request.getSession().setAttribute(\\\"captcha\\\", text);\\n        //根据文本验证码内容创建图形验证码\\n        BufferedImage image = defaultKaptcha.createImage(text);\\n        ServletOutputStream outputStream = null;\\n        try {\\n            outputStream = response.getOutputStream();\\n            //输出流输出图片，格式为jpg\\n            ImageIO.write(image, \\\"jpg\\\", outputStream);\\n            outputStream.flush();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } finally {\\n            if (outputStream != null) {\\n                try {\\n                    outputStream.close();\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n        }\\n        //---------------生成验证码end\\n    }\\n}\\n```\\n### 测试效果\\n![_PN0CBQT7~J9I0ETFY.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dfd3dca49d70eaaae9878797737ed8fa.png)\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dfd3dca49d70eaaae9878797737ed8fa.png\",\"articleTitle\":\"springboot集成谷歌验证码\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 09:49:33',NULL),(1161,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n\\n### 重点方法\\n当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n1. `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n\\n2. `HttpSecurity`\\n具体的权限控制规则配置\\n\",\"articleCover\":\"\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 14:40:20',NULL),(1162,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n**百度所得：**\\n- **原因分析**： 自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器。\\n- **解决办法**： 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\n这里我按照这个方法修改了代码，可还是走了过滤器链...\\n具体原因，之后有空再研究一下\\n**最终还是选择使用`WebSecurity`配置忽略地址**\\n### 总结\\n1. 当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n(1)  . `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n(2). `HttpSecurity`\\n具体的权限控制规则配置\\n2. 当我们使用依赖注入的方式注入过滤器时,自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器\\n- **解决办法**： \\n\\t- 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\t- **使用WebSecurity配置忽略名单，这里我采用的是这种方式**\\n   \\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/df9c1307704f20ebaf55d7a0ffffe126.jpg\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"categoryName\":\"各种bug\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 14:52:44',NULL),(1163,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## Spring boot @putmapping接收参数为null的问题\\n> 今天遇到了前端使用restful风格传参时，后端使用@PutMapping接收参数为null的问题\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/be8d1da446e777455dac66702908edf6.png)\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0b51411632a1f17635898ea6273784e5.png)\\n\\n### 原因\\n使用了`public class SwaggerWebMvcConfig extends WebMvcConfigurationSupport`\\n``` java\\n@Configuration\\npublic class SwaggerWebMvcConfig extends WebMvcConfigurationSupport {\\n    //WebMvcConfigurationSupport\\n    //WebMvcConfigurer\\n    @Override\\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\\n        registry.addResourceHandler(\\\"swagger-ui.html\\\")\\n                .addResourceLocations(\\\"classpath:/META-INF/resources/\\\");\\n        registry.addResourceHandler(\\\"doc.html\\\").addResourceLocations(\\\"classpath:/META-INF/resources/\\\");\\n        registry.addResourceHandler(\\\"/webjars/**\\\")\\n                .addResourceLocations(\\\"classpath:/META-INF/resources/webjars/\\\");\\n    }\\n}\\n```\\n### 解决方法\\n将原代码修改为\\n``` java\\n/**\\n * swagger mvc配置\\n *\\n * @author icatw\\n * @date 2022/05/05\\n */\\n@Configuration\\npublic class SwaggerWebMvcConfig implements WebMvcConfigurer {\\n    //WebMvcConfigurationSupport\\n    //WebMvcConfigurer\\n    @Override\\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\\n        registry.addResourceHandler(\\\"swagger-ui.html\\\")\\n                .addResourceLocations(\\\"classpath:/META-INF/resources/\\\");\\n        registry.addResourceHandler(\\\"doc.html\\\").addResourceLocations(\\\"classpath:/META-INF/resources/\\\");\\n        registry.addResourceHandler(\\\"/webjars/**\\\")\\n                .addResourceLocations(\\\"classpath:/META-INF/resources/webjars/\\\");\\n    }\\n}\\n```\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2904b329e08607f13e50d22582c9716d.jpg\",\"articleTitle\":\"Spring boot @putmapping接收参数为null解决与理解\",\"categoryName\":\"各种bug\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 23:22:37',NULL),(1164,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n**百度所得：**\\n- **原因分析**： 自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器。\\n- **解决办法**： 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\n这里我按照这个方法修改了代码，可还是走了过滤器链...\\n具体原因，之后有空再研究一下\\n**最终还是选择使用`WebSecurity`配置忽略地址**\\n### 总结\\n1. 当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n(1)  . `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n(2). `HttpSecurity`\\n具体的权限控制规则配置\\n2. 当我们使用依赖注入的方式注入过滤器时,自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器\\n- **解决办法**： \\n\\t- 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\t- **使用WebSecurity配置忽略名单，这里我采用的是这种方式**\\n   \\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/df9c1307704f20ebaf55d7a0ffffe126.jpg\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"categoryName\":\"各种bug\",\"id\":84,\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 23:34:16',NULL),(1165,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n\\n### 重点方法\\n当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n1. `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n\\n2. `HttpSecurity`\\n具体的权限控制规则配置\\n\",\"articleCover\":\"\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"id\":83,\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 23:43:40',NULL),(1166,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n**百度所得：**\\n- **原因分析**： 自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器。\\n- **解决办法**： 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\n这里我按照这个方法修改了代码，可还是走了过滤器链...\\n具体原因，之后有空再研究一下\\n**最终还是选择使用`WebSecurity`配置忽略地址**\\n### 总结\\n1. 当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n(1)  . `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n(2). `HttpSecurity`\\n具体的权限控制规则配置\\n2. 当我们使用依赖注入的方式注入过滤器时,自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器\\n- **解决办法**： \\n\\t- 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\t- **使用WebSecurity配置忽略名单，这里我采用的是这种方式**\\n   \\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/df9c1307704f20ebaf55d7a0ffffe126.jpg\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"categoryName\":\"各种bug\",\"id\":84,\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 23:45:09',NULL),(1167,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## spring boot security设置忽略地址不生效\\n今天在做项目引入swagger2+knife4j的的时候，出现了springsecurity忽略地址不生效的问题，这个问题是在添加了\\n``` java\\n//动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n```\\n之后出现的，报错如下\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/26d802a707a741431ec9634264913973.png)\\n### 最初security主要代码如下：\\n这个是忽略地址\\n``` java\\n  private static final String[] URL_WHITELIST = {\\n            \\\"/login\\\",\\n            \\\"/logout\\\",\\n            \\\"/captcha\\\",\\n            \\\"favicon.ico\\\",\\n            \\\"/swagger-ui.html/**\\\",\\n            \\\"/webjars/**\\\",\\n            \\\"/v2/**\\\",\\n            \\\"/swagger-resources/**\\\",\\n            \\\"/doc.html\\\",\\n            \\\"/upload\\\"\\n    };\\n```\\nsecurity配置：\\n``` java\\n @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                .antMatchers(URL_WHITELIST)\\n                .permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n### 修改后代码\\n\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        //使用jwt，不需要csrf\\n        http.csrf()\\n                .disable()\\n                //基于token不需要session\\n                .sessionManagement()\\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                //允许登录访问\\n                .and()\\n                .authorizeRequests()\\n                //.antMatchers(URL_WHITELIST)\\n                //.permitAll()\\n                //除了上面,所有请求都需要认证\\n                .anyRequest()\\n                .authenticated()\\n                //动态权限配置\\n                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\\n                    @Override\\n                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {\\n                        object.setAccessDecisionManager(customUrlDecisionManager);\\n                        object.setSecurityMetadataSource(customFilter);\\n                        return object;\\n                    }\\n                })\\n                //禁用缓存\\n                .and()\\n                .headers()\\n                .cacheControl();\\n        //    添加jwt登陆授权拦截器，在验证密码的前面添加拦截器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);\\n        //    添加自定义未授权和未登录结果返回\\n        http.exceptionHandling()\\n                .accessDeniedHandler(accessDeniedHandler)\\n                .authenticationEntryPoint(authenticationEntryPoint);\\n\\n    }\\n```\\n添加了如下代码之后便可以正常放行忽略地址，也能正常访问接口文档\\n``` java\\n@Override\\n    public void configure(WebSecurity web) throws Exception {\\n        //忽略白名单，放行以下路径\\n        web.ignoring().antMatchers(URL_WHITELIST);\\n    }\\n```\\n可idea控制台又出现了新的问题....\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c5d9f183df6cadaf950d9e8e42eadd35.png)\\n通过翻译得知，当前springboot版本不推荐这种忽略地址的方式，应该改为HttpSecurity中忽略\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/8a8854c167a5c7c3ef26b569b0a1ca01.png)\\n### 于是进行二次修改\\n通过半个小时的百度以及代码修改之后，自信的run项目，又出现了空指针异常...\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ca4036f61ec8e194bb146e83e89f5e73.png)\\n**百度所得：**\\n- **原因分析**： 自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器。\\n- **解决办法**： 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\n这里我按照这个方法修改了代码，可还是走了过滤器链...\\n具体原因，之后有空再研究一下\\n**最终还是选择使用`WebSecurity`配置忽略地址**\\n### 总结\\n1. 当我们继承`WebSecurityConfigurerAdapter`之后，重写`configure`方法是有两个不同的参数的：\\n(1)  . `WebSecurity`\\n全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局HttpFirewall配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor、\\n(2). `HttpSecurity`\\n具体的权限控制规则配置\\n2. 当我们使用依赖注入的方式注入过滤器时,自定义过滤器交给了spring IOC管理，所以你在spring Security的config无论怎么配都会走到自己的过滤器\\n- **解决办法**： \\n\\t- 自定义过滤器不能以bean的形式注入spring IOC，交给容器管理，检查自定义过滤器是否有以@bean、@component、@configuration的形式注入到spring IOC容器，如果有去掉即可。\\n\\t- **使用WebSecurity配置忽略名单，这里我采用的是这种方式**\\n   \\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/df9c1307704f20ebaf55d7a0ffffe126.jpg\",\"articleTitle\":\"spring boot security设置忽略地址不生效的解决\",\"categoryName\":\"各种bug\",\"id\":84,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-12 23:45:29',NULL),(1168,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"### 问题描述\\n> 在使用knife4j测试easyPoi导出Excel接口时出现了乱码问题\\n![_G7HFWODPDM35B99.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9f14607471ff104a270e5eda1f9ffacc.png)\\n\\n### 解决方法：\\n\\n添加`produces` 属性\\n``` java\\n  @ApiOperation(value = \\\"导出员工数据\\\")\\n  @GetMapping(value = \\\"/export\\\", produces = \\\"application/octet-stream\\\")\\n```\\n完整代码\\n``` java\\n    @ApiOperation(value = \\\"导出员工数据\\\")\\n    @GetMapping(value = \\\"/export\\\", produces = \\\"application/octet-stream\\\")\\n    public void exportEmployee(HttpServletResponse response) {\\n        List<Employee> list = employeeService.getEmployee(null);\\n        ExportParams params = new ExportParams(\\\"员工表\\\", \\\"员工表\\\", ExcelType.HSSF);\\n        Workbook book = ExcelExportUtil.exportExcel(params, Employee.class, list);\\n        ServletOutputStream out = null;\\n        try {\\n            //流形式\\n            response.setHeader(\\\"content-type\\\", \\\"application/octet-stream\\\");\\n            //防止中文乱码\\n            response.setHeader(\\\"content-disposition\\\", \\\"attachment;filename=\\\" +\\n                    URLEncoder.encode(\\\"员工表.xls\\\", \\\"UTF-8\\\"));\\n            out = response.getOutputStream();\\n            book.write(out);\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            if (null != out) {\\n                try {\\n                    out.flush();\\n                    out.close();\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n        }\\n    }\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/9f14607471ff104a270e5eda1f9ffacc.png\",\"articleTitle\":\"swagger knife4j 解决接口下载文件响应乱码问题\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-14 00:31:33',NULL),(1169,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## springboot集成mail实现邮件发送\\n### 引入pom依赖\\n``` java\\n  \\t<!--mail 依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-mail</artifactId>\\n        </dependency>\\n        <!--thymeleaf 依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\\n        </dependency>\\n\\n```\\n这里使用thymeleaf作为邮件的html模板\\n\\n### 添加配置信息\\n``` java\\nserver:\\n  # 端口\\n  port: 8082\\nspring:\\n  # 邮件配置\\n  mail:\\n    # 邮件服务器地址\\n    host: smtp.qq.com\\n    # 协议\\n    protocol: smtp\\n    # 编码格式\\n    default-encoding: utf-8\\n    # 授权码（在邮箱开通服务时获取）\\n    password: qxazsukhylrrbcjd\\n    # 发送者邮箱地址\\n    username: 762188827@qq.com\\n    # 端口（不同邮箱端口号不同）\\n    port: 25\\n```\\n### thymeleaf模板\\nmail.html\\n``` html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\" xmlns:th=\\\"http://www.thymeleaf.org\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>入职欢迎邮件</title>\\n</head>\\n<body>\\n欢迎 <span th:text=\\\"${name}\\\"></span> 加入 云e办 大家庭，您的入职信息如下：\\n<table border=\\\"1\\\">\\n    <tr>\\n        <td>姓名</td>\\n        <td th:text=\\\"${name}\\\"></td>\\n    </tr>\\n    <tr>\\n        <td>职位</td>\\n        <td th:text=\\\"${posName}\\\"></td>\\n    </tr>\\n    <tr>\\n        <td>职称</td>\\n        <td th:text=\\\"${joblevelName}\\\"></td>\\n    </tr>\\n    <tr>\\n        <td>部门</td>\\n        <td th:text=\\\"${departmentName}\\\"></td>\\n    </tr>\\n</table>\\n<p>我们公司的工作忠旨是严格，创新，诚信，您的加入将为我们带来新鲜的血液，带来创新的思维，以及为\\n    我们树立良好的公司形象!希望在以后的工作中我们能够齐心协力，与时俱进，团结协作!同时也祝您在本公\\n    司，工作愉快，实现自己的人生价值!希望在未来的日子里，携手共进！</p>\\n</body>\\n</html>\\n\\n```\\n### mail监听器（集成了rabbitMq消息可靠性以及使用redis实现幂等性）\\n``` java\\npackage cn.icatw.yeb.mail.receiver;\\n\\nimport cn.icatw.yeb.server.common.Constants.MailConstants;\\nimport cn.icatw.yeb.server.domain.Employee;\\nimport com.rabbitmq.client.Channel;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\\nimport org.springframework.amqp.support.AmqpHeaders;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.boot.autoconfigure.mail.MailProperties;\\nimport org.springframework.data.redis.core.HashOperations;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.mail.javamail.JavaMailSender;\\nimport org.springframework.mail.javamail.MimeMessageHelper;\\nimport org.springframework.messaging.Message;\\nimport org.springframework.messaging.MessageHeaders;\\nimport org.springframework.stereotype.Component;\\nimport org.thymeleaf.TemplateEngine;\\nimport org.thymeleaf.context.Context;\\n\\nimport javax.mail.internet.MimeMessage;\\nimport java.io.IOException;\\nimport java.util.Date;\\n\\n/**\\n * 邮件接收方\\n *\\n * @author icatw\\n * @date 2022/5/14\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class MailReceiver {\\n    //日志记录，相当于slf4j\\n    //private static final Log LOG = LogFactory.getLog(MailReceiver.class);\\n    @Autowired\\n    private JavaMailSender javaMailSender;\\n    @Autowired\\n    private MailProperties mailProperties;\\n    @Autowired\\n    private TemplateEngine templateEngine;\\n\\n    @Autowired\\n    private RedisTemplate redisTemplate;\\n\\n    /**\\n     * 处理程序\\n     * 监听rabbitMq发送来的消息（携带员工信息），进行邮件发送\\n     *\\n     * @param message 消息\\n     * @param channel 通道\\n     */\\n    @RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)\\n    public void handler(Message<Employee> message, Channel channel) {\\n        //从消息负载中获取员工信息\\n        Employee employee = message.getPayload();\\n        MessageHeaders headers = message.getHeaders();\\n        //消息序号\\n        long tag = (long) headers.get(AmqpHeaders.DELIVERY_TAG);\\n        String msgId = (String) headers.get(\\\"spring_returned_message_correlation\\\");\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        try {\\n            if (hashOperations.entries(\\\"mail_log\\\").containsKey(msgId)) {\\n                //[d, f, 2, 8, e, 7, 9, 0, -, 9, 8, a, e, -, 4, 3, a, c, -, a, e, f, 1, -, 9, 0, 8, 4, c, 0, 5, 2, 7, 5, 8, 9]\\n                //    redis中包含key，说明消息已经被消费，手动确认，直接返回\\n                log.info(\\\"消息已经被消费======>{}\\\", msgId);\\n                /**\\n                 * 手动确认消息\\n                 * tag：消息序号\\n                 * multiple：是否多条\\n                 */\\n                channel.basicAck(tag, false);\\n                return;\\n            }\\n            MimeMessage msg = javaMailSender.createMimeMessage();\\n            MimeMessageHelper helper = new MimeMessageHelper(msg);\\n            //设置邮件相关信息\\n            //发件人\\n            helper.setFrom(mailProperties.getUsername());\\n            //收件人\\n            helper.setTo(employee.getEmail());\\n            //    主题\\n            helper.setSubject(\\\"入职欢迎邮件\\\");\\n            //    发送日期’\\n            helper.setSentDate(new Date());\\n            //    邮件内容，将员工信息设置到thymeleaf上下文中\\n            Context context = new Context();\\n            context.setVariable(\\\"name\\\", employee.getName());\\n            context.setVariable(\\\"posName\\\", employee.getPosition().getName());\\n            context.setVariable(\\\"joblevelName\\\", employee.getJoblevel().getName());\\n            context.setVariable(\\\"departmentName\\\", employee.getDepartment().getName());\\n            String mail = templateEngine.process(\\\"mail\\\", context);\\n            //将thymeleaf模板内容设置为邮件文本内容\\n            helper.setText(mail, true);\\n            javaMailSender.send(msg);\\n            log.info(\\\"邮件发送成功！\\\");\\n            //    将消息id存入redis\\n            assert msgId != null;\\n            hashOperations.put(\\\"mail_log\\\", msgId, \\\"OK\\\");\\n            //    手动确认消息\\n            channel.basicAck(tag, false);\\n\\n        } catch (Exception e) {\\n            try {\\n                channel.basicNack(tag, false, true);\\n            } catch (IOException ex) {\\n                log.error(\\\"消息确认失败=====>{}\\\", ex.getMessage());\\n            }\\n            log.error(\\\"邮件发送失败======>{}\\\", e.getMessage());\\n        }\\n    }\\n}\\n\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg\",\"articleTitle\":\"springboot实现邮件发送\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-18 10:14:27',NULL),(1170,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"### 错误描述\\n``` java\\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of org.springframework.security.core.GrantedAuthority (no Creators, like default constructor, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\\n```\\n截图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/0973aa2cfe375a6fa497faff538557ef.png)\\n\\n\\n虽然该类实现了序列化 但是这个集合不能被解析\\n\\n其实就是在spring security 权限集合反序列化失败\\n``` java\\n   @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        List<SimpleGrantedAuthority> authorities = new ArrayList<>();\\n        for (Role role : roles) {\\n            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role.getName());\\n            authorities.add(authority);\\n        }\\n        return authorities;\\n    }\\n\\n```\\n这时候我们就需要自定义一个反序列化的类\\n``` java\\npublic class CustomAuthorityDeserializer extends JsonDeserializer {\\n    @Override\\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {\\n        ObjectMapper mapper = (ObjectMapper) p.getCodec();\\n        JsonNode jsonNode = mapper.readTree(p);\\n        LinkedList<GrantedAuthority> grantedAuthorities = new LinkedList<>();\\n        Iterator<JsonNode> elements = jsonNode.elements();\\n        while (elements.hasNext()) {\\n            JsonNode next = elements.next();\\n            JsonNode authority = next.get(\\\"authority\\\");\\n            //将得到的值放入链表 最终返回该链表\\n            grantedAuthorities.add(new SimpleGrantedAuthority(authority.asText()));\\n        }\\n        return grantedAuthorities;\\n    }\\n}\\n```\\n同时加上一个注解 自定义解析即可生效\\n@JsonDeserialize(using = CustomAuthorityDeserializer.class)\\n\\n    @Override\\n    @JsonDeserialize(using = CustomAuthorityDeserializer.class)\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        List<SimpleGrantedAuthority> authorities = new ArrayList<>();\\n        for (Role role : roles) {\\n            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role.getName());\\n            authorities.add(authority);\\n        }\\n        return authorities;\\n    }\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/80905339870b8aec953379cf5f2c2d11.jpg\",\"articleTitle\":\"GrantedAuthority错误解决\",\"categoryName\":\"各种bug\",\"isTop\":0,\"originalUrl\":\"https://blog.csdn.net/weixin_44353507/article/details/113596584\",\"status\":1,\"tagNameList\":[],\"type\":2}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-18 12:07:01',NULL),(1171,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>云e办项目总结\\n## 前言\\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\\n## 项目截图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bd834fb89b70fbedb46816144282a1f.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\\n## 功能模块\\n- 员工资料：基本资料、高级资料\\n- 人事管理（尚未开发）\\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\\n- 统计管理（尚未开发）\\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\\n- websocket在线聊天\\n## 项目技术栈\\n### 后端技术栈\\n1. Spring Boot\\n2. Spring Security\\n3. Mybatis+Mybatis-Plus\\n4. Redis\\n5. RabbitMQ\\n6. WebSocket\\n7. 阿里云oss\\n8. mail\\n9. ...\\n\\n### 前端技术栈\\n1. Vue\\n2. ElementUI\\n3. axios\\n4. vue-router\\n5. Vuex\\n6. WebSocket\\n7. vue-cli4\\n8. ...\\n\\n## 项目源码\\ngitee：https://gitee.com/icatw/cloudEOffice\\ngithub：https://github.com/icatw/cloudEOffice\\n\\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\\n\",\"articleCover\":\"\",\"articleTitle\":\"云e办项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-21 12:34:04',NULL),(1172,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>云e办项目总结\\n## 前言\\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\\n## 项目截图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6bd834fb89b70fbedb46816144282a1f.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\\n## 功能模块\\n- 员工资料：基本资料、高级资料\\n- 人事管理（尚未开发）\\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\\n- 统计管理（尚未开发）\\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\\n- websocket在线聊天\\n## 项目技术栈\\n### 后端技术栈\\n1. Spring Boot\\n2. Spring Security\\n3. Mybatis+Mybatis-Plus\\n4. Redis\\n5. RabbitMQ\\n6. WebSocket\\n7. 阿里云oss\\n8. mail\\n9. ...\\n\\n### 前端技术栈\\n1. Vue\\n2. ElementUI\\n3. axios\\n4. vue-router\\n5. Vuex\\n6. WebSocket\\n7. vue-cli4\\n8. ...\\n\\n## 项目源码\\ngitee：https://gitee.com/icatw/cloudEOffice\\ngithub：https://github.com/icatw/cloudEOffice\\n\\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png\",\"articleTitle\":\"云e办项目总结\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-21 12:38:59',NULL),(1173,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>云e办项目总结\\n## 前言\\n本项目基于b站的云e办项目，视频链接：<a>https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web<a/>，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\\n## 项目截图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/014a015e70db8fedb3a6352bdc4cc22a.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\\n## 功能模块\\n- 员工资料：基本资料、高级资料\\n- 人事管理（尚未开发）\\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\\n- 统计管理（尚未开发）\\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\\n- websocket在线聊天\\n## 项目技术栈\\n### 后端技术栈\\n1. Spring Boot\\n2. Spring Security\\n3. Mybatis+Mybatis-Plus\\n4. Redis\\n5. RabbitMQ\\n6. WebSocket\\n7. 阿里云oss\\n8. mail\\n9. ...\\n\\n### 前端技术栈\\n1. Vue\\n2. ElementUI\\n3. axios\\n4. vue-router\\n5. Vuex\\n6. WebSocket\\n7. vue-cli4\\n8. ...\\n\\n## 项目源码\\ngitee：https://gitee.com/icatw/cloudEOffice\\ngithub：https://github.com/icatw/cloudEOffice\\n\\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png\",\"articleTitle\":\"云e办项目总结\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-21 12:51:57',NULL),(1174,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>云e办项目总结\\n## 前言\\n本项目基于b站的云e办项目，视频链接：https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web ，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\\n## 项目截图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/014a015e70db8fedb3a6352bdc4cc22a.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\\n## 功能模块\\n- 员工资料：基本资料、高级资料\\n- 人事管理（尚未开发）\\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\\n- 统计管理（尚未开发）\\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\\n- websocket在线聊天\\n## 项目技术栈\\n### 后端技术栈\\n1. Spring Boot\\n2. Spring Security\\n3. Mybatis+Mybatis-Plus\\n4. Redis\\n5. RabbitMQ\\n6. WebSocket\\n7. 阿里云oss\\n8. mail\\n9. ...\\n\\n### 前端技术栈\\n1. Vue\\n2. ElementUI\\n3. axios\\n4. vue-router\\n5. Vuex\\n6. WebSocket\\n7. vue-cli4\\n8. ...\\n\\n## 项目源码\\ngitee：https://gitee.com/icatw/cloudEOffice\\ngithub：https://github.com/icatw/cloudEOffice\\n\\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png\",\"articleTitle\":\"云e办项目总结\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-21 12:53:06',NULL),(1175,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 使用PicGo+阿里云oss+Typora搭建图床\\n\\n### 阿里云开通oss服务\\n\\nhttps://oss.console.aliyun.com/\\n\\n- 登陆注册阿里云\\n- 搜索oss，并且开通\\n- 创建Bucket（注意读写权限选择公共读，不然无法显示oss图片）\\n\\n![image-20220522193238267](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221932391.png)\\n\\n![image-20220522194541527](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221945613.png)\\n\\n### 阿里云创建AccessKey子用户\\n- 入口为：右上角头像 ->AccessKey管理 -> 开始使用子用户AccessKey\\n\\n![image-20220522195724210](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221957325.png)\\n\\n- 勾选Open API 调用访问\\n\\n![image-20220522200120519](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222001631.png)\\n\\n- 添加管理对象存储服务（OSS）权限\\n\\n![](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222002347.png)\\n\\n- **之后一定要复制下来用户KeyId和KeySecret**（关闭窗口之后无法查看）\\n\\n### 配置PicGo\\n\\nPicGo官网：https://picgo.github.io/PicGo-Doc/zh/guide/\\n\\n- 下载PicGo https://github.com/Molunerfinn/PicGo/releases\\n- 配置阿里云oss图床\\n\\n![image-20220522195341532](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205221953599.png)\\n\\n> 前两个设置为刚刚复制下来的阿里云AccessKey信息\\n>\\n> 存储空间名设置为 oss的bucket名字\\n>\\n> 确认存储空间设置为 oss的Endpoint前缀，例如：杭州： oss-cn-hangzhou\\n>\\n> 指定存储路径设置为 img/  ，一定要加/\\n\\n### Typora设置\\n\\n按照下图修改配置即可\\n\\n![image-20220522200757258](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222007340.png)\\n\\n完成之后需要重启PicGo和Typora！！\\n\\n### 可能出现的问题\\n\\n假如上传图片时出错请修改PicGo配置，如下图\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222009908.png\\\" alt=\\\"image-20220522200939845\\\" style=\\\"zoom:67%;\\\" />\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222009195.png\\\" alt=\\\"image-20220522200953142\\\" style=\\\"zoom:67%;\\\" />\\n\\n开启时间戳重命名\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222010719.png\\\" alt=\\\"image-20220522201042661\\\" style=\\\"zoom:67%;\\\" />\\n\\n之后重启测试即可\\n\\n![image-20220522201114370](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205222011444.png)\\n\\n看到这个结果就可以愉快的使用Typora写博客啦！！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d06d1116d46a3b159734db29dc7e9f6b.png\",\"articleTitle\":\"使用PicGo+阿里云oss+Typora搭建图床\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"其他技术\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-22 20:14:15',NULL),(1176,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringSecurity从入门到精通\\n\\n## 课程介绍\\n\\n![image-20211219121555979](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231606106.png)\\n\\n## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image-20211215094003288](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607396.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image-20211214144425527](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607397.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image-20211214145824903](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607398.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image-20211214151515385](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607399.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author sg\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如\\n\\n![image-20211216123945882](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607400.png)\\n\\n这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。\\n\\n\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n​\\t![image-20211222110249727](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author makejava\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\tCSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\thttps://blog.csdn.net/freeking101/article/details/86537087\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n### 其他认证方案畅想\\n\\n\\n\\n\\n\\n## 7. 源码讲解\\n\\n​\\t\\n> 转自b站三更草堂的springsecurity教程\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e27525d8f199eb6a037ab70e4d29edd2.png\",\"articleTitle\":\"SpringSecurity从入门到精通\",\"categoryName\":\"学习记录\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 16:16:28',NULL),(1177,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringSecurity从入门到精通\\n\\n## 课程介绍\\n\\n![image-20211219121555979](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231606106.png)\\n\\n## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image-20211215094003288](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607396.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image-20211214144425527](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607397.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image-20211214145824903](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607398.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image-20211214151515385](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607399.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author sg\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如\\n\\n![image-20211216123945882](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607400.png)\\n\\n这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。\\n\\n\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n​\\t![image-20211222110249727](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205231607401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author makejava\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  B站： https://space.bilibili.com/663528522\\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\tCSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\thttps://blog.csdn.net/freeking101/article/details/86537087\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n### 其他认证方案畅想\\n\\n\\n\\n\\n\\n## 7. 源码讲解\\n\\n​\\t\\n> 转自b站三更草堂的springsecurity教程，资料源码地址： [资料地址](https://gitee.com/icatw/SpringSecurity)\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e27525d8f199eb6a037ab70e4d29edd2.png\",\"articleTitle\":\"SpringSecurity从入门到精通\",\"categoryName\":\"学习记录\",\"id\":94,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 16:17:51',NULL),(1178,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[91,90,89],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 16:18:06',NULL),(1179,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# docker安装mysql8.0\\n\\n> 这里使用虚拟机安装测试\\n\\n## docker中下载mysql最新版\\n\\n``` shell\\ndocker pull mysql\\n```\\n\\n![image-20220523221026511](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232210963.png)\\n\\n## 启动\\n\\n``` shell\\ndocker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\\n```\\n\\n命令说明：\\n\\n- --name： 指定容器名字（名称唯一）\\n- -p：指定容器暴露端口\\n- -d：后台运行容器\\n\\n启动成功之后可通过`docker ps`命令查看\\n\\n![image-20220523222137904](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232221222.png)\\n\\n## 进入容器\\n\\n```shell\\ndocker exec -it mysql bash\\n```\\n\\n![image-20220523222311324](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232223624.png)\\n\\n登录mysql\\n\\n```sql\\nmysql -u root -p\\n```\\n\\n之后输入自己的密码：eg：123456（**Linux命令行是看不到自己输入的密码的**）\\n\\n![image-20220523222600694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232226997.png)\\n\\n登录mysql成功之后就可以正常的使用sql命令啦\\n\\n## 退出容器\\n\\n- 先使用`exit`退出mysql\\n\\n- 再使用一次`exit`退出mysql容器\\n\\n![image-20220523223110417](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232231715.png)\\n\\n## 本地测试连接虚拟机mysql\\n\\n- 打开Navicat\\n\\n- 新建mysql连接，左上角-> 连接，选择MySQL\\n\\n  ![image-20220523223209937](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232232005.png)\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232233950.png\\\" alt=\\\"image-20220523223328888\\\" style=\\\"zoom: 50%;\\\" />\\n\\n- 配置连接信息\\n  - 连接名：自己定义\\n  - 主机：虚拟机ip\\n  - 端口号：默认3306\\n  - 用户名：默认root\\n  - 密码：mysql密码\\n- 测试连接\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232235639.png\\\" alt=\\\"image-20220523223521571\\\" style=\\\"zoom:50%;\\\" />\\n\\n## 成功！\\n\\n![image-20220523223732358](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232237390.png)\\n\\n到此就可以在本机操作虚拟机中docker的mysql了\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f1c14ed0da37b3391cac387a88d64a66.jpg\",\"articleTitle\":\"docker安装mysql8.0\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"docker\",\"mysql\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:48:35',NULL),(1180,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"Java面经\",\"id\":194}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:48:58',NULL),(1181,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# docker安装mysql8.0\\n\\n> 这里使用虚拟机安装测试\\n\\n## docker中下载mysql最新版\\n\\n``` shell\\ndocker pull mysql\\n```\\n\\n![image-20220523221026511](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232210963.png)\\n\\n## 启动\\n\\n``` shell\\ndocker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\\n```\\n\\n命令说明：\\n\\n- --name： 指定容器名字（名称唯一）\\n- -p：指定容器暴露端口\\n- -d：后台运行容器\\n\\n启动成功之后可通过`docker ps`命令查看\\n\\n![image-20220523222137904](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232221222.png)\\n\\n## 进入容器\\n\\n```shell\\ndocker exec -it mysql bash\\n```\\n\\n![image-20220523222311324](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232223624.png)\\n\\n登录mysql\\n\\n```sql\\nmysql -u root -p\\n```\\n\\n之后输入自己的密码：eg：123456（**Linux命令行是看不到自己输入的密码的**）\\n\\n![image-20220523222600694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232226997.png)\\n\\n登录mysql成功之后就可以正常的使用sql命令啦\\n\\n## 退出容器\\n\\n- 先使用`exit`退出mysql\\n\\n- 再使用一次`exit`退出mysql容器\\n\\n![image-20220523223110417](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232231715.png)\\n\\n## 本地测试连接虚拟机mysql\\n\\n- 打开Navicat\\n\\n- 新建mysql连接，左上角-> 连接，选择MySQL\\n\\n  ![image-20220523223209937](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232232005.png)\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232233950.png\\\" alt=\\\"image-20220523223328888\\\" style=\\\"zoom: 50%;\\\" />\\n\\n- 配置连接信息\\n  - 连接名：自己定义\\n  - 主机：虚拟机ip\\n  - 端口号：默认3306\\n  - 用户名：默认root\\n  - 密码：mysql密码\\n- 测试连接\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232235639.png\\\" alt=\\\"image-20220523223521571\\\" style=\\\"zoom:50%;\\\" />\\n\\n## 成功！\\n\\n![image-20220523223732358](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232237390.png)\\n\\n到此就可以在本机操作虚拟机中docker的mysql了\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f1c14ed0da37b3391cac387a88d64a66.jpg\",\"articleTitle\":\"docker安装mysql8.0\",\"categoryName\":\"Java后端\",\"id\":95,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:49:40',NULL),(1182,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# docker安装mysql8.0\\n\\n> 这里使用虚拟机安装测试\\n\\n## docker中下载mysql最新版\\n\\n``` shell\\ndocker pull mysql\\n```\\n\\n![image-20220523221026511](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232210963.png)\\n\\n## 启动\\n\\n``` shell\\ndocker run --name mysql8 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\\n```\\n\\n命令说明：\\n\\n- --name： 指定容器名字（名称唯一）\\n- -p：指定容器暴露端口\\n- -d：后台运行容器\\n\\n启动成功之后可通过`docker ps`命令查看\\n\\n![image-20220523222137904](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232221222.png)\\n\\n## 进入容器\\n\\n```shell\\ndocker exec -it mysql bash\\n```\\n\\n![image-20220523222311324](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232223624.png)\\n\\n登录mysql\\n\\n```sql\\nmysql -u root -p\\n```\\n\\n之后输入自己的密码：eg：123456（**Linux命令行是看不到自己输入的密码的**）\\n\\n![image-20220523222600694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232226997.png)\\n\\n登录mysql成功之后就可以正常的使用sql命令啦\\n\\n## 退出容器\\n\\n- 先使用`exit`退出mysql\\n\\n- 再使用一次`exit`退出mysql容器\\n\\n![image-20220523223110417](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232231715.png)\\n\\n## 本地测试连接虚拟机mysql\\n\\n- 打开Navicat\\n\\n- 新建mysql连接，左上角-> 连接，选择MySQL\\n\\n  ![image-20220523223209937](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232232005.png)\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232233950.png\\\" alt=\\\"image-20220523223328888\\\" style=\\\"zoom: 50%;\\\" />\\n\\n- 配置连接信息\\n  - 连接名：自己定义\\n  - 主机：虚拟机ip\\n  - 端口号：默认3306\\n  - 用户名：默认root\\n  - 密码：mysql密码\\n- 测试连接\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232235639.png\\\" alt=\\\"image-20220523223521571\\\" style=\\\"zoom:50%;\\\" />\\n\\n## 成功！\\n\\n![image-20220523223732358](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232237390.png)\\n\\n到此就可以在本机操作虚拟机中docker的mysql了\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f1c14ed0da37b3391cac387a88d64a66.jpg\",\"articleTitle\":\"docker安装mysql8.0\",\"categoryName\":\"学习记录\",\"id\":95,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:49:53',NULL),(1183,'分类模块','删除','/admin/categories','com.minzheng.blog.controller.CategoryController.deleteCategories','删除分类','[[196]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:50:22',NULL),(1184,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"Java后端\",\"id\":189}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:50:32',NULL),(1185,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"Bug记录\",\"id\":191}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:50:51',NULL),(1186,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 栈\\n## 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n## 栈的实现\\n这里基于**Java链表**实现\\n\\n## 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n## 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|:--:|:--:|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n**需求**：\\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\\n分析：\\n> 1.创建一个栈对象oprands存储操作数\\n2.从左往右遍历逆波兰表达式，得到每一个字符串\\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\\n5.使用该运算符计算o1和o2，得到结果result\\n6.把该结果压入oprands栈中\\n7.遍历结束后，拿出栈中最终的结果返回\\n\\n流程图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\\n\\n**代码实现**：\\n``` java\\n/**\\n * 逆波兰表示法\\n *\\n * @author icatw\\n * @date 2022/04/17\\n */\\npublic class ReversePolishNotation {\\n    public static void main(String[] args) {\\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\\n        String[] notation = {\\\"3\\\", \\\"17\\\", \\\"15\\\", \\\"-\\\", \\\"*\\\", \\\"18\\\", \\\"6\\\", \\\"/\\\", \\\"+\\\"};\\n        int result = calculate(notation);\\n        System.out.println(\\\"逆波兰表达式的结果为：\\\" + result);\\n    }\\n\\n    /**\\n     * @param notation 逆波兰表达式的数组表示方式\\n     * @return 逆波兰表达式的计算结果\\n     */\\n    public static int calculate(String[] notation) {\\n        //1、定义一个栈用来存储操作数\\n        Stack<Integer> operands = new Stack<>();\\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\\n        for (int i = 0; i < notation.length; i++) {\\n            String curr = notation[i];\\n            //3、判断当前元素是运算符还是操作数\\n            Integer o1;\\n            Integer o2;\\n            Integer result;\\n            switch (curr) {\\n                case \\\"+\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 + o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"-\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 - o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"*\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 * o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"/\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 / o1;\\n                    operands.push(result);\\n                    break;\\n                default:\\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\\n                    operands.push(Integer.valueOf(curr));\\n                    break;\\n            }\\n\\n            //5、操作数，把该操作数压入栈中\\n\\n        }\\n        Integer pop = operands.pop();\\n        System.out.println(pop);\\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\\n        return pop;\\n    }\\n}\\n```\\n# 队列\\n## 理论基础：\\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\\n## API设计\\n|类名|Queue|\\n|-|-|\\n|构造方法|public Queue()：创建Queue对象|\\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\\n|内部结点类|private class Node|\\n## 代码实现\\n基于Java链表\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/4/18\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Queue<T> implements Iterable<T> {\\n    //记录首结点\\n    private Node head;\\n    //记录最后一个结点\\n    private Node last;\\n    //记录队列中元素的个数\\n    private int N;\\n\\n    public Queue() {\\n        head = new Node(null, null);\\n        last = null;\\n        N = 0;\\n    }\\n\\n    //判断队列是否为空\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    //返回队列中元素的个数\\n    public int size() {\\n        return N;\\n    }\\n\\n    //向队列中插入元素t\\n    public void enqueue(T t) {\\n        //1、当前尾结点，last为null\\n        if (last == null) {\\n            last = new Node(t, null);\\n            head.next = last;\\n        }\\n        //    2、当前尾结点不为null\\n        else {\\n            Node oldLast = this.last;\\n            Node newNode = new Node(t, null);\\n            last = newNode;\\n            oldLast.next = last;\\n        }\\n        N++;\\n    }\\n\\n    //从队列中拿出一个元素\\n    public T dequeue() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        Node oldFirst = head.next;\\n        head.next = oldFirst.next;\\n        N--;\\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\\n        if (isEmpty()) {\\n            last = null;\\n        }\\n        return oldFirst.item;\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### LeetCode 225. 用队列实现栈\\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\\n实现 MyStack 类：\\nvoid push(int x) 将元素 x 压入栈顶。\\nint pop() 移除并返回栈顶元素。\\nint top() 返回栈顶元素。\\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\\n\\n**代码实现**：\\n``` java\\nclass MyStack {\\n\\n    Queue<Integer> queue1;\\n    Queue<Integer> queue2;\\n\\n    public MyStack() {\\n        queue1 = new LinkedList<Integer>();\\n        queue2 = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue2.offer(x);\\n        while (!queue1.isEmpty()) {\\n            queue2.offer(queue1.poll());\\n        }\\n        Queue<Integer> temp = queue1;\\n        queue1 = queue2;\\n        queue2 = temp;\\n    }\\n    \\n    public int pop() {\\n        return queue1.poll();\\n    }\\n    \\n    public int top() {\\n        return queue1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue1.isEmpty();\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d8afa7b4d72f0765e8a1cae491582411.jpg\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"categoryName\":\"数据结构算法\",\"id\":70,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:53:48',NULL),(1187,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 栈\\n## 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n## 栈的实现\\n这里基于**Java链表**实现\\n\\n## 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n## 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|:--:|:--:|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n**需求**：\\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\\n分析：\\n> 1.创建一个栈对象oprands存储操作数\\n2.从左往右遍历逆波兰表达式，得到每一个字符串\\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\\n5.使用该运算符计算o1和o2，得到结果result\\n6.把该结果压入oprands栈中\\n7.遍历结束后，拿出栈中最终的结果返回\\n\\n流程图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\\n\\n**代码实现**：\\n``` java\\n/**\\n * 逆波兰表示法\\n *\\n * @author icatw\\n * @date 2022/04/17\\n */\\npublic class ReversePolishNotation {\\n    public static void main(String[] args) {\\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\\n        String[] notation = {\\\"3\\\", \\\"17\\\", \\\"15\\\", \\\"-\\\", \\\"*\\\", \\\"18\\\", \\\"6\\\", \\\"/\\\", \\\"+\\\"};\\n        int result = calculate(notation);\\n        System.out.println(\\\"逆波兰表达式的结果为：\\\" + result);\\n    }\\n\\n    /**\\n     * @param notation 逆波兰表达式的数组表示方式\\n     * @return 逆波兰表达式的计算结果\\n     */\\n    public static int calculate(String[] notation) {\\n        //1、定义一个栈用来存储操作数\\n        Stack<Integer> operands = new Stack<>();\\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\\n        for (int i = 0; i < notation.length; i++) {\\n            String curr = notation[i];\\n            //3、判断当前元素是运算符还是操作数\\n            Integer o1;\\n            Integer o2;\\n            Integer result;\\n            switch (curr) {\\n                case \\\"+\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 + o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"-\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 - o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"*\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 * o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"/\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 / o1;\\n                    operands.push(result);\\n                    break;\\n                default:\\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\\n                    operands.push(Integer.valueOf(curr));\\n                    break;\\n            }\\n\\n            //5、操作数，把该操作数压入栈中\\n\\n        }\\n        Integer pop = operands.pop();\\n        System.out.println(pop);\\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\\n        return pop;\\n    }\\n}\\n```\\n# 队列\\n## 理论基础：\\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\\n## API设计\\n|类名|Queue|\\n|-|-|\\n|构造方法|public Queue()：创建Queue对象|\\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\\n|内部结点类|private class Node|\\n## 代码实现\\n基于Java链表\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/4/18\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Queue<T> implements Iterable<T> {\\n    //记录首结点\\n    private Node head;\\n    //记录最后一个结点\\n    private Node last;\\n    //记录队列中元素的个数\\n    private int N;\\n\\n    public Queue() {\\n        head = new Node(null, null);\\n        last = null;\\n        N = 0;\\n    }\\n\\n    //判断队列是否为空\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    //返回队列中元素的个数\\n    public int size() {\\n        return N;\\n    }\\n\\n    //向队列中插入元素t\\n    public void enqueue(T t) {\\n        //1、当前尾结点，last为null\\n        if (last == null) {\\n            last = new Node(t, null);\\n            head.next = last;\\n        }\\n        //    2、当前尾结点不为null\\n        else {\\n            Node oldLast = this.last;\\n            Node newNode = new Node(t, null);\\n            last = newNode;\\n            oldLast.next = last;\\n        }\\n        N++;\\n    }\\n\\n    //从队列中拿出一个元素\\n    public T dequeue() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        Node oldFirst = head.next;\\n        head.next = oldFirst.next;\\n        N--;\\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\\n        if (isEmpty()) {\\n            last = null;\\n        }\\n        return oldFirst.item;\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### LeetCode 225. 用队列实现栈\\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\\n实现 MyStack 类：\\nvoid push(int x) 将元素 x 压入栈顶。\\nint pop() 移除并返回栈顶元素。\\nint top() 返回栈顶元素。\\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\\n\\n**代码实现**：\\n``` java\\nclass MyStack {\\n\\n    Queue<Integer> queue1;\\n    Queue<Integer> queue2;\\n\\n    public MyStack() {\\n        queue1 = new LinkedList<Integer>();\\n        queue2 = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue2.offer(x);\\n        while (!queue1.isEmpty()) {\\n            queue2.offer(queue1.poll());\\n        }\\n        Queue<Integer> temp = queue1;\\n        queue1 = queue2;\\n        queue2 = temp;\\n    }\\n    \\n    public int pop() {\\n        return queue1.poll();\\n    }\\n    \\n    public int top() {\\n        return queue1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue1.isEmpty();\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d8afa7b4d72f0765e8a1cae491582411.jpg\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"categoryName\":\"数据结构算法\",\"id\":70,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:53:59',NULL),(1188,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 1、 Java语言有哪些特点\\n1. 简单易学、有丰富的类库\\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\\n3. 与平台无关性（JVM是Java跨平台使用的根本）\\n4. 可靠安全\\n5. 支持多线程\\n## 2、面向对象和面向过程的区别\\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\\n\\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\\n## 3 、八种基本数据类型的大小，以及他们的封装类\\n|基本类型 |大小（字节）|默认值|封装类|\\n|-|-|-|-|\\n|byte|1|(byte)0|Byte|\\n|short|2|(short)0|Short|\\n|int|4|0|Integer|\\n|long|8|0L|Long|\\n|float|4|0.0f|Float|\\n|double|8|0.0d|Double|\\n|boolean|-|false|Boolean|\\n|char|2|\\\\u0000(null)|Char|\\n注：\\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\\n\\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\\n\\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\\n## 4、标识符的命名规则。\\n<b>标识符的含义：</b>\\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\\n\\n<b>命名规则：（硬性要求）</b>\\n- 标识符可以包含英文字母，0-9的数字，$以及_\\n- 标识符不能以数字开头\\n- 标识符不是关键字\\n\\n\\n<b>命名规范：（非硬性要求）</b>\\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\\n- 方法名规范：同变量名。\\n## 5、instanceof 关键字的作用\\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\\n``` java\\nboolean result = obj instanceof Class\\n```\\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\\n\\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\\n``` java\\nint i = 0;\\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\\nSystem.out.println(i instanceof Object);//编译不通过\\n```\\n``` java\\nInteger integer = new Integer(1);\\nSystem.out.println(integer instanceof Integer);//true\\n\\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\\nfalse。\\nSystem.out.println(null instanceof Object);\\n```\\n## 6、Java自动装箱与拆箱\\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\\nvalueOf(int) 方法</b>\\n\\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\\n``` java\\nInteger i = new Integer(10);\\n```\\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\\n样就可以了：\\n``` java\\nInteger i = 10;\\n```\\n<b><i>面试题1： 以下代码会输出什么？</i></b>\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tInteger i1 = 100;\\n\\t\\tInteger i2 = 100;\\n\\t\\tInteger i3 = 200;\\n\\t\\tInteger i4 = 200;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n运行结果：\\n``` java\\ntrue\\nfalse\\n```\\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\\n``` java\\npublic static Integer valueOf(int i) {\\n\\tif(i >= -128 && i <= IntegerCache.high)\\n\\t\\treturn IntegerCache.cache[i + 128];\\n\\telse\\n\\t\\treturn new Integer(i);\\n}\\n\\n```\\n\\n其中IntegerCache类的实现为：\\n``` java\\n    private static class IntegerCache {\\n        static final int low = -128;\\n        static final int high;\\n        static final Integer cache[];\\n\\n        static {\\n            // high value may be configured by property\\n            int h = 127;\\n            String integerCacheHighPropValue =\\n                sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\");\\n            if (integerCacheHighPropValue != null) {\\n                try {\\n                    int i = parseInt(integerCacheHighPropValue);\\n                    i = Math.max(i, 127);\\n                    // Maximum array size is Integer.MAX_VALUE\\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\\n                } catch( NumberFormatException nfe) {\\n                    // If the property cannot be parsed into an int, ignore it.\\n                }\\n            }\\n            high = h;\\n\\n            cache = new Integer[(high - low) + 1];\\n            int j = low;\\n            for(int k = 0; k < cache.length; k++)\\n                cache[k] = new Integer(j++);\\n\\n            // range [-128, 127] must be interned (JLS7 5.1.7)\\n            assert IntegerCache.high >= 127;\\n        }\\n\\n        private IntegerCache() {}\\n    }\\n```\\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\\n\\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\\n\\n***面试题2：以下代码输出什么***\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tDouble i1 = 100.0;\\n\\t\\tDouble i2 = 100.0;\\n\\t\\tDouble i3 = 200.0;\\n\\t\\tDouble i4 = 200.0;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n\\n运行结果：\\n``` java\\nfalse\\nfalse\\n```\\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\\n## 7、 重载和重写的区别\\n<b>重写(Override)</b>\\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\\n``` java\\npublic class Father {\\npublic static void main(String[] args) {\\n\\t// TODO Auto-generated method stub\\n\\tSon s = new Son();\\n\\ts.sayHello();\\n}\\npublic void sayHello() {\\n\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n}\\nclass Son extends Father{\\n\\t@Override\\n\\tpublic void sayHello() {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tSystem.out.println(\\\"hello by \\\");\\n\\t}\\n}\\n```\\n<b>重写总结：</b>\\n1. 发生在父类与子类之间\\n2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\\n3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\\n4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\\n\\n\\n<b>重载（Overload）</b>\\n在一个类中，同名的方法如果有不同的参数列表<b>（参数类型不同、参数个数不同甚至是参数顺序不同）</b>则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<b>不能通过返回类型是否相同来判断重载。</b>\\n\\n``` java\\npublic class Father {\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tFather s = new Father();\\n\\t\\ts.sayHello();\\n\\t\\ts.sayHello(\\\"wintershii\\\");\\n\\t}\\n\\tpublic void sayHello() {\\n\\t\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n\\tpublic void sayHello(String name) {\\n\\t\\tSystem.out.println(\\\"Hello\\\" + \\\" \\\" + name);\\n\\t}\\n}\\n```\\n<b>重载总结：</b>\\n1. 重载Overload是一个类中多态性的一种表现\\n2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\\n3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\\n## 8、 equals与==的区别\\n<b>== ：</b>\\n\\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，**用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。**\\n1. 比较的是操作符两端的操作数是否是同一个对象。\\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\\n\\n<b>equals：</b>\\n\\n&emsp;&emsp;equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\\nequals方法返回的却是==的判断。\\n\\n<b>总结：</b>\\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针。\\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\\n## 9、 Hashcode的作用\\n&emsp;&emsp;**java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复**。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。\\n\\n&emsp;&emsp;于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。\\n\\n&emsp;&emsp;hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\\n## 10、String、String StringBuffer 和 StringBuilder 的区别是什么?\\n\\n**String是只读字符串，它并不是基本数据类型，而是一个对象**。从底层源码来看是一个final类型的字符\\n数组，所引用的字符串不能被改变，**一经定义，无法再增删改。每次对String的操作都会生成新的String对象**。\\n``` java\\nprivate final char value[];\\n```\\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。\\n\\n**StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类**，从AbstractStringBuilder抽象类中我们可以看到\\n``` java\\n/**\\n* The value is used for character storage.\\n*/\\nchar[] value;\\n```\\n他们的底层都是可变的字符数组，**所以在进行频繁的字符串操作时，建议使用StringBuffer和\\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的**。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b6ca16c4768b3e963997131f64e49b63.jpg\",\"articleTitle\":\"java基础面试题（一）\",\"categoryName\":\"Java面经\",\"id\":62,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:54:40',NULL),(1189,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 栈\\n## 理论基础：\\n**栈（stack**），**是一种先进后出（FILO，First In Last Out）的数据结构，只能在一段进行插入和删除的特殊线性表**。按照先进后出的原则存储数据，先进入的数据被压于栈底，最后入的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。\\n\\n**通常称数据进入到栈的操作为压栈，数据从栈中出去的动作为弹栈。**\\n\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f3c045c177cdf8be231076fad52e673e.png)（图源b站黑马程序员-数据结构与算法基础）\\n## 栈的实现\\n这里基于**Java链表**实现\\n\\n## 栈的API设计\\n|类名|Stack|\\n|-|-|\\n|构造方法|public Stack()|\\n|成员方法|1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size()：返回栈的大小长度<br>3.public T pop()：弹出栈顶元素（弹栈）<br>4.public void push(T t)：向栈中压入元素（压栈）|\\n| 成员变量|1.private Node head：记录首结点<br>2.private int N：记录栈元素个数|\\n|结点内部类|private class Node|\\n\\n## 代码实现\\n``` java\\n/**\\n * 堆栈\\n *\\n * @author icatw\\n * @date 2022/4/17\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Stack<T> implements Iterable<T> {\\n    private Node head;\\n    private int N;\\n\\n    public Stack() {\\n        this.head = new Node(null, null);\\n        this.N = 0;\\n    }\\n\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    public int size() {\\n        return N;\\n    }\\n\\n    /**\\n     * 弹出栈顶元素\\n     *\\n     * @return {@link T}\\n     */\\n    public T pop() {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = this.head.next;\\n        //让首结点指向原来的第一个结点的下一个结点\\n        if (oldFirst == null) {\\n            return null;\\n        }\\n        head.next = oldFirst.next;\\n        //元素个数-1\\n        N--;\\n        return oldFirst.item;\\n    }\\n\\n    /**\\n     * 向栈中压入元素t\\n     *\\n     * @param t t\\n     */\\n    public void push(T t) {\\n        //找到首结点指向的第一个结点\\n        Node oldFirst = head.next;\\n        //    创建新结点\\n        Node newNode = new Node(t, null);\\n        //    让首结点指向新结点\\n        head.next = newNode;\\n        //    让新结点指向原来的第一个结点\\n        newNode.next = oldFirst;\\n        //    元素个数+1\\n        N++;\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### **LeetCode 20.有效的括号**\\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\\n有效字符串需满足：\\n1.左括号必须用相同类型的右括号闭合。\\n2.左括号必须以正确的顺序闭合。\\n\\n**Java代码实现**\\n``` java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> left=  new Stack<>();\\n        for(char c : s.toCharArray()){\\n            //左括号，则入栈\\n            if (c == \'(\' || c == \'{\' || c == \'[\')\\n                left.push(c);\\n            else //右括号\\n                if (!left.isEmpty() && leftOf(c) == left.peek())\\n                    left.pop();\\n                else\\n                    // 和最近的左括号不匹配\\n                    return false;\\n        }\\n        //是否所有的左括号都被匹配了\\n        return left.isEmpty();\\n    }\\n\\n    char leftOf(char c) {\\n        if (c == \'}\') return \'{\';\\n        if (c == \')\') return \'(\';\\n        return \'[\';\\n    }\\n}\\n```\\n解题思路\\n> 1.创建一个栈用来存储左括号\\n2.从左往右遍历字符串，拿到每一个字符\\n3.判断该字符是不是左括号，如果是，放入栈中存储\\n4.判断该字符是不是右括号，如果不是，继续下一次循环\\n5.如果该字符是右括号，则从栈中弹出一个元素t；\\n6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\\n7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\\n``` text\\n基于栈的思想，遍历字符串，遇到左括号则（\'(\',\'{\',\'[\'）则将其入栈，右括号则进行判断\\nif (!left.isEmpty() && leftOf(c) == left.peek())\\nleft.peek()，得到栈顶元素而不弹出，先将栈顶元素与遍历的右括号进行比较，如果相等，则弹栈。\\n否则，此右括号和最近的左括号不匹配，直接返回false\\n最后再 left.isEmpty判断栈是否为空（括号匹配成功的话将会进行弹栈操作，因此，括号完全匹配成功之后，栈元素清零）\\n栈为空，则匹配成功，否则返回失败\\n```\\n\\n### 逆波兰表达式求值问题\\n1. 什么是逆波兰表达式（后缀表达式）？\\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，**后缀表达式的特点：运算符总是放在跟它相关的操作数之后**。\\n2. 中缀表达式\\n中缀表达式就是我们平常生活中所使用的表达式，例如：1+3*2,2-(1+3)等等，**中缀表达式的特点是：二元运算符总是置于两个操作数中间**。\\n\\n**对应关系**：\\n|中缀表达式|逆波兰表达式|\\n|:--:|:--:|\\n|a+b|ab+|\\n|a+(b-c)|abc-+|\\n|a+(b-c)*d|abc-d*+|\\n|a*(b-c)+d|abc-*d+|\\n**需求**：\\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\\n分析：\\n> 1.创建一个栈对象oprands存储操作数\\n2.从左往右遍历逆波兰表达式，得到每一个字符串\\n3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\\n4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\\n5.使用该运算符计算o1和o2，得到结果result\\n6.把该结果压入oprands栈中\\n7.遍历结束后，拿出栈中最终的结果返回\\n\\n流程图：\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a73b4f10eff2d91ec219b2a17c99f6e5.png)\\n\\n**代码实现**：\\n``` java\\n/**\\n * 逆波兰表示法\\n *\\n * @author icatw\\n * @date 2022/04/17\\n */\\npublic class ReversePolishNotation {\\n    public static void main(String[] args) {\\n//中缀表达式3*（17-15）+18/6的逆波兰表达式如下\\n        String[] notation = {\\\"3\\\", \\\"17\\\", \\\"15\\\", \\\"-\\\", \\\"*\\\", \\\"18\\\", \\\"6\\\", \\\"/\\\", \\\"+\\\"};\\n        int result = calculate(notation);\\n        System.out.println(\\\"逆波兰表达式的结果为：\\\" + result);\\n    }\\n\\n    /**\\n     * @param notation 逆波兰表达式的数组表示方式\\n     * @return 逆波兰表达式的计算结果\\n     */\\n    public static int calculate(String[] notation) {\\n        //1、定义一个栈用来存储操作数\\n        Stack<Integer> operands = new Stack<>();\\n        //2、从左往右遍历逆波兰表达式，得到每一个元素\\n        for (int i = 0; i < notation.length; i++) {\\n            String curr = notation[i];\\n            //3、判断当前元素是运算符还是操作数\\n            Integer o1;\\n            Integer o2;\\n            Integer result;\\n            switch (curr) {\\n                case \\\"+\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 + o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"-\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 - o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"*\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 * o1;\\n                    operands.push(result);\\n                    break;\\n                case \\\"/\\\":\\n                    o1 = operands.pop();\\n                    o2 = operands.pop();\\n                    result = o2 / o1;\\n                    operands.push(result);\\n                    break;\\n                default:\\n                    //4、运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中\\n                    operands.push(Integer.valueOf(curr));\\n                    break;\\n            }\\n\\n            //5、操作数，把该操作数压入栈中\\n\\n        }\\n        Integer pop = operands.pop();\\n        System.out.println(pop);\\n        //6、得到栈中最后一个元素就是逆波兰表达式的结果\\n        return pop;\\n    }\\n}\\n```\\n# 队列\\n## 理论基础：\\n**队列（queue）**，**是一种先进先出（FIFO，First In First Out）的数据结构**，只能在一段进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据也先被读取出来。\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2bddc25c0691d5d7d6853d4f8b82b765.png)\\n## API设计\\n|类名|Queue|\\n|-|-|\\n|构造方法|public Queue()：创建Queue对象|\\n|成员方法|1.public boolean isEmpty()：判断队列是否为空<br>2.public int size()：返回队列中的元素个数<br>3.public void enqueue(T t)：向队列中插入元素<br>4.public T dequeue()：从队列中拿出一个元素（拿出之后删除）|\\n|成员变量|1.private Node head:记录首结点<br>2.private int N:当前栈的元素个数<br>3.private Node last:记录最后一个结点|\\n|内部结点类|private class Node|\\n## 代码实现\\n基于Java链表\\n``` java\\n/**\\n * @author icatw\\n * @date 2022/4/18\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\npublic class Queue<T> implements Iterable<T> {\\n    //记录首结点\\n    private Node head;\\n    //记录最后一个结点\\n    private Node last;\\n    //记录队列中元素的个数\\n    private int N;\\n\\n    public Queue() {\\n        head = new Node(null, null);\\n        last = null;\\n        N = 0;\\n    }\\n\\n    //判断队列是否为空\\n    public boolean isEmpty() {\\n        return N == 0;\\n    }\\n\\n    //返回队列中元素的个数\\n    public int size() {\\n        return N;\\n    }\\n\\n    //向队列中插入元素t\\n    public void enqueue(T t) {\\n        //1、当前尾结点，last为null\\n        if (last == null) {\\n            last = new Node(t, null);\\n            head.next = last;\\n        }\\n        //    2、当前尾结点不为null\\n        else {\\n            Node oldLast = this.last;\\n            Node newNode = new Node(t, null);\\n            last = newNode;\\n            oldLast.next = last;\\n        }\\n        N++;\\n    }\\n\\n    //从队列中拿出一个元素\\n    public T dequeue() {\\n        if (isEmpty()) {\\n            return null;\\n        }\\n        Node oldFirst = head.next;\\n        head.next = oldFirst.next;\\n        N--;\\n        //    出队列就是删除元素，并且弹出，如果队列元素被删完了，需要重置last=null\\n        if (isEmpty()) {\\n            last = null;\\n        }\\n        return oldFirst.item;\\n    }\\n\\n    @Override\\n    public Iterator<T> iterator() {\\n        return new IterableI();\\n    }\\n\\n\\n    private class Node {\\n        public T item;\\n        public Node next;\\n\\n        public Node(T item, Node next) {\\n            this.item = item;\\n            this.next = next;\\n        }\\n    }\\n\\n    private class IterableI implements Iterator<T> {\\n        private Node n;\\n\\n        public IterableI() {\\n            this.n = head;\\n        }\\n\\n        @Override\\n        public boolean hasNext() {\\n\\n            return n.next != null;\\n        }\\n\\n        @Override\\n        public T next() {\\n            n = n.next;\\n            return n.item;\\n        }\\n    }\\n}\\n```\\n## 案例\\n### LeetCode 225. 用队列实现栈\\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\\n实现 MyStack 类：\\nvoid push(int x) 将元素 x 压入栈顶。\\nint pop() 移除并返回栈顶元素。\\nint top() 返回栈顶元素。\\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\\n\\n**代码实现**：\\n``` java\\nclass MyStack {\\n\\n    Queue<Integer> queue1;\\n    Queue<Integer> queue2;\\n\\n    public MyStack() {\\n        queue1 = new LinkedList<Integer>();\\n        queue2 = new LinkedList<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        queue2.offer(x);\\n        while (!queue1.isEmpty()) {\\n            queue2.offer(queue1.poll());\\n        }\\n        Queue<Integer> temp = queue1;\\n        queue1 = queue2;\\n        queue2 = temp;\\n    }\\n    \\n    public int pop() {\\n        return queue1.poll();\\n    }\\n    \\n    public int top() {\\n        return queue1.peek();\\n    }\\n    \\n    public boolean empty() {\\n        return queue1.isEmpty();\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d8afa7b4d72f0765e8a1cae491582411.jpg\",\"articleTitle\":\"数据结构学习笔记：栈和队列\",\"categoryName\":\"数据结构算法\",\"id\":70,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:54:57',NULL),(1190,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[83],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:55:07',NULL),(1191,'分类模块','删除','/admin/categories','com.minzheng.blog.controller.CategoryController.deleteCategories','删除分类','[[193]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:55:33',NULL),(1192,'标签模块','删除','/admin/tags','com.minzheng.blog.controller.TagController.deleteTag','删除标签','[[32]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:55:47',NULL),(1193,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"::: hljs-center\\n\\n## 尚医通项目总结\\n\\n:::\\n# 模块说明\\n#### yygh_parent：根目录，管理子模块\\n##### common：公共模块父节点\\n###### common-util：工具类模块，所有模块都可以依赖于它\\n###### rabbit-util：rabbitmq业务封装\\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\\n##### hospital-manage：医院接口模拟端\\n##### model：实体类模块\\n##### server-gateway：服务网关\\n##### service：api接口服务父节点\\n###### service-cmn：字典api接口服务\\n###### service-hosp：医院api接口服务\\n###### service-order：订单api接口服务\\n###### service-oss：文件存储api接口服务\\n###### service-sms：短信api接口服务\\n###### service-statistics：统计api接口服务\\n###### service-task：定时任务服务\\n###### service-user：用户api接口服务\\n##### service-client：feign服务调用父节点\\n###### service-cmn-client：字典api接口\\n###### service-hosp-client：医院api接口\\n###### service-order-client：订单api接口\\n###### service-user-client：用户api接口\\n#### sql：项目涉及的sql文件\\n\\n# 1、项目介绍\\n> 段落引用尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\\n# 2、技术点\\n #### 后端:\\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\\n3. MyBatis-Plus：持久层框架\\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\\n6. EasyExcel：操作excel表格，进行行读写操作\\n7. RabbitMQ：消息中间件（订单相关操作）\\n8. HTTPClient: Http协议客户端\\n9. Nginx：负载均衡\\n10. Mysql：关系型数据库\\n11. \\n#### 前端：\\n1. Vue.js：web 界面的渐进式框架\\n2. Node.js： JavaScript 运行环境\\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\\n4. NPM：包管理器\\n5. Babel：转码器\\n6. Webpack：打包工具\\n7. ECharts：图表展示\\n#### 其他:\\n1. Lombok\\n2. Swagger2：Api接口文档工具\\n3. Docker ：容器技术\\n4. Git：代码管理工具\\n5. 阿里云oss\\n6. 阿里云短信服务\\n7. 微信登录、支付\\n8. 定时任务\\n# 3、业务流程\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\\n\\n# 4、微服务架构\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\\n\\n# 5、git地址\\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png\",\"articleTitle\":\"尚医通项目总结\",\"categoryName\":\"项目总结\",\"id\":56,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:56:24',NULL),(1194,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"## 1、 Java语言有哪些特点\\n1. 简单易学、有丰富的类库\\n2. 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）\\n3. 与平台无关性（JVM是Java跨平台使用的根本）\\n4. 可靠安全\\n5. 支持多线程\\n## 2、面向对象和面向过程的区别\\n面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\\n\\n面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。<b>面向对象有封装、继承、多态的特性</b>，所以<b>易维护、易复用、易扩展</b>。可以设计出低耦合的系统。 但是<b>性能上来说，比面向过程要低。</b>\\n## 3 、八种基本数据类型的大小，以及他们的封装类\\n|基本类型 |大小（字节）|默认值|封装类|\\n|-|-|-|-|\\n|byte|1|(byte)0|Byte|\\n|short|2|(short)0|Short|\\n|int|4|0|Integer|\\n|long|8|0L|Long|\\n|float|4|0.0f|Float|\\n|double|8|0.0d|Double|\\n|boolean|-|false|Boolean|\\n|char|2|\\\\u0000(null)|Char|\\n注：\\n&emsp;&emsp;1. int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。\\n\\n&emsp;&emsp;2. 基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。\\n\\n&emsp;&emsp;虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。\\n## 4、标识符的命名规则。\\n<b>标识符的含义：</b>\\n是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。\\n\\n<b>命名规则：（硬性要求）</b>\\n- 标识符可以包含英文字母，0-9的数字，$以及_\\n- 标识符不能以数字开头\\n- 标识符不是关键字\\n\\n\\n<b>命名规范：（非硬性要求）</b>\\n- 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。\\n- 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。\\n- 方法名规范：同变量名。\\n## 5、instanceof 关键字的作用\\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\\n``` java\\nboolean result = obj instanceof Class\\n```\\n&emsp;&emsp;其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\\n\\n&emsp;&emsp;注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\\n``` java\\nint i = 0;\\nSystem.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型\\nSystem.out.println(i instanceof Object);//编译不通过\\n```\\n``` java\\nInteger integer = new Integer(1);\\nSystem.out.println(integer instanceof Integer);//true\\n\\n//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回\\nfalse。\\nSystem.out.println(null instanceof Object);\\n```\\n## 6、Java自动装箱与拆箱\\n<b>装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）；调用方法：Integer的\\nvalueOf(int) 方法</b>\\n\\n<b>拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）。调用方法：Integer的intValue方法</b>\\n在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：\\n``` java\\nInteger i = new Integer(10);\\n```\\n 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这\\n样就可以了：\\n``` java\\nInteger i = 10;\\n```\\n<b><i>面试题1： 以下代码会输出什么？</i></b>\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tInteger i1 = 100;\\n\\t\\tInteger i2 = 100;\\n\\t\\tInteger i3 = 200;\\n\\t\\tInteger i4 = 200;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n运行结果：\\n``` java\\ntrue\\nfalse\\n```\\n为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：\\n``` java\\npublic static Integer valueOf(int i) {\\n\\tif(i >= -128 && i <= IntegerCache.high)\\n\\t\\treturn IntegerCache.cache[i + 128];\\n\\telse\\n\\t\\treturn new Integer(i);\\n}\\n\\n```\\n\\n其中IntegerCache类的实现为：\\n``` java\\n    private static class IntegerCache {\\n        static final int low = -128;\\n        static final int high;\\n        static final Integer cache[];\\n\\n        static {\\n            // high value may be configured by property\\n            int h = 127;\\n            String integerCacheHighPropValue =\\n                sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\");\\n            if (integerCacheHighPropValue != null) {\\n                try {\\n                    int i = parseInt(integerCacheHighPropValue);\\n                    i = Math.max(i, 127);\\n                    // Maximum array size is Integer.MAX_VALUE\\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\\n                } catch( NumberFormatException nfe) {\\n                    // If the property cannot be parsed into an int, ignore it.\\n                }\\n            }\\n            high = h;\\n\\n            cache = new Integer[(high - low) + 1];\\n            int j = low;\\n            for(int k = 0; k < cache.length; k++)\\n                cache[k] = new Integer(j++);\\n\\n            // range [-128, 127] must be interned (JLS7 5.1.7)\\n            assert IntegerCache.high >= 127;\\n        }\\n\\n        private IntegerCache() {}\\n    }\\n```\\n从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。\\n\\n上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。\\n\\n***面试题2：以下代码输出什么***\\n``` java\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tDouble i1 = 100.0;\\n\\t\\tDouble i2 = 100.0;\\n\\t\\tDouble i3 = 200.0;\\n\\t\\tDouble i4 = 200.0;\\n\\t\\tSystem.out.println(i1==i2);\\n\\t\\tSystem.out.println(i3==i4);\\n\\t}\\n}\\n\\n```\\n\\n运行结果：\\n``` java\\nfalse\\nfalse\\n```\\n原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。\\n## 7、 重载和重写的区别\\n<b>重写(Override)</b>\\n<b>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。</b>子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。**但要注意子类函数的访问修饰权限不能少于父类的。**\\n``` java\\npublic class Father {\\npublic static void main(String[] args) {\\n\\t// TODO Auto-generated method stub\\n\\tSon s = new Son();\\n\\ts.sayHello();\\n}\\npublic void sayHello() {\\n\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n}\\nclass Son extends Father{\\n\\t@Override\\n\\tpublic void sayHello() {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tSystem.out.println(\\\"hello by \\\");\\n\\t}\\n}\\n```\\n<b>重写总结：</b>\\n1. 发生在父类与子类之间\\n2. 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同\\n3. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)\\n4. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常\\n\\n\\n<b>重载（Overload）</b>\\n在一个类中，同名的方法如果有不同的参数列表<b>（参数类型不同、参数个数不同甚至是参数顺序不同）</b>则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<b>不能通过返回类型是否相同来判断重载。</b>\\n\\n``` java\\npublic class Father {\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tFather s = new Father();\\n\\t\\ts.sayHello();\\n\\t\\ts.sayHello(\\\"wintershii\\\");\\n\\t}\\n\\tpublic void sayHello() {\\n\\t\\tSystem.out.println(\\\"Hello\\\");\\n\\t}\\n\\tpublic void sayHello(String name) {\\n\\t\\tSystem.out.println(\\\"Hello\\\" + \\\" \\\" + name);\\n\\t}\\n}\\n```\\n<b>重载总结：</b>\\n1. 重载Overload是一个类中多态性的一种表现\\n2. 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)\\n3. 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准\\n## 8、 equals与==的区别\\n<b>== ：</b>\\n\\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，**用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。**\\n1. 比较的是操作符两端的操作数是否是同一个对象。\\n2. 两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\\n3. 比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\\n\\n<b>equals：</b>\\n\\n&emsp;&emsp;equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\\nequals方法返回的却是==的判断。\\n\\n<b>总结：</b>\\n所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针。\\n在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals\\n## 9、 Hashcode的作用\\n&emsp;&emsp;**java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复**。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。\\n\\n&emsp;&emsp;于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。\\n\\n&emsp;&emsp;hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\\n## 10、String、String StringBuffer 和 StringBuilder 的区别是什么?\\n\\n**String是只读字符串，它并不是基本数据类型，而是一个对象**。从底层源码来看是一个final类型的字符\\n数组，所引用的字符串不能被改变，**一经定义，无法再增删改。每次对String的操作都会生成新的String对象**。\\n``` java\\nprivate final char value[];\\n```\\n每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。\\n\\n**StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类**，从AbstractStringBuilder抽象类中我们可以看到\\n``` java\\n/**\\n* The value is used for character storage.\\n*/\\nchar[] value;\\n```\\n他们的底层都是可变的字符数组，**所以在进行频繁的字符串操作时，建议使用StringBuffer和\\nStringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的**。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b6ca16c4768b3e963997131f64e49b63.jpg\",\"articleTitle\":\"java基础面试题（一）\",\"categoryName\":\"Java面经\",\"id\":62,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:56:28',NULL),(1195,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"::: hljs-center\\n\\n## 尚医通项目总结\\n\\n:::\\n# 模块说明\\n#### yygh_parent：根目录，管理子模块\\n##### common：公共模块父节点\\n###### common-util：工具类模块，所有模块都可以依赖于它\\n###### rabbit-util：rabbitmq业务封装\\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\\n##### hospital-manage：医院接口模拟端\\n##### model：实体类模块\\n##### server-gateway：服务网关\\n##### service：api接口服务父节点\\n###### service-cmn：字典api接口服务\\n###### service-hosp：医院api接口服务\\n###### service-order：订单api接口服务\\n###### service-oss：文件存储api接口服务\\n###### service-sms：短信api接口服务\\n###### service-statistics：统计api接口服务\\n###### service-task：定时任务服务\\n###### service-user：用户api接口服务\\n##### service-client：feign服务调用父节点\\n###### service-cmn-client：字典api接口\\n###### service-hosp-client：医院api接口\\n###### service-order-client：订单api接口\\n###### service-user-client：用户api接口\\n#### sql：项目涉及的sql文件\\n\\n# 1、项目介绍\\n> 段落引用尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\\n# 2、技术点\\n #### 后端:\\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\\n3. MyBatis-Plus：持久层框架\\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\\n6. EasyExcel：操作excel表格，进行行读写操作\\n7. RabbitMQ：消息中间件（订单相关操作）\\n8. HTTPClient: Http协议客户端\\n9. Nginx：负载均衡\\n10. Mysql：关系型数据库\\n11. \\n#### 前端：\\n1. Vue.js：web 界面的渐进式框架\\n2. Node.js： JavaScript 运行环境\\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\\n4. NPM：包管理器\\n5. Babel：转码器\\n6. Webpack：打包工具\\n7. ECharts：图表展示\\n#### 其他:\\n1. Lombok\\n2. Swagger2：Api接口文档工具\\n3. Docker ：容器技术\\n4. Git：代码管理工具\\n5. 阿里云oss\\n6. 阿里云短信服务\\n7. 微信登录、支付\\n8. 定时任务\\n# 3、业务流程\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\\n\\n# 4、微服务架构\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\\n\\n# 5、git地址\\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png\",\"articleTitle\":\"尚医通项目总结\",\"categoryName\":\"项目总结\",\"id\":56,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:56:30',NULL),(1196,'标签模块','删除','/admin/tags','com.minzheng.blog.controller.TagController.deleteTag','删除标签','[[31]]','DELETE','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:56:36',NULL),(1197,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"\\n# <center>云e办项目总结\\n## 前言\\n本项目基于b站的云e办项目，视频链接：https://www.bilibili.com/video/BV1ff4y1M7XK?p=71&share_source=copy_web ，采用主流技术springboot+vue前后端分离开发，做完之后发现跟github上23kstar的vhr（微人事）项目有一点点相似...\\n## 项目截图\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/014a015e70db8fedb3a6352bdc4cc22a.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/90e99ce311a5880e67a54154175f2a76.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c1ed6b222c679471d9e1df80e3423852.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/a5de07da64dae300dbf27639ec483624.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/1adcdf2d933bf1eeeea7bef62a901461.png)\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4363ecaab6d9d386de5fb4bdc54e1553.png)\\n## 功能模块\\n- 员工资料：基本资料、高级资料\\n- 人事管理（尚未开发）\\n- 薪资管理：工资账套管理、员工账套管理（工资表管理、月末处理、工资表查询尚未开发）\\n- 统计管理（尚未开发）\\n- 系统管理：基础信息设置（部门管理、职位管理、职称管理、奖惩规则、权限组）、操作员管理（展示以及编辑操作员信息以及对应的角色信息）\\n- websocket在线聊天\\n## 项目技术栈\\n### 后端技术栈\\n1. Spring Boot\\n2. Spring Security\\n3. Mybatis+Mybatis-Plus\\n4. Redis\\n5. RabbitMQ\\n6. WebSocket\\n7. 阿里云oss\\n8. mail\\n9. ...\\n\\n### 前端技术栈\\n1. Vue\\n2. ElementUI\\n3. axios\\n4. vue-router\\n5. Vuex\\n6. WebSocket\\n7. vue-cli4\\n8. ...\\n\\n## 项目源码\\ngitee：https://gitee.com/icatw/cloudEOffice\\ngithub：https://github.com/icatw/cloudEOffice\\n\\n原项目使用fastdfs作为分布式文件存储系统，而我改用了阿里云的oss作为图片存储，另外采用了ui界面更为美观的knife4j作为接口文档（仍然存在很多bug）\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/019c8f19df5b1551d008d2eae1e8dbcb.png\",\"articleTitle\":\"云e办项目总结\",\"categoryName\":\"项目总结\",\"id\":92,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:57:14',NULL),(1198,'标签模块','新增或修改','/admin/tags','com.minzheng.blog.controller.TagController.saveOrUpdateTag','添加或修改标签','[{\"id\":30,\"tagName\":\"项目总结\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-23 22:57:32',NULL),(1199,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# MySQL学习基础篇\\n\\n## 1. SQL\\n\\n**全称 Structured Query Language，结构化查询语言**。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。\\n\\n### 1.1 SQL通用语法\\n\\n- SQL语句可以单行或者多行书写，以分号结尾。\\n- SQL语句可以使用空格/缩进来增强语句的可读性。\\n- MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\\n- 注释\\n    - 单行注释：-- 注释内容 或 # 注释内容\\n    - 多行注释： /* 注释内容 */\\n\\n### 1.2 SQL分类\\n\\nSQL语句，根据其功能，主要分为四类：**DDL、DML、DQL、DCL**。\\n\\n| 分类 | 全称                        | 说明                                                    |\\n| ---- | --------------------------- | :------------------------------------------------------ |\\n| DDL  | Data Definition Language    | 数据定义语言，用来定义数据库对象(数据库，表， 字段)     |\\n| DML  | Data Manipuulation Language | 数据操作语言，用来对数据库表中的数据进行增删改          |\\n| DQL  | Data Query Language         | 数据查询语言，用来查询数据库中表的记录                  |\\n| DCL  | Data Control Language       | 数据控制语言，用来创建数据库用户、控制数据库的 访问权限 |\\n\\n### 1.3 DDL\\n\\n> **Data Definition Language，数据定义语言，用来定义数据库对象（数据库、表、字段）**\\n\\n#### 1.3.1 数据库操作\\n\\n这里我们直接使用可视化数据库工具Navicat演示命令\\n\\n- 查询所有数据库\\n\\n``` sql\\nshow databases;\\n```\\n\\n![image-20220523234102071](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232341162.png)\\n\\n- 查询当前数据库\\n\\n``` sql\\nselect database()\\n```\\n\\n- 创建数据库\\n\\n``` sql\\ncreate database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;\\n```\\n\\n>  注：[ ] 中的值为可选项，default代表有默认值\\n\\n案例：\\n\\nA. 创建一个icatw数据库，使用数据库默认的字符集。\\n\\n``` sql\\nCREATE DATABASE icatw;\\n```\\n\\n![image-20220523234756349](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232347399.png)\\n\\n在同一个数据库服务器中，数据库名不可重复，必须唯一，否则将会报错。\\n\\n![image-20220523234950307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232349389.png)\\n\\n可以通过 `` if not exists``（如果不存在）参数来解决这个问题，只有是当数据库名不存在时，才会进行创建。\\n\\n``` sql\\nCREATE DATABASE IF NOT EXISTS icatw;\\n```\\n\\n![image-20220523235235940](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232352985.png)\\n\\nB.创建一个icat数据库，并且指定字符集\\n\\n``` sql\\n-- 创建icat数据库并指定utf8mb4为默认数据库\\nCREATE DATABASE icat DEFAULT CHARSET utf8mb4;\\n```\\n\\nutf8mb4比utf8支持更多字符，\\n\\n**utf8mb4支持最大4个字节的字符，而utf8最大只支持3个字节的字符，现在一般都使用utf8mb4作为mysql默认字符集**\\n\\n- 删除数据库\\n\\n``` sql\\n-- 删除数据库icat(如果存在)\\nDROP DATABASE IF EXISTS icat;\\n```\\n\\n如果不加上 if exists 的话，数据库不存在则会报错;\\n\\n- 切换数据库\\n\\n``` sql\\nUSE icatw;\\n```\\n\\n当我们需要操作某个数据库下的表时必须先切换到对应数据库\\n\\n#### 1.3.2 表操作\\n\\n对表的操作需要先使用`USE 数据库表`切换到对应数据库\\n\\n##### 1.3.2.1 表操作-查询创建\\n\\n1）. 查询当前数据库所有表\\n\\n查询表需要先使用 `USE 数据库名`切换数据库\\n\\n例:\\n\\n``` sql\\n-- 查询当前数据库下的所有表\\nUSE sys;\\nSHOW TABLES;\\n```\\n\\n![image-20220524084459677](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240845244.png)\\n\\n2）. 查看指定表结构\\n\\n``` sql\\ndesc 表名\\n```\\n\\n3）. 查询指定表的建表语句\\n\\n``` sql\\n-- 查询指定表的建表语句\\nSHOW CREATE TABLE sys_config;\\n```\\n\\n![image-20220524085039027](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240850135.png)\\n\\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\\n\\n4）. 创建表结构\\n\\n``` sql\\nCREATE TABLE 表名(\\n字段1 字段1类型 [ COMMENT 字段1注释 ],\\n字段2 字段2类型 [COMMENT 字段2注释 ],\\n字段3 字段3类型 [COMMENT 字段3注释 ],\\n......\\n字段n 字段n类型 [COMMENT 字段n注释 ]\\n) [ COMMENT 表注释 ] ;\\n\\n```\\n\\n例: 创建一张表tb_user，对应的结构如下\\n\\n|  id  |   name   | age  | gender |\\n| :--: | :------: | :--: | :----: |\\n|  1   |  令狐冲  |  28  |   男   |\\n|  2   |  风清扬  |  32  |   男   |\\n|  3   | 东方不败 |  34  |   男   |\\n\\n那么建表语句为：\\n\\n``` sql\\n-- 创建表结构\\nUSE icatw;\\nCREATE TABLE tb_user(\\nid INT COMMENT 主键id,\\nname VARCHAR(50) COMMENT 名字,\\nage INT COMMENT 年龄,\\ngender VARCHAR(1) 性别\\n)COMMENT 用户表 ;\\n```\\n\\n##### 1.3.2.2 表操作-数据类型\\n\\nMySQL中的数据类型有很多，主要分为三类：**数值类型、字符串类型、日期时间类型**\\n\\n1）. 数值类型\\n\\n| 类型        | 大小   | 有符号(SIGNED)范围                                     | 无符号(UNSIGNED)范围                                       | 描述                  |\\n| ----------- | ------ | ------------------------------------------------------ | ---------------------------------------------------------- | --------------------- |\\n| TINYINT     | 1byte  | (-128，127)                                            | (0，255)                                                   | 小整 数值             |\\n| SMALLINT    | 2bytes | (-32768，32767)                                        | (0，65535)                                                 | 大整 数值             |\\n| MEDIUMINT   | 3bytes | (-8388608，8388607)                                    | (0，16777215)                                              | 大整 数值             |\\n| INT/INTEGER | 4bytes | (-2147483648， 2147483647)                             | (0，4294967295)                                            | 大整 数值             |\\n| BIGINT      | 8bytes | (-2^63，2^63-1)                                        | (0，2^64-1)                                                | 极大 整数 值          |\\n| FLOAT       | 4bytes | (-3.402823466 E+38， 3.402823466351 E+38)              | 0 和 (1.175494351 E38，3.402823466 E+38)                   | 单精 度浮 点数 值     |\\n| DOUBLE      | 8bytes | (-1.7976931348623157 E+308， 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308) | 双精 度浮 点数 值     |\\n| DECIMAL     |        | 依赖于M(精度)和D(标度) 的值                            | 依赖于M(精度)和D(标度)的 值                                | 小数 值(精 确定 点数) |\\n\\n``` tex\\n如:\\n1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大\\nage tinyint unsigned\\n2). 分数 -- 总分100分, 最多出现一位小数\\nscore double(4,1)\\n通常使用DECIMAL 存储货币、钱\\n```\\n\\n2）. 字符串类型\\n\\n|    类型  |   大小   | 描述 |\\n| ---- | ---- | ---- |\\n| CHAR | 0-255 bytes | 定长字符串(需要指定长度) |\\n| VARCHAR | 0-65535 bytes | 变长字符串(需要指定长度) |\\n| TINYBLOB | 0-255 bytes | 不超过255个字符的二进制数据 |\\n| TINYTEXT | 0-255 bytes | 短文本字符串 |\\n| BLOB | 0-65535 bytes | 二进制形式的长文本数据 |\\n| TEXT | 0-65535 bytes | 长文本数据 |\\n| MEDIUMBLOB | 0-16777215 bytes | 二进制形式的中等长度文本数据 |\\n| MEDIUMTEXT | 0-16777215 bytes | 中等长度文本数据 |\\n| LONGBLOB | 0-4 294 967 295 bytes | 二进制形式的极大文本数据 |\\n| LONGTEXT | 0-4 294 967 295 bytes | 极大文本数据 |\\n\\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。\\n\\n``` tex\\n如：\\n1). 用户名 username ------> 长度不定, 最长不会超过50\\nusername varchar(50)\\n2). 性别 gender ---------> 存储值, 不是男,就是女\\ngender char(1)\\n3). 手机号 phone --------> 固定长度为11\\nphone char(11)\\n\\n```\\n\\n3） . 日期时间类型\\n\\n| 类型      | 大 小 | 范围                                       | 格式                | 描述                      |\\n| --------- | ----- | ------------------------------------------ | ------------------- | ------------------------- |\\n| DATE      | 3     | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                    |\\n| TIME      | 3     | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续 时间         |\\n| YEAR      | 1     | 1901 至 2155                               | YYYY                | 年份值                    |\\n| DATETIME  | 8     | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值         |\\n| TIMESTAMP | 4     | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值，时间戳 |\\n\\n``` tex\\n如:\\n    1). 生日字段 birthday\\n    birthday date\\n    2). 创建时间 createtime\\n    createtime datetime\\n```\\n\\n##### 1.3.2.3 表操作-案例\\n\\n> 设计一张员工信息表，要求如下：\\n>\\n> 1. 编号（纯数字）\\n> 2. 员工工号 (字符串类型，长度不超过10位)\\n> 3. 员工姓名（字符串类型，长度不超过10位） \\n> 4. 性别（男/女，存储一个汉字） \\n> 5. 年龄（正常人年龄，不可能存储负数） \\n> 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符） \\n> 7. 入职时间（取值年月日即可）\\n\\n对应的建表语句如下：\\n\\n``` sql\\ncreate table emp(\\n    id int comment \'编号\',\\n    workno varchar(10) comment \'工号\',\\n    name varchar(10) comment \'姓名\',\\n    gender char(1) comment \'性别\',\\n    age tinyint unsigned comment \'年龄\',\\n    idcard char(18) comment \'身份证号\',\\n    entrydate date comment \'入职时间\'\\n) comment \'员工表\';\\n```\\n\\n建表之后可通过 `desc emp`查看员工表结构\\n\\n![image-20220524093825055](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240938173.png)\\n\\n至此，员工表就已经创建好了，当我们指定了字段的最大长度之后，超出最大长度将会报错。\\n\\n##### 1.3.2.4 表操作-修改\\n\\n1）. 添加字段\\n\\n``` sql\\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\\n```\\n\\n案例:\\n\\n为emp表增加一个新的字段\\\"昵称\\\"为nickname，类型为varchar(20)\\n\\n``` sql\\n-- 添加字段\\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT \'昵称\';\\n```\\n\\n2）. 修改数据类型\\n\\n``` sql\\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)\\n```\\n\\n3）. 修改字段名和字段类型\\n\\n``` sql\\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];\\n```\\n\\n案例:\\n\\n将emp表的nickname字段修改为username,类型为varchar(30)\\n\\n``` sql\\n-- 将emp表的nickname字段修改为username,类型为varchar(30)\\nALTER TABLE emp CHANGE nickname username VARCHAR(30) COMMENT \'用户名\';\\n```\\n\\n4）. 删除字段\\n\\n``` sql\\nALTER TABLE 表名 DROP 字段名;\\n```\\n\\n``` sql\\n-- 删除emp表中的username\\nALTER TABLE emp DROP username;\\n```\\n\\n5）. 修改表名\\n\\n``` sql\\nALTER TABLE 表名 RENAME TO 新表名;\\n```\\n\\n案例:\\n\\n将emp表的表名修改为employee\\n\\n``` sql\\n-- 修改表名ALTER TABLE 表名 RENAME TO 新表名;\\nALTER  TABLE emp RENAME TO employee;\\n```\\n\\n**总结:**\\n\\n​\\t**对表的修改操作通用格式为**:` ALTER TABLE 表名 操作名(ADD,MODIFY,CHANGE,DROP,RENAME TO)`\\n\\n##### 1.3.2.5 表操作-删除\\n\\n1）. 删除表\\n\\n``` sql\\nDROP TABLE [IF EXISTS] 表名;\\n```\\n\\n可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。\\n\\n案例: \\n\\n如果tb_user表存在，则删除tb_user表\\n\\n``` sql\\nDROP TABLE IF EXISTS tb_user;\\n```\\n\\n2）. 删除指定表，并重新创建表\\n\\n``` sql\\nTRUNCATE TABLE 表名;\\n```\\n\\n> 我的理解是 相当于清空数据，新建的表结构并不会发生变化\\n\\n### 1.4 图形化界面工具\\n\\nidea、Navicat\\n\\n这里我们使用idea的自带的数据库操作工具学习\\n\\n### 1.5 DML\\n\\n>  **DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作**。\\n\\n- 添加数据（INSERT） \\n- 修改数据（UPDATE） \\n- 删除数据（DELETE）\\n\\n#### 1.5.1 添加数据\\n\\n1）. 给指定字段添加数据\\n\\n``` sql\\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\\n```\\n\\n案例：给employee表所有的字段添加数据 ；\\n\\n```sql\\n# 插入数据\\ninsert into employee (id, workno, name, gender, age, idcard, entrydate)\\nvalues (1,\'1\',\'icatw\',\'男\',18,\'431088200205180463\',\'2002-05-22\');\\n```\\n\\n插入数据完成之后有两种方式查询数据库的数据\\n\\nA. 方式一\\n\\n在表名上双击，就可以看到这张表的数据。\\n\\n![image-20220524124505124](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205241245329.png)\\n\\nB. 方式二\\n\\n直接使用查询的SQL语句\\n\\n``` sql\\nselect * from employee;\\n```\\n\\n2）. 给全部字段添加数据\\n\\n``` sql\\nINSERT INTO 表名 VALUES (值1, 值2, ...);\\n```\\n\\n案例：给employee表的所有字段添加数据\\n\\n``` sql\\n# 给所有字段添加数据\\ninsert into employee values (2, \'2\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'2005-01-01\');\\n```\\n\\n3）. 批量添加数据\\n\\n``` sql\\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\\n```\\n\\n``` sql\\nINSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\\n```\\n\\n案例：批量插入数据到employee表\\n\\n``` sql\\ninsert into employee values(3,\'3\',\'韦一笑\',\'男\',38,\'123456789012345670\',\'2005-01-01\'),(4,\'4\',\'赵敏\',\'女\',18,\'123456789012345670\',\'2005-01-01\');\\n\\n```\\n\\n> 注意事项：\\n>\\n> - 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\\n> - 字符串和日期型数据应该包含在引号中。\\n> - 插入的数据大小，应该在字段的规定范围内，不能超过最大值。\\n\\n#### 1.5.2 修改数据\\n\\n修改数据的具体语法为：\\n\\n```sql\\nUPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;\\n```\\n\\n**如果不指定where条件将修改所有行**\\n\\n案例：\\n\\nA. 修改id为1的数据，将那么修改为icatw2\\n\\n``` sql\\nupdate employee set name=\'icatw2\' where id=1;\\n```\\n\\nB. 修改id为1的数据，将name修改为小昭，gender修改为女\\n\\n``` sql\\nupdate employee set name=\'小昭\' ,gender=\'女\' where id=1;\\n```\\n\\nC. 将所有员工的入职日期修改为2008-01-01\\n\\n``` sql\\nupdate employee set entrydate=\'2008-01-01\'\\n```\\n\\n> 注意事项：\\n>\\n> ​\\t\\t**修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。**\\n\\n#### 1.5.3 删除数据\\n\\n语法：\\n\\n``` sql\\ndelete from 表名 [where 条件];\\n```\\n\\n案例：\\n\\nA. 删除gender为女的员工\\n\\n``` sql\\ndelete from employee where gender=\'女\';\\n```\\n\\nB. 删除所有员工\\n\\n``` sql\\ndelete from employee\\n```\\n\\n> 注意事项: \\n>\\n> - DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。\\n> - DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\\n> - 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击 Execute即可。\\n\\n\\n\\n### 1.6 DDL\\n\\n> **DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。** \\n\\n查询关键字: **SELECT** \\n\\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站， 在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\\n\\n首先我们准备数据\\n\\n``` sql\\n# 添加数据\\ndrop table if exists employee;\\ncreate table emp\\n(\\n    id          int comment \'编号\',\\n    workno      varchar(10) comment \'工号\',\\n    name        varchar(10) comment \'姓名\',\\n    gender      char(1) comment \'性别\',\\n    age         tinyint unsigned comment \'年龄\',\\n    idcard      char(18) comment \'身份证号\',\\n    workaddress varchar(50) comment \'工作地址\',\\n    entrydate   date comment \'入职时间\'\\n) comment \'员工表\';\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (1, \'00001\', \'柳岩666\', \'女\', 20, \'123456789012345678\', \'北京\', \'2000-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (2, \'00002\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'北京\', \'2005-09-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (3, \'00003\', \'韦一笑\', \'男\', 38, \'123456789712345670\', \'上海\', \'2005-08-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (4, \'00004\', \'赵敏\', \'女\', 18, \'123456757123845670\', \'北京\', \'2009-12-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (5, \'00005\', \'小昭\', \'女\', 16, \'123456769012345678\', \'上海\', \'2007-07-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (6, \'00006\', \'杨逍\', \'男\', 28, \'12345678931234567X\', \'北京\', \'2006-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (7, \'00007\', \'范瑶\', \'男\', 40, \'123456789212345670\', \'北京\', \'2005-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (8, \'00008\', \'黛绮丝\', \'女\', 38, \'123456157123645670\', \'天津\', \'2015-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (9, \'00009\', \'范凉凉\', \'女\', 45, \'123156789012345678\', \'北京\', \'2010-04-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (10, \'00010\', \'陈友谅\', \'男\', 53, \'123456789012345670\', \'上海\', \'2011-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (11, \'00011\', \'张士诚\', \'男\', 55, \'123567897123465670\', \'江苏\', \'2015-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (12, \'00012\', \'常遇春\', \'男\', 32, \'123446757152345670\', \'北京\', \'2004-02-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (13, \'00013\', \'张三丰\', \'男\', 88, \'123656789012345678\', \'江苏\', \'2020-11-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (14, \'00014\', \'灭绝\', \'女\', 65, \'123456719012345670\', \'西安\', \'2019-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (15, \'00015\', \'胡青牛\', \'男\', 70, \'12345674971234567X\', \'西安\', \'2018-04-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (16, \'00016\', \'周芷若\', \'女\', 18, null, \'北京\', \'2012-06-01\');\\n\\n```\\n\\n#### 1.6.1 基本语法\\n\\nDDL查询语句，语法结构如下：\\n\\n``` sql\\nSELECT\\n字段列表\\nFROM\\n表名列表\\nWHERE\\n条件列表\\nGROUP BY\\n分组字段列表\\nHAVING\\n分组后条件列表\\nORDER BY\\n排序字段列表\\nLIMIT\\n分页参数\\n\\n```\\n\\n大致可以拆分为以下几个部分：\\n\\n- 基本查询（不带任何条件） \\n- 条件查询（WHERE） \\n- 聚合函数（count、max、min、avg、sum） \\n- 分组查询（group by） \\n- 排序查询（order by） \\n- 分页查询（limit）\\n\\n#### 1.6.2基本查询\\n\\n在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：\\n\\n1）. 查询多个字段\\n\\n``` sql\\nselect 字段1,字段2,字段3 ... from 表名;\\n```\\n\\n``` sql\\nSELECT * FROM 表名 ;\\n```\\n\\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\\n\\n2）. 字段设置别名\\n\\n``` sql\\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;\\n```\\n\\n``` sql\\n# as 也可省略\\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\\n```\\n\\n3）. 去除重复记录\\n\\n``` sql\\nselect distinct 字段列表 from 表名;\\n```\\n\\n案例：\\n\\nA. 查询指定字段 name，workno，age并返回\\n\\n``` sql\\nselect name,workno,age from emp;\\n```\\n\\nB. 查询返回所有字段\\n\\n``` sql\\nselect id,workno,name,gender,age,idcard,workaddress,entrydate from emp;\\n```\\n\\n``` sql\\nselect * from emp;\\n```\\n\\nC. 查询所有员工的工作地址，起别名\\n\\n``` sql\\nselect workaddress as \'工作地址\' from emp;\\n```\\n\\n``` sql\\n-- as可以省略\\nselect workaddress \'工作地址\' from emp;\\n```\\n\\nD. 查询公司员工的上班地址有哪些（去重）\\n\\n``` sql\\nselect distinct workaddress \'工作地址\' from emp;\\n```\\n\\n#### 1.6.3 条件查询\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 where 条件列表;\\n```\\n\\n2）. 条件\\n\\n常用的比较运算符如下：\\n\\n| 比较运算符          | 功能                                     |\\n| ------------------- | ---------------------------------------- |\\n| >                   | 大于                                     |\\n| >=                  | 大于等于                                 |\\n| <                   | 小于                                     |\\n| <=                  | 小于等于                                 |\\n| =                   | 等于                                     |\\n| <> 或 !=            | 不等于                                   |\\n| BETWEEN ... AND ... | 在某个范围之内(含最小、最大值)           |\\n| IN(...)             | 在in之后的列表中的值，多选一             |\\n| LIKE 占位符         | 模糊匹配(_匹配单个字符, %匹配任意个字符) |\\n| IS NULL             | 是NULL                                   |\\n\\n常用的逻辑运算符如下：\\n\\n|逻辑运算符|功能|\\n|----|----|\\n|AND 或 &&|并且 (多个条件同时成立)|\\n|OR 或 \\\\|\\\\||或者 (多个条件任意一个成立)|\\n|NOT 或 !|非 , 不是|\\n\\n案例：\\n\\nA. 查询年龄等于88的员工\\n\\n``` sql\\nselect * from emp where age=88;\\n```\\n\\nB. 查询年龄小于20的员工信息\\n\\n``` sql\\nselect * from emp where age<20;\\n```\\n\\nC. 查询年龄小于等于20的员工信息\\n\\n``` sql\\nselect * from emp where age<=20;\\n```\\n\\nD. 查询没有身份证号的员工信息\\n\\n``` sql\\nselect * from emp where idcard is null;\\n```\\n\\nE. 查询有身份证号的员工信息\\n\\n``` sql\\nselect * from emp where idcard is not null;\\n```\\n\\nF. 查询年龄不等于88的员工信息\\n\\n``` sql\\nselect * from emp where age!=88;\\n```\\n\\n``` sql\\nselect * from emp where age<>88;\\n```\\n\\nG. 查询年龄在15岁（包含）到20岁（包含）之间的员工信息\\n\\n``` sql\\nselect * from emp where age >=15 and age <= 20;\\nselect * from emp where age>=15 && age <=20;\\nselect * from emp where age between 15 and 20;\\n```\\n\\nH. 查询性别为女 且年龄小于25的员工信息\\n\\n``` sql\\nselect * from emp where gender =\'女\' and age<25;\\n```\\n\\nI. 查询年龄等于18或20或40的员工信息\\n\\n``` sql\\nselect * from emp where age =18 or age =20 or age =40;\\nselect * from emp where age in(18,20,40)\\n```\\n\\nJ. 查询姓名为两个字的员工信息 _ %\\n\\n``` sql\\nselect * from emp where name like \'__\'\\n```\\n\\nK. 查询身份证号最后以为是x的员工信息\\n\\n``` sql\\nselect * from emp where idcard like \'%x\';\\nselect * from emp where idcard like \'_________________x\';\\n```\\n\\n#### 1.6.4 聚合函数\\n\\n1）. 介绍\\n\\n将一列数据作为一个整体，进行纵向计算。\\n\\n2）. 常见的聚合函数\\n\\n| 函数  | 功能     |\\n| ----- | -------- |\\n| count | 统计数量 |\\n| max   | 最大值   |\\n| min   | 最小值   |\\n| avg   | 平均值   |\\n| sum   | 求和     |\\n\\n3）. 语法\\n\\n``` sql\\nselect 聚合函数（字段列表） from 表名;\\n```\\n\\n> 注意：null值是不参与所有聚合函数运算的。\\n\\n案例：\\n\\nA. 统计该企业员工数量\\n\\n``` sql\\nselect count(*) from emp; -- 统计的是总记录数,也就是记录行数\\nselect count(idcard) from emp; -- 统计的是idcard字段不为null的记录数\\n```\\n\\n对于count聚合函数，统计符合条件的总记录数，还可以通过count（数字/字符串）的形式进行统计查询，比如：\\n\\n``` sql\\nselect count(1) from emp;\\n-- 效果等于 select count(*) from emp;\\n```\\n\\nB. 统计该企业员工的平均年龄\\n\\n``` sql\\nselect avg(age) from emp;\\n```\\n\\nC. 统计该企业员工的最大年龄\\n\\n``` sql\\nselect max(age) from emp;\\n```\\n\\nD. 统计该企业员工的最小年龄\\n\\n``` sql\\nselect min(age) from emp;\\n```\\n\\nE. 统计西安地区员工的年龄之和\\n\\n``` sql\\nselect sum(age) from emp where wordaddress=\'西安\';\\n```\\n\\n#### 1.6.5 分组查询\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\\n```\\n\\n2）. where与having区别\\n\\n- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\\n- 判断条件不同：where不能对聚合函数进行判断，而having可以。\\n\\n> 注意事项：\\n>\\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\\n> - 执行顺序: where > 聚合函数 > having 。\\n> - 支持多字段分组, 具体语法为 : group by columnA,columnB\\n\\n案例：\\n\\nA. 根据性别分组，统计男性员工和女性员工的数量\\n\\n``` sql\\nselect gender,count(*) from emp group by gender;\\n```\\n\\n![image-20220525150636926](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251506016.png)\\n\\nB. 根据性别分组，统计男性员工和女性员工的平均年龄\\n\\n``` sql\\nselect gender,avg(age) from emp group by gender;\\n```\\n\\n![image-20220525150757361](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251507435.png)\\n\\nC. 查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址\\n\\n``` sql\\nselect workaddress, count(*) address_count\\nfrom emp\\nwhere age < 45\\ngroup by workaddress\\nhaving address_count >= 3;\\n```\\n\\n![image-20220525151427330](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251514414.png)\\n\\nD. 统计各个工作地址上班的男性及女性员工的数量\\n\\n``` sql\\nselect workaddress \'地区\', gender \'性别\', count(*) \'数量\'\\nfrom emp\\ngroup by gender, workaddress;\\n```\\n\\n#### 1.6.6 排序查询\\n\\n排序是日常开发只能够非常常见的一个操作，分为升序和降序排序\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;\\n```\\n\\n2）. 排序方式\\n\\n- ASC：升序（默认值）\\n- DESC：降序\\n\\n> 注意事项\\n>\\n> - 如果是升序, 可以不指定排序方式ASC ; \\n> - 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\\n\\n案例：\\n\\nA. 根据年龄对公司的员工进行升序排序\\n\\n``` sql\\nselect * from emp order by age asc;\\nselect * from emp order by age;\\n```\\n\\nB. 根据入职时间，对员工进行降序排序\\n\\n``` sql\\nselect * from emp order by entry date desc;\\n```\\n\\nC. 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序\\n\\n``` sql\\nselect * from emp order by age asc , entrydate desc;\\n```\\n\\n#### 1.6.7 分页查询\\n\\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台 都需要借助于数据库的分页操作。\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 limit 起始索引 , 查询记录数;\\n```\\n\\n> 注意事项: \\n>\\n> - **起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数**。 \\n> - 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 \\n> - 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10\\n\\n案例：\\n\\nA. 查询第一页员工数据，每页显示十条记录\\n\\n``` sql\\n-- 起始索引为 （查询页码）-1*每页显示记录数\\nselect * from emp limit 0,10;\\n-- 查询的为第一页数据，起始索引可以省略\\nselect * from emp limit 10;\\n```\\n\\nB. 查询第二页员工数据，每页展示10条记录\\n\\n--------> (页码-1)*页展示记录数\\n\\n``` sql\\n-- 需要查询的为第二页员工数据\\n-- 起始索引等于 （查询页码-1）*每页显示记录数\\n-- 因此，此处起始索引为（2-1）*10\\nselect * from emp limit 10,10;\\n```\\n\\n#### 1.6.8 案例\\n\\n1）. 查询年龄为20,21,22,23岁的员工信息。\\n\\n``` sql\\nselect * from emp where age in(20,21,22,23);\\n```\\n\\n2）. 查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\\n\\n``` sql\\n#  查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\\nselect *\\nfrom emp\\nwhere gender = \'男\'\\n  and age between 20 and 40\\n  and name like \'___\';\\n```\\n\\n3）. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\\n\\n``` sql\\n# 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\\nselect gender, count(*)\\nfrom emp\\nwhere age < 60\\ngroup by gender;\\n```\\n\\n4）. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按 入职时间降序排序。\\n\\n``` sql\\nselect name, age\\nfrom emp\\nwhere age <= 35\\norder by age, entrydate desc;\\n```\\n\\n5）.  查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere gender = \'男\'\\n  and age between 20 and 40\\norder by age, entrydate desc\\nlimit 5;\\n```\\n\\n#### 1.6.9 执行顺序\\n\\n![image-20220525154935887](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251549982.png)\\n\\n**DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...**\\n\\n### 1.7 DCL\\n\\n> DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。\\n\\n![image-20220525155152013](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251551105.png)\\n\\n#### 1.7.1 管理用户\\n\\n1）. 查询用户\\n\\n``` sql\\nselect * from mysql.user;\\n```\\n\\n查询结果如下：\\n\\n![image-20220525155335839](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251619656.png)\\n\\n**其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户**\\n\\n2）. 创建用户\\n\\n``` sql\\ncreate user \'用户名\'@\'主机名\' identified by \'密码\';\\n```\\n\\n3）. 修改用户密码\\n\\n``` sql\\nalter user \'用户名\'@\'主机名\' identified with mysql_native_password by \'新密码\';\\n```\\n\\n4）. 删除用户\\n\\n``` sql\\ndrop user \'用户名\'@\'主机名\';\\n```\\n\\n> 注意事项: \\n>\\n> - 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\\n> - 主机名可以使用 % 通配。 \\n> - 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。\\n\\n案例：\\n\\nA. 创建用户icat, 只能够在当前主机localhost访问, 密码123456;\\n\\n``` sql\\ncreate user \'icat\'@\'localhost\' identified by \'123456\';\\n```\\n\\nB. 创建用户icatw, 可以在任意主机访问该数据库, 密码123456;\\n\\n``` sql\\ncreate user \'icatw\'@\'%\' identified by \'123456\';\\n```\\n\\nC. 修改用户icatw的访问密码为1234;\\n\\n``` sql\\nalter user \'icatw\'@\'%\' identified with mysql_native_password by \'1234\';\\n```\\n\\nD. 删除 icat@localhost 用户\\n\\n``` sql\\ndrop user \'icat\'@\'localhost\';\\n```\\n\\n#### 1.7.2 权限控制\\n\\nMySQL中定义了很多种权限，但是常用的就以下几种：\\n\\n| 权限                | 说明               |\\n| ------------------- | ------------------ |\\n| ALL, ALL PRIVILEGES | 所有权限           |\\n| SELECT              | 查询数据           |\\n| INSERT              | 插入数据           |\\n| UPDATE              | 修改数据           |\\n| DELETE              | 删除数据           |\\n| ALTER               | 修改表             |\\n| DROP                | 删除数据库/表/视图 |\\n| CREATE              | 创建数据库/表      |\\n\\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html)。\\n\\n1）. 查询权限\\n\\n``` sql\\nSHOW GRANTS FOR \'用户名\'@\'主机名\' ;\\n```\\n\\n2）. 授予权限\\n\\n``` sql\\nGRANT 权限列表 ON 数据库名.表名 TO \'用户名\'@\'主机名\';\\n```\\n\\n3）. 撤销权限\\n\\n``` sql\\nREVOKE 权限列表 ON 数据库名.表名 FROM \'用户名\'@\'主机名\';\\n```\\n\\n> 注意事项： \\n>\\n> - 多个权限之间，使用逗号分隔 \\n> - 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\\n\\n案例: \\n\\nA. 查询 \'heima\'@\'%\' 用户的权限\\n\\n``` sql\\nshow grants for \'heima\'@\'%\';\\n```\\n\\nB. 授予 \'heima\'@\'%\' 用户itcast数据库所有表的所有操作权限\\n\\n``` sql\\ngrant all on itcast.* to \'heima\'@\'%\'\\n```\\n\\nC. 撤销 \'heima\'@\'%\' 用户的itcast数据库的所有权限\\n\\n``` sql\\nrevoke all on itcast.* from \'heima\'@\'%\';\\n```\\n\\n\\n\\n## 2. 函数\\n\\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那 么，函数到底在哪儿使用呢？ 我们先来看两个场景：\\n\\n![image-20220525162834366](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251628459.png)\\n\\n1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能 够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计 算出天数呢？ \\n\\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的 分数值，如98/75，如何快速判定分数的等级呢？ 其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。\\n\\n其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。 \\n\\nMySQL中的函数主要分为以下四类： **字符串函数、数值函数、日期函数、流程函数。**\\n\\n### 2.1 字符串函数\\n\\nMySQL中内置了很多字符串函数，常用的几个如下：\\n\\n| 函数                     | 功能                                                       |\\n| ------------------------ | ---------------------------------------------------------- |\\n| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串               |\\n| LOWER(str)               | 将字符串str全部转为小写                                    |\\n| UPPER(str)               | 将字符串str全部转为大写                                    |\\n| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 |\\n| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 |\\n| TRIM(str)                | 去掉字符串头部和尾部的空格                                 |\\n| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串            |\\n\\n演示如下：\\n\\nA. concat：字符串拼接\\n\\n``` sql\\nselect concat(\'Hello\' , \' MySQL\');\\n```\\n\\n结果如下：\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251651650.png\\\" alt=\\\"image-20220525165104555\\\" style=\\\"zoom:67%;\\\" />\\n\\nB. lower : 全部转小写\\n\\n``` sql\\nselect lower(\'Hello\');\\n```\\n\\n![image-20220525165228376](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251652464.png)\\n\\nC. upper : 全部转大写\\n\\n``` sql\\nselect upper(\'Hello\');\\n```\\n\\n![image-20220525165323592](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251653679.png)\\n\\nD.  lpad : 左填充\\n\\n``` sql\\nselect lpad(\'01\', 5, \'-\');\\n```\\n\\n![image-20220525165433666](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251654755.png)\\n\\nE. rpad : 右填充\\n\\n``` sql\\nselect rpad(\'01\', 5, \'-\');\\n```\\n\\n![image-20220525165713762](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251657320.png)\\n\\nF. trim : 去除空格\\n\\n``` sql\\nselect trim(\' Hello MySQL \');\\n```\\n\\nG. substring : 截取子字符串\\n\\n``` sql\\nselect substring(\'Hello MySQL\',1,5);\\n```\\n\\n案例：\\n\\n![image-20220525174936078](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251749181.png)\\n\\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员 工的工号应该为00001。\\n\\n``` sql\\nupdate emp set workno = lpad(workno, 5, \'0\');\\n```\\n\\n处理完毕后, 具体的数据为:\\n\\n![image-20220525175223093](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251752289.png)\\n\\n### 2.2 数值函数\\n\\n常见的数值函数如下：\\n\\n| 函数       | 功能                               |\\n| ---------- | ---------------------------------- |\\n| CEIL(x)    | 向上取整                           |\\n| FLOOR(x)   | 向下取整                           |\\n| MOD(x,y)   | 返回x/y的模                        |\\n| RAND()     | 返回0~1内的随机数                  |\\n| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |\\n\\n演示如下：\\n\\nA. ceil：向上取整\\n\\n``` sql\\nselect ceil(1.1);\\n```\\n\\nB. floor：向下取整\\n\\n``` sql\\nselect floor(1.9)\\n```\\n\\nC. mod：取模\\n\\n``` sql\\nselect mod(7,4);\\n```\\n\\nD. rand：获取随机数\\n\\n``` sql\\nselect rand();\\n```\\n\\nE. round：四舍五入\\n\\n``` sql\\nselect round(2.344,2);\\n```\\n\\n案例： \\n\\n通过数据库的函数，生成一个六位数的随机验证码。\\n\\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础 上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\\n\\n``` sql\\nselect lpad(round(rand()*1000000 , 0), 6, \'0\');\\n```\\n\\n### 2.3 日期函数\\n\\n常见的日期函数如下：\\n\\n| 函数                               | 功能                                               |\\n| ---------------------------------- | -------------------------------------------------- |\\n| CURDATE()                          | 返回当前日期                                       |\\n| CURTIME()                          | 返回当前时间                                       |\\n| NOW()                              | 返回当前日期和时间                                 |\\n| YEAR(date)                         | 获取指定date的年份                                 |\\n| MONTH(date)                        | 获取指定date的月份                                 |\\n| DAY(date)                          | 获取指定date的日期                                 |\\n| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的 时间值 |\\n| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天 数      |\\n\\n演示如下：\\n\\nA. curdate：当前日期\\n\\n``` sql\\nselect curdate();\\n```\\n\\nB. curtime：当前时间\\n\\n``` SQL\\nselect curtime();\\n```\\n\\nC. now：当前日期和时间\\n\\n``` sql\\nselect now();\\n```\\n\\nD. YEAR , MONTH , DAY：当前年、月、日\\n\\n``` sql\\nselect YEAR(now());\\nselect MONTH(now());\\nselect DAY(now());\\n```\\n\\nE. date_add：增加指定的时间间隔\\n\\n``` sql\\nselect date_add(now(), INTERVAL 70 YEAR );\\n```\\n\\nF. datediff：获取两个日期相差的天数\\n\\n``` sql\\nselect datediff(\'2021-10-01\', \'2021-12-01\');\\n```\\n\\n案例： \\n\\n查询所有员工的入职天数，并根据入职天数倒序排序。 \\n\\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\\n\\n``` sql\\nselect name, datediff(curdate(), entrydate) as \'entrydays\' from emp order by entrydays desc;\\n\\n```\\n\\n### 2.4 流程函数\\n\\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\\n\\n| 函数                                                         | 功能                                                       |\\n| ------------------------------------------------------------ | ---------------------------------------------------------- |\\n| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回 f                       |\\n| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则 返回value2              |\\n| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |\\n| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |\\n演示如下：\\n\\nA. if\\n\\n``` sql\\nselect if(false, \'Ok\', \'Error\');\\n```\\n\\nB. ifnull \\n\\n``` sql\\nselect ifnull(\'Ok\',\'Default\');\\nselect ifnull(\'\',\'Default\');\\n-- 只有这个才会输出default\\nselect ifnull(null,\'Default\');\\n```\\n\\nC. case when then else end\\n\\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----> 一线城市 , 其他 ----> 二线城市)\\n\\n``` sql\\nselect name,\\n       (case workaddress\\n            when \'北京\' then \'一线城市\'\\n            when \'上海\' then \'一线城市\'\\n            else\\n                \'二线城市\' end) as \'工作地址\'\\nfrom emp;\\n```\\n\\n案例：\\n\\n将学生表按成绩分类\\n\\n首先，准备数据\\n\\n``` sql\\ncreate table score\\n(\\n    id      int comment \'ID\',\\n    name    varchar(20) comment \'姓名\',\\n    math    int comment \'数学\',\\n    english int comment \'英语\',\\n    chinese int comment \'语文\'\\n) comment \'学员成绩表\';\\ninsert into score(id, name, math, english, chinese)\\nVALUES (1, \'Tom\', 67, 88, 95),\\n       (2, \'Rose\', 23, 66, 90),\\n       (3, \'Jack\', 56, 98, 76);\\n\\n```\\n\\n具体SQL如下\\n\\n``` sql\\nselect id,\\n       name,\\n       (case when math >= 85 then \'优秀\' when math >= 60 then \'及格\' else \'不及格\' end)\\n                \'数学\',\\n       (case\\n            when english >= 85 then \'优秀\'\\n            when english >= 60 then \'及格\'\\n            else \'不及格\'\\n           end) \'英语\',\\n       (case\\n            when chinese >= 85 then \'优秀\'\\n            when chinese >= 60 then \'及格\'\\n            else \'不及格\'\\n           end) \'语文\'\\nfrom score;\\n```\\n\\n![image-20220525181610736](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251816834.png)\\n\\nMySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景， 思考一下需要用到什么样的函数来实现? \\n\\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------> \\n\\n答案: datediff \\n\\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------> \\n\\n答案: case ... when ...\\n\\n## 3. 约束\\n\\n### 3.1 概述\\n\\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\\n\\n目的：保证数据库中数据的正确、有效性和完整性。\\n\\n分类：\\n\\n| 约束                      | 描述                                                      | 关键字      |\\n| ------------------------- | --------------------------------------------------------- | ----------- |\\n| 非空约束                  | 限制该字段的数据不能为null                                | NOT NULL    |\\n| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                    | UNIQUE      |\\n| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                  | PRIMARY KEY |\\n| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值            | DEFAULT     |\\n| 检查约束(8.0.16版本 之后) | 保证字段值满足某一个条件                                  | CHECK       |\\n| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致 性和完整性 | FOREIGN KEY |\\n\\n> 注意：**约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。**\\n\\n### 3.2 约束演示\\n\\n案例需求： 根据需求，完成表结构的创建。需求如下：\\n\\n| 字段名 | 字段含 义   | 字段类型    | 约束条件                   | 约束关键字                  |\\n| ------ | ----------- | ----------- | -------------------------- | --------------------------- |\\n| id     | ID唯一 标识 | int         | 主键，并且自动增长         | PRIMARY KEY, AUTO_INCREMENT |\\n| name   | 姓名        | varchar(10) | 不为空，并且唯一           | NOT NULL , UNIQUE           |\\n| age    | 年龄        | int         | 大于0，并且小于等 于120    | CHECK                       |\\n| status | 状态        | char(1)     | 如果没有指定该值， 默认为1 | DEFAULT                     |\\n| gender | 性别        | char(1)     | 无                         |                             |\\n\\n对应的建表语句为：\\n\\n``` sql\\nCREATE TABLE tb_user\\n(\\n    id     int AUTO_INCREMENT PRIMARY KEY COMMENT \'ID唯一标识\',\\n    name   varchar(10) NOT NULL UNIQUE COMMENT \'姓名\',\\n    age    int check (age > 0 && age <= 120) COMMENT \'年龄\',\\n    status char(1) default \'1\' COMMENT \'状态\',\\n    gender char(1) COMMENT \'性别\'\\n);\\n```\\n\\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。\\n\\n### 3.3 外键约束\\n\\n#### 3.3.1 介绍\\n\\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\\n\\n准备数据\\n\\n``` sql\\ncreate table dept\\n(\\n    id   int auto_increment comment \'ID\' primary key,\\n    name varchar(50) not null comment \'部门名称\'\\n) comment \'部门表\';\\nINSERT INTO dept (id, name)\\nVALUES (1, \'研发部\'),\\n       (2, \'市场部\'),\\n       (3, \'财务部\'),\\n       (4,\\n        \'销售部\'),\\n       (5, \'总经办\');\\ndrop table if exists icatw.emp;\\ncreate table emp\\n(\\n    id        int auto_increment comment \'ID\' primary key,\\n    name      varchar(50) not null comment \'姓名\',\\n    age       int comment \'年龄\',\\n    job       varchar(20) comment \'职位\',\\n    salary    int comment \'薪资\',\\n    entrydate date comment \'入职时间\',\\n    managerid int comment \'直属领导ID\',\\n    dept_id   int comment \'部门ID\'\\n) comment \'员工表\';\\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\\n       (2, \'张无忌\', 20,\\n        \'项目经理\', 12500, \'2005-12-05\', 1, 1),\\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1);\\n\\n```\\n\\n\\n\\n#### 3.3.2 语法\\n\\n1）. 添加外键\\n\\n``` sql\\nCREATE TABLE 表名(\\n字段名 数据类型,\\n...\\n[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)\\n);\\n```\\n\\n``` sql\\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)\\nREFERENCES 主表 (主表列名) ;\\n```\\n\\n案例：\\n\\n为emp表的dept_id字段添加外键约束，关联dept表的主键id。\\n\\n``` sql\\nalter table emp\\n    add constraint fk foreign key (dept_id) references dept (id);\\n```\\n\\n![image-20220525212454577](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252124722.png)\\n\\n**当添加外键约束之后，不能直接删除父表的记录，需要先删除子表所关联数据，否则会报错。**\\n\\n2）. 删除外键\\n\\n``` sql\\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\\n```\\n\\n案例：\\n\\n删除emp表的外键fk。\\n\\n``` sql\\nalter table emp\\n    drop foreign key fk;\\n```\\n\\n#### 3.3.3 删除/更新行为\\n\\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:\\n\\n| 行为        | 说明                                                         |\\n| ----------- | ------------------------------------------------------------ |\\n| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为 |\\n| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为 |\\n| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。 |\\n| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。 |\\n| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)  |\\n\\n具体语法为：\\n\\n``` sql\\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\\n主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;\\n```\\n\\n## 4. 多表查询\\n\\n### 4.1 多表关系\\n\\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\\n\\n- 一对多(多对一) \\n- 多对多 \\n- 一对一\\n\\n#### 4.1.1 一对多\\n\\n- 案例：部门与员工的关系\\n- 关系：一个部门对应多名员工，一个员工对应一个部门\\n- 实现：在多的一方建立外键，指向另一方的主键\\n\\n![image-20220525213949714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252139778.png)\\n\\n#### 4.1.2 多对多\\n\\n- 案例：学生与课程的关系\\n- 关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\\n- 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\\n\\n![image-20220525214004144](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252140207.png)\\n\\n对应的SQL脚本：\\n\\n``` sql\\ncreate table student\\n(\\n    id   int auto_increment primary key comment \'主键ID\',\\n    name varchar(10) comment \'姓名\',\\n    no   varchar(10) comment \'学号\'\\n) comment \'学生表\';\\ninsert into student\\nvalues (null, \'黛绮丝\', \'2000100101\'),\\n       (null, \'谢逊\',\\n        \'2000100102\'),\\n       (null, \'殷天正\', \'2000100103\'),\\n       (null, \'韦一笑\', \'2000100104\');\\ncreate table course\\n(\\n    id   int auto_increment primary key comment \'主键ID\',\\n    name varchar(10) comment \'课程名称\'\\n) comment \'课程表\';\\ninsert into course\\nvalues (null, \'Java\'),\\n       (null, \'PHP\'),\\n       (null, \'MySQL\'),\\n       (null, \'Hadoop\');\\n\\ncreate table student_course\\n(\\n    id        int auto_increment comment \'主键\' primary key,\\n    studentid int not null comment \'学生ID\',\\n    courseid  int not null comment \'课程ID\',\\n    constraint fk_courseid foreign key (courseid) references course (id),\\n    constraint fk_studentid foreign key (studentid) references student (id)\\n) comment \'学生课程中间表\';\\ninsert into student_course\\nvalues (null, 1, 1),\\n       (null, 1, 2),\\n       (null, 1, 3),\\n       (null, 2, 2),\\n       (null, 2, 3),\\n       (null, 3, 4);\\n```\\n\\n#### 4.1.3 一对一\\n\\n- 案例：用户与用户详情的关系\\n- 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\\n- 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\\n\\n![image-20220525214650949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252146016.png)\\n\\n对应的SQL脚本：\\n\\n``` sql\\ncreate table if not exists tb_user\\n(\\n    id     int auto_increment primary key comment \'主键ID\',\\n    name   varchar(10) comment \'姓名\',\\n    age    int comment \'年龄\',\\n    gender char(1) comment \'1: 男 , 2: 女\',\\n    phone  char(11) comment \'手机号\'\\n) comment \'用户基本信息表\';\\ncreate table if not exists tb_user_edu\\n(\\n    id            int auto_increment primary key comment \'主键ID\',\\n    degree        varchar(20) comment \'学历\',\\n    major         varchar(50) comment \'专业\',\\n    primaryschool varchar(50) comment \'小学\',\\n    middleschool  varchar(50) comment \'中学\',\\n\\n    university    varchar(50) comment \'大学\',\\n    userid        int unique comment \'用户ID\',\\n    constraint fk_userid foreign key (userid) references tb_user (id)\\n) comment \'用户教育信息表\';\\ninsert into tb_user(id, name, age, gender, phone)\\nvalues (null, \'黄渤\', 45, \'1\', \'18800001111\'),\\n       (null, \'冰冰\', 35, \'2\', \'18800002222\'),\\n       (null, \'码云\', 55, \'1\', \'18800008888\'),\\n       (null, \'李彦宏\', 50, \'1\', \'18800009999\');\\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,\\n                        university, userid)\\nvalues (null, \'本科\', \'舞蹈\', \'静安区第一小学\', \'静安区第一中学\', \'北京舞蹈学院\', 1),\\n       (null, \'硕士\', \'表演\', \'朝阳区第一小学\', \'朝阳区第一中学\', \'北京电影学院\', 2),\\n       (null, \'本科\', \'英语\', \'杭州市第一小学\', \'杭州市第一中学\', \'杭州师范大学\', 3),\\n       (null, \'本科\', \'应用数学\', \'阳泉第一小学\', \'阳泉区第一中学\', \'清华大学\', 4);\\n```\\n\\n### 4.2 多表查询概述\\n\\n#### 4.2.1 数据准备\\n\\n1）. 删除之前emp，dept表的测试数据\\n\\n2）. 执行如下脚本，创建emp表与dept表并插入测试数据\\n\\n``` sql\\n-- 创建dept表，并插入数据\\ndrop table if exists dept;\\ncreate table dept\\n(\\n    id   int auto_increment comment \'ID\' primary key,\\n    name varchar(50) not null comment \'部门名称\'\\n) comment \'部门表\';\\nINSERT INTO dept (id, name)\\nVALUES (1, \'研发部\'),\\n       (2, \'市场部\'),\\n       (3, \'财务部\'),\\n       (4,\\n        \'销售部\'),\\n       (5, \'总经办\'),\\n       (6, \'人事部\');\\n-- 创建emp表，并插入数据\\ndrop table if exists emp;\\ncreate table emp\\n(\\n    id        int auto_increment comment \'ID\' primary key,\\n    name      varchar(50) not null comment \'姓名\',\\n    age       int comment \'年龄\',\\n    job       varchar(20) comment \'职位\',\\n    salary    int comment \'薪资\',\\n    entrydate date comment \'入职时间\',\\n    managerid int comment \'直属领导ID\',\\n    dept_id   int comment \'部门ID\'\\n) comment \'员工表\';\\n-- 添加外键\\nalter table emp\\n    add constraint fk_emp_dept_id foreign key (dept_id) references\\n        dept (id);\\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\\n       (2, \'张无忌\', 20, \'项目经理\', 12500, \'2005-12-05\', 1, 1),\\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1),\\n       (7, \'灭绝\', 60, \'财务总监\', 8500, \'2002-09-12\', 1, 3),\\n       (8, \'周芷若\', 19, \'会计\', 48000, \'2006-06-02\', 7, 3),\\n       (9, \'丁敏君\', 23, \'出纳\', 5250, \'2009-05-13\', 7, 3),\\n       (10, \'赵敏\', 20, \'市场部总监\', 12500, \'2004-10-12\', 1, 2),\\n       (11, \'鹿杖客\', 56, \'职员\', 3750, \'2006-10-03\', 10, 2),\\n       (12, \'鹤笔翁\', 19, \'职员\', 3750, \'2007-05-09\', 10, 2),\\n       (13, \'方东白\', 19, \'职员\', 5500, \'2009-02-12\', 10, 2),\\n       (14, \'张三丰\', 88, \'销售总监\', 14000, \'2004-10-12\', 1, 4),\\n       (15, \'俞莲舟\', 38, \'销售\', 4600, \'2004-10-12\', 14, 4),\\n       (16, \'宋远桥\', 40, \'销售\', 4600, \'2004-10-12\', 14, 4),\\n       (17, \'陈友谅\', 42, null, 2000, \'2011-10-12\', 1, null);\\n```\\n\\ndept表共6条记录，emp表共17条记录。\\n\\n#### 4.2.2 概述\\n\\n多表查询就是指从多张表中查询数据。\\n\\n原来查询单表数据，执行的SQL形式为：select * from emp; \\n\\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，\\n\\n如： `select * from emp , dept` ; 具体的执行结果如下:\\n\\n![image-20220526085113395](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260851744.png)\\n\\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。\\n\\n**笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。**\\n\\n![image-20220526085212058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260853700.png)\\n\\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\\n\\n![image-20220526085430499](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260854637.png)\\n\\n![image-20220526085521044](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260855198.png)\\n\\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\\n\\n``` sql\\nselect *\\nfrom icatw.emp,\\n     icatw.dept\\nwhere emp.dept_id = dept.id;\\n```\\n\\n![image-20220526085719946](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260857204.png)\\n\\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。\\n\\n#### 4.2.3 分类\\n\\n- 连接查询\\n  - 内连接：相当于查询A、B交集部分数据 \\n  - 外连接： \\n  - 左外连接：查询左表所有数据，以及两张表交集部分数据 \\n  - 右外连接：查询右表所有数据，以及两张表交集部分数据 \\n  - 自连接：当前表与自身的连接查询，自连接必须使用表别名\\n- 子查询\\n\\n![image-20220526090006541](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900675.png)\\n\\n### 4.3 内连接\\n\\n![image-20220526090056077](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900217.png)\\n\\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构\\n\\n1）. 隐式内连接\\n\\n``` sql\\nselect 字段列表 from 表1 , 表2 where 条件...;\\n```\\n\\n2）. 显式内连接\\n\\n``` sql\\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;\\n```\\n\\n案例：\\n\\nA. 查询每一个员工的姓名，及关联的部门的名称（隐式内连接）\\n\\n表结构：emp , dept\\n\\n连接条件：emp.dept_id = dept.id\\n\\n``` sql\\nselect emp.name, dept.name\\nfrom emp,\\n     dept\\nwhere emp.dept_id = dept.id;\\n\\n-- 为每一张表起别名,简化SQL编写\\nselect e.name, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n![image-20220526091506843](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260915000.png)\\n\\nB. 查询每一个员工的姓名，及关联的部门的名称（显示内连接实现）\\n\\n--- INNER JOIN ... ON ...\\n\\n表结构：emp，dept\\n\\n连接条件：emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, d.name\\nfrom emp e\\n         inner join dept d on e.dept_id = d.id;\\n         \\n-- 为每一张表起别名,简化SQL编写\\nselect e.name, d.name\\nfrom emp e\\n         join dept d on e.dept_id = d.id;\\n```\\n\\n> 表的别名：\\n>\\n> - tablea as 别名1 ,  tableb as 别名2 ;\\n> -  tablea 别名1 , tableb 别名2 ;\\n>\\n> 注意事项：\\n>\\n> ​\\t\\t一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\\n\\n### 4.4 外连接\\n\\n![image-20220526105436328](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261054413.png)\\n\\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\\n\\n1）. 左外连接\\n\\n``` sql\\nselect 字段列表 from 表1 left [outer] join 表2 on 条件 ...;\\n```\\n\\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\\n\\n2）. 右外连接\\n\\n``` sql\\nselect 字段列表 from 表1 right [outer] join 表2 on 条件...;\\n```\\n\\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\\n\\n案例: \\n\\nA. 查询emp表的所有数据, 和对应的部门信息 \\n\\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。 \\n\\n表结构: emp, dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.*, d.name\\nfrom icatw.emp e\\n         left join icatw.dept d on e.dept_id = d.id;\\n\\nselect e.*, d.name\\nfrom emp e\\n         left outer join dept d on e.dept_id = d.id;\\n```\\n\\nB. 查询dept表的所有数据, 和对应的员工信息(右外连接)\\n\\n由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 \\n\\n表结构: emp, dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;\\n\\nselect d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;\\n```\\n\\n> 注意事项：\\n>\\n> ​\\t\\t左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\\n\\n### 4.5 自连接\\n\\n#### 4.5.1 自连接查询\\n\\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。下面是自连接 的查询语法：\\n\\n``` sql\\nselect 字段列表 from 表A 别名A join 表A 别名B on 条件...;\\n```\\n\\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\\n\\n案例：\\n\\nA. 查询员工 及其 所属领导的名字 \\n\\n表结构: emp\\n\\n``` SQL\\n# A. 查询员工 及其 所属领导的名字\\nselect a.name \'领导名\', b.name \'员工名\'\\nfrom emp a\\n         join emp b on a.id = b.managerid;\\n```\\n\\nB. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 \\n\\n表结构: emp a , emp b\\n\\n``` SQL\\nselect a.name \'员工\', b.name \'领导\'\\nfrom emp a\\n         left join emp b on a.managerid =\\n                            b.id;\\n```\\n\\n> 注意事项: \\n>\\n> ​\\t\\t在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底 是哪一张表的字段。\\n\\n#### 4.5.2 联合查询\\n\\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\\n\\n``` sql\\nSELECT 字段列表 FROM 表A ...\\nUNION [ ALL ]\\nSELECT 字段列表 FROM 表B ....;\\n```\\n\\n- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 \\n- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\\n\\n案例: \\n\\nA. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. \\n\\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们 也可以通过union/union all来联合查询.\\n\\nunion all: 会有重复值\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary < 5000\\nunion all\\nselect *\\nfrom emp\\nwhere age > 50;\\n```\\n\\n相当于\\n\\n``` sql\\nselect * from emp where salary < 5000 or age > 50;\\n```\\n\\n![image-20220526112549321](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261125429.png)\\n\\nunion 联合查询，会对查询出来的结果进行去重处理\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary < 5000\\nunion\\nselect *\\nfrom emp\\nwhere age > 50;\\n```\\n\\n相当于\\n\\n``` sql\\nselect distinct *\\nfrom emp\\nwhere salary < 5000\\n   or age > 50;\\n```\\n\\n> 注意： \\n>\\n> ​\\t\\t如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报 错。如：\\n\\n![image-20220526112722744](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261127805.png)\\n\\n### 4.6 子查询\\n\\n#### 4.6.1 概述\\n\\n1）. 概念\\n\\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\\n\\n``` sql\\nselect * from t1 where column1=(select column1 from t2); \\n```\\n\\n子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。\\n\\n2）. 分类\\n\\n根据子查询结果不同，分为： \\n\\nA. 标量子查询（子查询结果为单个值） \\n\\nB. 列子查询(子查询结果为一列) \\n\\nC. 行子查询(子查询结果为一行) \\n\\nD. 表子查询(子查询结果为多行多列)\\n\\n\\n\\n根据子查询位置，分为： \\n\\nA. WHERE之后 \\n\\nB. FROM之后 \\n\\nC. SELECT之后\\n\\n#### 4.6.2 标量子查询\\n\\n子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= <> > >= < <=\\n\\n案例：\\n\\nA. 查询 \\\"销售部\\\" 的所有员工信息 \\n\\n完成这个需求时，我们可以将需求分解为两步： \\n\\n①. 查询 \\\"销售部\\\" 部门ID\\n\\n``` sql\\nselect id\\n                 from dept\\n                 where name = \'销售部\';\\n```\\n\\n②. 根据 \\\"销售部\\\" 部门ID, 查询员工信息\\n\\n``` sql\\n# 查询 \\\"销售部\\\" 的所有员工信息\\nselect *\\nfrom emp\\nwhere dept_id = (select id\\n                 from dept\\n                 where name = \'销售部\');\\n```\\n\\n内连接：\\n\\n``` sql\\nselect e.*\\nfrom emp e\\n         join dept d on e.dept_id = d.id and d.name = \'销售部\';\\n```\\n\\nB. 查询在 \\\"方东白\\\" 入职之后的员工信息 \\n\\n完成这个需求时，我们可以将需求分解为两步： \\n\\n①. 查询 方东白 的入职日期\\n\\n``` sql\\n# 查询在 \\\"方东白\\\" 入职之后的员工信息\\nselect entrydate\\nfrom emp\\nwhere name = \'方东白\';\\n```\\n\\n②. 查询指定入职日期之后入职的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere entrydate > (select entrydate\\n                   from emp\\n                   where name = \'方东白\');\\n```\\n\\n#### 4.6.3 列子查询\\n\\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 \\n\\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\\n\\n| 操作符 | 描述                                   |\\n| ------ | -------------------------------------- |\\n| IN     | 在指定的集合范围之内，多选一           |\\n| NOT IN | 不在指定的集合范围之内                 |\\n| ANY    | 子查询返回列表中，有任意一个满足即可   |\\n| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |\\n| ALL    | 子查询返回列表的所有值都必须满足       |\\n\\n案例：\\n\\nA. 查询 \\\"销售部\\\" 和 \\\"市场部\\\" 的所有员工信息\\n\\n分解为以下两步: \\n\\n①. 查询 \\\"销售部\\\" 和 \\\"市场部\\\" 的部门ID\\n\\n``` sql\\nselect id\\nfrom dept\\nwhere name = \'销售部\'\\n   or name = \'市场部\';\\n```\\n\\n②. 根据部门ID, 查询员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere dept_id in (select id\\n                  from dept\\n                  where name = \'销售部\'\\n                     or name = \'市场部\');\\n```\\n\\nB. 查询比 财务部 所有人工资都高的员工信息\\n\\n分解为以下两步: \\n\\n①. 查询所有 财务部 人员工资\\n\\n``` sql\\nselect id from dept where name = \'财务部\';\\nselect salary from emp where dept_id = (select id from dept where name = \'财务部\');\\n```\\n\\n②. 比 财务部 所有人工资都高的员工信息\\n\\n``` sql\\nselect * from emp where salary > all ( select salary from emp where dept_id =\\n(select id from dept where name = \'财务部\') );\\n```\\n\\nC. 查询比研发部其中任意一人工资高的员工信息\\n\\n分解为以下两步: \\n\\n①. 查询研发部所有人工资\\n\\n``` sql\\nselect salary\\nfrom emp\\nwhere dept_id = (select id from dept where name = \'研发部\');\\n```\\n\\n②. 比研发部其中任意一人工资高的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > any (select salary\\n                    from emp\\n                    where dept_id = (select id from dept where name = \'研发部\'));\\n```\\n\\n#### 4.6.4 行子查询\\n\\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：= 、<> 、IN 、NOT IN\\n\\n案例: \\n\\nA. 查询与 \\\"张无忌\\\" 的薪资及直属领导相同的员工信息 ; \\n\\n这个需求同样可以拆解为两步进行:\\n\\n①. 查询 \\\"张无忌\\\" 的薪资及直属领导\\n\\n```sql\\nselect salary, managerid\\nfrom emp\\nwhere name = \'张无忌\';\\n```\\n\\n②. 查询与 \\\"张无忌\\\" 的薪资及直属领导相同的员工信息 ;\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere (salary, managerid) = (select salary, managerid\\n                             from emp\\n                             where name = \'张无忌\');\\n```\\n\\n#### 4.6.5 表子查询\\n\\n子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN\\n\\n案例: \\n\\nA. 查询与 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资相同的员工信息 \\n\\n分解为两步执行:\\n\\n①. 查询 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资\\n\\n``` sql\\nselect job, salary\\nfrom emp\\nwhere name = \'鹿杖客\'\\n   or name = \'宋远桥\';\\n```\\n\\n②. 查询与 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资相同的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere (job, salary) in (select job, salary\\n                        from emp\\n                        where name = \'鹿杖客\'\\n                           or name = \'宋远桥\');\\n```\\n\\nB. 查询入职日期是 \\\"2006-01-01\\\" 之后的员工信息 , 及其部门信息\\n\\n分解为两步执行: \\n\\n①. 入职日期是 \\\"2006-01-01\\\" 之后的员工信息\\n\\n``` sql\\nselect *\\nfrom emp where entrydate>\'2006-01-01\';\\n```\\n\\n②. 查询这部分员工, 对应的部门信息;\\n\\n```sql\\n-- 先查询出入职日期是 \\\"2006-01-01\\\" 之后的员工信息，再将其作为新表与部门表进行左外连接查询\\nselect *\\nfrom (select *\\n      from emp\\n      where entrydate > \'2006-01-01\') e\\n         left join dept d\\n                   on e.dept_id = d.id;\\n```\\n\\n### 4.7 多表查询案例\\n\\n数据环境准备：\\n\\n``` sql\\ncreate table salgrade\\n(\\n    grade int,\\n    losal int,\\n    hisal int\\n) comment \'薪资等级表\';\\ninsert into salgrade\\nvalues (1, 0, 3000),\\n       (2, 3001, 5000),\\n       (3, 5001, 8000),\\n       (4, 8001, 10000),\\n       (5, 10001, 15000),\\n       (6, 15001, 20000),\\n       (7, 20001, 25000),\\n       (8, 25001, 30000);\\n```\\n\\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉 及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\\n\\n1）. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\\n\\n表: emp , dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, e.age, e.job, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n2）. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接） \\n\\n表: emp , dept\\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, e.age, e.job, d.name\\nfrom emp e\\n         inner join dept d on e.dept_id = d.id and e.age < 30;\\n```\\n\\n3）. 查询拥有员工的部门ID、部门名称\\n\\n表：emp，dept\\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect distinct d.id, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n4）. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出 来(外连接) \\n\\n表: emp , dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.*, d.name\\nfrom emp e\\n         left join dept d on d.id = e.dept_id and e.age > 40;\\n```\\n\\n5）. 查询所有员工的工资等级 \\n\\n表: emp , salgrade \\n\\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\\n\\n``` sql\\nselect e.*, s.grade \'员工等级\'\\nfrom emp e,\\n     salgrade s\\nwhere e.salary between s.losal and s.hisal;\\n```\\n\\n6）. 查询 \\\"研发部\\\" 所有员工的信息及 工资等级 \\n\\n表: emp , salgrade , dept \\n\\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id \\n\\n查询条件 : dept.name = \'研发部\'\\n\\n``` sql\\nselect e.*, d.name, s.grade\\nfrom emp e,\\n     dept d,\\n     salgrade s\\nwhere d.name = \'研发部\'\\n  and e.dept_id = d.id\\n  and e.salary between s.losal and s.hisal;\\n```\\n\\n7）. 查询 \\\"研发部\\\" 员工的平均工资 \\n\\n表: emp , dept \\n\\n连接条件 : emp.dept_id = dept.id\\n\\n``` sql\\nselect avg(e.salary)\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id\\n  and d.name = \'研发部\';\\n```\\n\\n8）. 查询工资比 \\\"灭绝\\\" 高的员工信息。 \\n\\n①. 查询 \\\"灭绝\\\" 的薪资\\n\\n``` sql\\nselect salary\\nfrom emp\\nwhere emp.name = \'灭绝\';\\n```\\n\\n②. 查询比她工资高的员工数据\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > (select salary\\n                from emp\\n                where emp.name = \'灭绝\');\\n```\\n\\n9）.  查询比平均薪资高的员工信息 \\n\\n①. 查询员工的平均薪资\\n\\n``` sql\\nselect avg(salary)\\nfrom emp;\\n```\\n\\n②. 查询比平均薪资高的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > (select avg(salary)\\n                from emp);\\n```\\n\\n10）.  查询低于本部门平均工资的员工信息 \\n\\n①. 查询指定部门平均薪资\\n\\n``` sql\\nselect avg(e1.salary) from emp e1 where e1.dept_id = 1;\\nselect avg(e1.salary) from emp e1 where e1.dept_id = 2;\\n```\\n\\n②. 查询低于本部门平均工资的员工信息\\n\\n``` sql\\nselect *\\nfrom emp e2\\nwhere e2.salary < (select avg(e1.salary)\\n                   from emp e1\\n                   where e1.dept_id = e2.dept_id);\\n```\\n\\n11）. 查询所有的部门信息, 并统计部门的员工人数\\n\\n``` sql\\nselect d.id, d.name, (select count(*) from emp e where e.dept_id = d.id) \'人数\'\\nfrom dept d;\\n```\\n\\n12）. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\\n\\n表: student , course , student_course \\n\\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\\n\\n``` sql\\nselect s.name, s.no, c.name\\nfrom student s,\\n     student_course sc,\\n     course c\\nwhere s.id = sc.studentid\\n  and sc.courseid = c.id;\\n```\\n\\n**备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条 件的记录即可。**\\n\\n## 5. 事务\\n\\n### 5.1 事务介绍\\n\\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 \\n\\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\\n\\n![image-20220526211221401](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112624.png)\\n\\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :\\n\\n![image-20220526211238606](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112698.png)\\n\\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\\n\\n![image-20220526211300656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113735.png)\\n\\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\\n\\n![image-20220526211317578](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113661.png)\\n\\n> **注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。**\\n\\n### 5.2 事务操作\\n\\n数据准备：\\n\\n``` sql\\ndrop table if exists account;\\ncreate table account\\n(\\n    id    int primary key AUTO_INCREMENT comment \'ID\',\\n    name  varchar(10) comment \'姓名\',\\n    money double(10, 2) comment \'余额\'\\n) comment \'账户表\';\\ninsert into account(name, money)\\nVALUES (\'张三\', 2000),\\n       (\'李四\', 2000);\\n```\\n\\n#### 5.2.1 未控制事务\\n\\n1). 测试正常情况\\n\\n``` sql\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n```\\n\\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\\n\\n![image-20220526211732232](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262117323.png)\\n\\n2). 测试异常情况\\n\\n``` sql\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n出错了....\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n```\\n\\n我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。\\n\\n![image-20220526211831649](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262118725.png)\\n\\n#### 5.2.2 控制事务一\\n\\n1）. 查看/设置事务提交方式\\n\\n``` sql\\nSELECT @@autocommit ;\\nSET @@autocommit = 0 ;\\n```\\n\\n2）. 提交事务\\n\\n``` sql\\ncommit;\\n```\\n\\n3）. 回滚事务\\n\\n``` sql\\nrollback;\\n```\\n\\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\\n\\n#### 5.2.3 控制事务二\\n\\n1）. 开启事务\\n\\n``` sql\\nSTART TRANSACTION 或 BEGIN ;\\n```\\n\\n2）. 提交事务\\n\\n``` sql\\ncommit;\\n```\\n\\n3）. 回滚事务\\n\\n``` sql\\nROLLBACK;\\n```\\n\\n转账案例：\\n\\n``` sql\\n-- 开启事务\\nstart transaction\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n-- 如果正常执行完毕, 则提交事务\\ncommit;\\n-- 如果执行过程中报错, 则回滚事务\\n-- rollback;\\n```\\n\\n### 5.3  事务四大特性（ACID）\\n\\n- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 \\n- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 \\n- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。\\n- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\\n\\n上述就是事务的四大特性，简称ACID。\\n\\n![image-20220526215911714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262159820.png)\\n\\n### 5.4 并发事务问题\\n\\n1）. 脏读：一个事务读到另外一个事务还没有提交的数据。\\n\\n![image-20220526220426943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204036.png)\\n\\n2）. 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\\n\\n![image-20220526220450359](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204455.png)\\n\\n3）. 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 \\\"幻影\\\"。\\n\\n![image-20220526220605668](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262206753.png)\\n\\n### 5.5 事务隔离级别\\n\\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\\n\\n| 隔离级别                          | 脏读 | 不可重复读取 | 幻读 |\\n| --------------------------------- | ---- | ------------ | ---- |\\n| Read uncommitted（读未提交）      | √    | √            | √    |\\n| Read committed（读已提交）        | ×    | √            | √    |\\n| Repeatable Read(默认)（可重复读） | ×    | ×            | √    |\\n| Serializable（串行化）            | ×    | ×            | ×    |\\n\\n1）. 查看事务隔离级别\\n\\n``` SQL\\nSELECT @@TRANSACTION_ISOLATION;\\n```\\n\\n2）. 设置事务隔离级别\\n\\n``` sql\\nSET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |\\nREAD COMMITTED | REPEATABLE READ | SERIALIZABLE }\\n```\\n\\n> **注意：事务隔离级别越高，数据越安全，但是性能越低。**\",\"articleCover\":\"\",\"articleTitle\":\"MySQL学习【基础篇】\",\"isTop\":0,\"originalUrl\":\"\",\"status\":3,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-26 22:38:54',NULL),(1200,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# MySQL学习基础篇\\n\\n## 1. SQL\\n\\n**全称 Structured Query Language，结构化查询语言**。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。\\n\\n### 1.1 SQL通用语法\\n\\n- SQL语句可以单行或者多行书写，以分号结尾。\\n- SQL语句可以使用空格/缩进来增强语句的可读性。\\n- MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\\n- 注释\\n    - 单行注释：-- 注释内容 或 # 注释内容\\n    - 多行注释： /* 注释内容 */\\n\\n### 1.2 SQL分类\\n\\nSQL语句，根据其功能，主要分为四类：**DDL、DML、DQL、DCL**。\\n\\n| 分类 | 全称                        | 说明                                                    |\\n| ---- | --------------------------- | :------------------------------------------------------ |\\n| DDL  | Data Definition Language    | 数据定义语言，用来定义数据库对象(数据库，表， 字段)     |\\n| DML  | Data Manipuulation Language | 数据操作语言，用来对数据库表中的数据进行增删改          |\\n| DQL  | Data Query Language         | 数据查询语言，用来查询数据库中表的记录                  |\\n| DCL  | Data Control Language       | 数据控制语言，用来创建数据库用户、控制数据库的 访问权限 |\\n\\n### 1.3 DDL\\n\\n> **Data Definition Language，数据定义语言，用来定义数据库对象（数据库、表、字段）**\\n\\n#### 1.3.1 数据库操作\\n\\n这里我们直接使用可视化数据库工具Navicat演示命令\\n\\n- 查询所有数据库\\n\\n``` sql\\nshow databases;\\n```\\n\\n![image-20220523234102071](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232341162.png)\\n\\n- 查询当前数据库\\n\\n``` sql\\nselect database()\\n```\\n\\n- 创建数据库\\n\\n``` sql\\ncreate database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;\\n```\\n\\n>  注：[ ] 中的值为可选项，default代表有默认值\\n\\n案例：\\n\\nA. 创建一个icatw数据库，使用数据库默认的字符集。\\n\\n``` sql\\nCREATE DATABASE icatw;\\n```\\n\\n![image-20220523234756349](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232347399.png)\\n\\n在同一个数据库服务器中，数据库名不可重复，必须唯一，否则将会报错。\\n\\n![image-20220523234950307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232349389.png)\\n\\n可以通过 `` if not exists``（如果不存在）参数来解决这个问题，只有是当数据库名不存在时，才会进行创建。\\n\\n``` sql\\nCREATE DATABASE IF NOT EXISTS icatw;\\n```\\n\\n![image-20220523235235940](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205232352985.png)\\n\\nB.创建一个icat数据库，并且指定字符集\\n\\n``` sql\\n-- 创建icat数据库并指定utf8mb4为默认数据库\\nCREATE DATABASE icat DEFAULT CHARSET utf8mb4;\\n```\\n\\nutf8mb4比utf8支持更多字符，\\n\\n**utf8mb4支持最大4个字节的字符，而utf8最大只支持3个字节的字符，现在一般都使用utf8mb4作为mysql默认字符集**\\n\\n- 删除数据库\\n\\n``` sql\\n-- 删除数据库icat(如果存在)\\nDROP DATABASE IF EXISTS icat;\\n```\\n\\n如果不加上 if exists 的话，数据库不存在则会报错;\\n\\n- 切换数据库\\n\\n``` sql\\nUSE icatw;\\n```\\n\\n当我们需要操作某个数据库下的表时必须先切换到对应数据库\\n\\n#### 1.3.2 表操作\\n\\n对表的操作需要先使用`USE 数据库表`切换到对应数据库\\n\\n##### 1.3.2.1 表操作-查询创建\\n\\n1）. 查询当前数据库所有表\\n\\n查询表需要先使用 `USE 数据库名`切换数据库\\n\\n例:\\n\\n``` sql\\n-- 查询当前数据库下的所有表\\nUSE sys;\\nSHOW TABLES;\\n```\\n\\n![image-20220524084459677](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240845244.png)\\n\\n2）. 查看指定表结构\\n\\n``` sql\\ndesc 表名\\n```\\n\\n3）. 查询指定表的建表语句\\n\\n``` sql\\n-- 查询指定表的建表语句\\nSHOW CREATE TABLE sys_config;\\n```\\n\\n![image-20220524085039027](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240850135.png)\\n\\n通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\\n\\n4）. 创建表结构\\n\\n``` sql\\nCREATE TABLE 表名(\\n字段1 字段1类型 [ COMMENT 字段1注释 ],\\n字段2 字段2类型 [COMMENT 字段2注释 ],\\n字段3 字段3类型 [COMMENT 字段3注释 ],\\n......\\n字段n 字段n类型 [COMMENT 字段n注释 ]\\n) [ COMMENT 表注释 ] ;\\n\\n```\\n\\n例: 创建一张表tb_user，对应的结构如下\\n\\n|  id  |   name   | age  | gender |\\n| :--: | :------: | :--: | :----: |\\n|  1   |  令狐冲  |  28  |   男   |\\n|  2   |  风清扬  |  32  |   男   |\\n|  3   | 东方不败 |  34  |   男   |\\n\\n那么建表语句为：\\n\\n``` sql\\n-- 创建表结构\\nUSE icatw;\\nCREATE TABLE tb_user(\\nid INT COMMENT 主键id,\\nname VARCHAR(50) COMMENT 名字,\\nage INT COMMENT 年龄,\\ngender VARCHAR(1) 性别\\n)COMMENT 用户表 ;\\n```\\n\\n##### 1.3.2.2 表操作-数据类型\\n\\nMySQL中的数据类型有很多，主要分为三类：**数值类型、字符串类型、日期时间类型**\\n\\n1）. 数值类型\\n\\n| 类型        | 大小   | 有符号(SIGNED)范围                                     | 无符号(UNSIGNED)范围                                       | 描述                  |\\n| ----------- | ------ | ------------------------------------------------------ | ---------------------------------------------------------- | --------------------- |\\n| TINYINT     | 1byte  | (-128，127)                                            | (0，255)                                                   | 小整 数值             |\\n| SMALLINT    | 2bytes | (-32768，32767)                                        | (0，65535)                                                 | 大整 数值             |\\n| MEDIUMINT   | 3bytes | (-8388608，8388607)                                    | (0，16777215)                                              | 大整 数值             |\\n| INT/INTEGER | 4bytes | (-2147483648， 2147483647)                             | (0，4294967295)                                            | 大整 数值             |\\n| BIGINT      | 8bytes | (-2^63，2^63-1)                                        | (0，2^64-1)                                                | 极大 整数 值          |\\n| FLOAT       | 4bytes | (-3.402823466 E+38， 3.402823466351 E+38)              | 0 和 (1.175494351 E38，3.402823466 E+38)                   | 单精 度浮 点数 值     |\\n| DOUBLE      | 8bytes | (-1.7976931348623157 E+308， 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308) | 双精 度浮 点数 值     |\\n| DECIMAL     |        | 依赖于M(精度)和D(标度) 的值                            | 依赖于M(精度)和D(标度)的 值                                | 小数 值(精 确定 点数) |\\n\\n``` tex\\n如:\\n1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大\\nage tinyint unsigned\\n2). 分数 -- 总分100分, 最多出现一位小数\\nscore double(4,1)\\n通常使用DECIMAL 存储货币、钱\\n```\\n\\n2）. 字符串类型\\n\\n|    类型  |   大小   | 描述 |\\n| ---- | ---- | ---- |\\n| CHAR | 0-255 bytes | 定长字符串(需要指定长度) |\\n| VARCHAR | 0-65535 bytes | 变长字符串(需要指定长度) |\\n| TINYBLOB | 0-255 bytes | 不超过255个字符的二进制数据 |\\n| TINYTEXT | 0-255 bytes | 短文本字符串 |\\n| BLOB | 0-65535 bytes | 二进制形式的长文本数据 |\\n| TEXT | 0-65535 bytes | 长文本数据 |\\n| MEDIUMBLOB | 0-16777215 bytes | 二进制形式的中等长度文本数据 |\\n| MEDIUMTEXT | 0-16777215 bytes | 中等长度文本数据 |\\n| LONGBLOB | 0-4 294 967 295 bytes | 二进制形式的极大文本数据 |\\n| LONGTEXT | 0-4 294 967 295 bytes | 极大文本数据 |\\n\\nchar 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。\\n\\n``` tex\\n如：\\n1). 用户名 username ------> 长度不定, 最长不会超过50\\nusername varchar(50)\\n2). 性别 gender ---------> 存储值, 不是男,就是女\\ngender char(1)\\n3). 手机号 phone --------> 固定长度为11\\nphone char(11)\\n\\n```\\n\\n3） . 日期时间类型\\n\\n| 类型      | 大 小 | 范围                                       | 格式                | 描述                      |\\n| --------- | ----- | ------------------------------------------ | ------------------- | ------------------------- |\\n| DATE      | 3     | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                    |\\n| TIME      | 3     | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续 时间         |\\n| YEAR      | 1     | 1901 至 2155                               | YYYY                | 年份值                    |\\n| DATETIME  | 8     | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值         |\\n| TIMESTAMP | 4     | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时 间值，时间戳 |\\n\\n``` tex\\n如:\\n    1). 生日字段 birthday\\n    birthday date\\n    2). 创建时间 createtime\\n    createtime datetime\\n```\\n\\n##### 1.3.2.3 表操作-案例\\n\\n> 设计一张员工信息表，要求如下：\\n>\\n> 1. 编号（纯数字）\\n> 2. 员工工号 (字符串类型，长度不超过10位)\\n> 3. 员工姓名（字符串类型，长度不超过10位） \\n> 4. 性别（男/女，存储一个汉字） \\n> 5. 年龄（正常人年龄，不可能存储负数） \\n> 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符） \\n> 7. 入职时间（取值年月日即可）\\n\\n对应的建表语句如下：\\n\\n``` sql\\ncreate table emp(\\n    id int comment \'编号\',\\n    workno varchar(10) comment \'工号\',\\n    name varchar(10) comment \'姓名\',\\n    gender char(1) comment \'性别\',\\n    age tinyint unsigned comment \'年龄\',\\n    idcard char(18) comment \'身份证号\',\\n    entrydate date comment \'入职时间\'\\n) comment \'员工表\';\\n```\\n\\n建表之后可通过 `desc emp`查看员工表结构\\n\\n![image-20220524093825055](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205240938173.png)\\n\\n至此，员工表就已经创建好了，当我们指定了字段的最大长度之后，超出最大长度将会报错。\\n\\n##### 1.3.2.4 表操作-修改\\n\\n1）. 添加字段\\n\\n``` sql\\nALTER TABLE 表名 ADD 字段名 类型(长度) [comment 注释] [约束];\\n```\\n\\n案例:\\n\\n为emp表增加一个新的字段\\\"昵称\\\"为nickname，类型为varchar(20)\\n\\n``` sql\\n-- 添加字段\\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT \'昵称\';\\n```\\n\\n2）. 修改数据类型\\n\\n``` sql\\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)\\n```\\n\\n3）. 修改字段名和字段类型\\n\\n``` sql\\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];\\n```\\n\\n案例:\\n\\n将emp表的nickname字段修改为username,类型为varchar(30)\\n\\n``` sql\\n-- 将emp表的nickname字段修改为username,类型为varchar(30)\\nALTER TABLE emp CHANGE nickname username VARCHAR(30) COMMENT \'用户名\';\\n```\\n\\n4）. 删除字段\\n\\n``` sql\\nALTER TABLE 表名 DROP 字段名;\\n```\\n\\n``` sql\\n-- 删除emp表中的username\\nALTER TABLE emp DROP username;\\n```\\n\\n5）. 修改表名\\n\\n``` sql\\nALTER TABLE 表名 RENAME TO 新表名;\\n```\\n\\n案例:\\n\\n将emp表的表名修改为employee\\n\\n``` sql\\n-- 修改表名ALTER TABLE 表名 RENAME TO 新表名;\\nALTER  TABLE emp RENAME TO employee;\\n```\\n\\n**总结:**\\n\\n​\\t**对表的修改操作通用格式为**:` ALTER TABLE 表名 操作名(ADD,MODIFY,CHANGE,DROP,RENAME TO)`\\n\\n##### 1.3.2.5 表操作-删除\\n\\n1）. 删除表\\n\\n``` sql\\nDROP TABLE [IF EXISTS] 表名;\\n```\\n\\n可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。\\n\\n案例: \\n\\n如果tb_user表存在，则删除tb_user表\\n\\n``` sql\\nDROP TABLE IF EXISTS tb_user;\\n```\\n\\n2）. 删除指定表，并重新创建表\\n\\n``` sql\\nTRUNCATE TABLE 表名;\\n```\\n\\n> 我的理解是 相当于清空数据，新建的表结构并不会发生变化\\n\\n### 1.4 图形化界面工具\\n\\nidea、Navicat\\n\\n这里我们使用idea的自带的数据库操作工具学习\\n\\n### 1.5 DML\\n\\n>  **DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作**。\\n\\n- 添加数据（INSERT） \\n- 修改数据（UPDATE） \\n- 删除数据（DELETE）\\n\\n#### 1.5.1 添加数据\\n\\n1）. 给指定字段添加数据\\n\\n``` sql\\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\\n```\\n\\n案例：给employee表所有的字段添加数据 ；\\n\\n```sql\\n# 插入数据\\ninsert into employee (id, workno, name, gender, age, idcard, entrydate)\\nvalues (1,\'1\',\'icatw\',\'男\',18,\'431088200205180463\',\'2002-05-22\');\\n```\\n\\n插入数据完成之后有两种方式查询数据库的数据\\n\\nA. 方式一\\n\\n在表名上双击，就可以看到这张表的数据。\\n\\n![image-20220524124505124](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205241245329.png)\\n\\nB. 方式二\\n\\n直接使用查询的SQL语句\\n\\n``` sql\\nselect * from employee;\\n```\\n\\n2）. 给全部字段添加数据\\n\\n``` sql\\nINSERT INTO 表名 VALUES (值1, 值2, ...);\\n```\\n\\n案例：给employee表的所有字段添加数据\\n\\n``` sql\\n# 给所有字段添加数据\\ninsert into employee values (2, \'2\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'2005-01-01\');\\n```\\n\\n3）. 批量添加数据\\n\\n``` sql\\nINSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\\n```\\n\\n``` sql\\nINSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;\\n```\\n\\n案例：批量插入数据到employee表\\n\\n``` sql\\ninsert into employee values(3,\'3\',\'韦一笑\',\'男\',38,\'123456789012345670\',\'2005-01-01\'),(4,\'4\',\'赵敏\',\'女\',18,\'123456789012345670\',\'2005-01-01\');\\n\\n```\\n\\n> 注意事项：\\n>\\n> - 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\\n> - 字符串和日期型数据应该包含在引号中。\\n> - 插入的数据大小，应该在字段的规定范围内，不能超过最大值。\\n\\n#### 1.5.2 修改数据\\n\\n修改数据的具体语法为：\\n\\n```sql\\nUPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;\\n```\\n\\n**如果不指定where条件将修改所有行**\\n\\n案例：\\n\\nA. 修改id为1的数据，将那么修改为icatw2\\n\\n``` sql\\nupdate employee set name=\'icatw2\' where id=1;\\n```\\n\\nB. 修改id为1的数据，将name修改为小昭，gender修改为女\\n\\n``` sql\\nupdate employee set name=\'小昭\' ,gender=\'女\' where id=1;\\n```\\n\\nC. 将所有员工的入职日期修改为2008-01-01\\n\\n``` sql\\nupdate employee set entrydate=\'2008-01-01\'\\n```\\n\\n> 注意事项：\\n>\\n> ​\\t\\t**修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。**\\n\\n#### 1.5.3 删除数据\\n\\n语法：\\n\\n``` sql\\ndelete from 表名 [where 条件];\\n```\\n\\n案例：\\n\\nA. 删除gender为女的员工\\n\\n``` sql\\ndelete from employee where gender=\'女\';\\n```\\n\\nB. 删除所有员工\\n\\n``` sql\\ndelete from employee\\n```\\n\\n> 注意事项: \\n>\\n> - DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。\\n> - DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\\n> - 当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击 Execute即可。\\n\\n\\n\\n### 1.6 DDL\\n\\n> **DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。** \\n\\n查询关键字: **SELECT** \\n\\n在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站， 在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\\n\\n首先我们准备数据\\n\\n``` sql\\n# 添加数据\\ndrop table if exists employee;\\ncreate table emp\\n(\\n    id          int comment \'编号\',\\n    workno      varchar(10) comment \'工号\',\\n    name        varchar(10) comment \'姓名\',\\n    gender      char(1) comment \'性别\',\\n    age         tinyint unsigned comment \'年龄\',\\n    idcard      char(18) comment \'身份证号\',\\n    workaddress varchar(50) comment \'工作地址\',\\n    entrydate   date comment \'入职时间\'\\n) comment \'员工表\';\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (1, \'00001\', \'柳岩666\', \'女\', 20, \'123456789012345678\', \'北京\', \'2000-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (2, \'00002\', \'张无忌\', \'男\', 18, \'123456789012345670\', \'北京\', \'2005-09-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (3, \'00003\', \'韦一笑\', \'男\', 38, \'123456789712345670\', \'上海\', \'2005-08-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (4, \'00004\', \'赵敏\', \'女\', 18, \'123456757123845670\', \'北京\', \'2009-12-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (5, \'00005\', \'小昭\', \'女\', 16, \'123456769012345678\', \'上海\', \'2007-07-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (6, \'00006\', \'杨逍\', \'男\', 28, \'12345678931234567X\', \'北京\', \'2006-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (7, \'00007\', \'范瑶\', \'男\', 40, \'123456789212345670\', \'北京\', \'2005-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (8, \'00008\', \'黛绮丝\', \'女\', 38, \'123456157123645670\', \'天津\', \'2015-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (9, \'00009\', \'范凉凉\', \'女\', 45, \'123156789012345678\', \'北京\', \'2010-04-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (10, \'00010\', \'陈友谅\', \'男\', 53, \'123456789012345670\', \'上海\', \'2011-01-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (11, \'00011\', \'张士诚\', \'男\', 55, \'123567897123465670\', \'江苏\', \'2015-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (12, \'00012\', \'常遇春\', \'男\', 32, \'123446757152345670\', \'北京\', \'2004-02-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (13, \'00013\', \'张三丰\', \'男\', 88, \'123656789012345678\', \'江苏\', \'2020-11-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (14, \'00014\', \'灭绝\', \'女\', 65, \'123456719012345670\', \'西安\', \'2019-05-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (15, \'00015\', \'胡青牛\', \'男\', 70, \'12345674971234567X\', \'西安\', \'2018-04-01\');\\nINSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)\\nVALUES (16, \'00016\', \'周芷若\', \'女\', 18, null, \'北京\', \'2012-06-01\');\\n\\n```\\n\\n#### 1.6.1 基本语法\\n\\nDDL查询语句，语法结构如下：\\n\\n``` sql\\nSELECT\\n字段列表\\nFROM\\n表名列表\\nWHERE\\n条件列表\\nGROUP BY\\n分组字段列表\\nHAVING\\n分组后条件列表\\nORDER BY\\n排序字段列表\\nLIMIT\\n分页参数\\n\\n```\\n\\n大致可以拆分为以下几个部分：\\n\\n- 基本查询（不带任何条件） \\n- 条件查询（WHERE） \\n- 聚合函数（count、max、min、avg、sum） \\n- 分组查询（group by） \\n- 排序查询（order by） \\n- 分页查询（limit）\\n\\n#### 1.6.2基本查询\\n\\n在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：\\n\\n1）. 查询多个字段\\n\\n``` sql\\nselect 字段1,字段2,字段3 ... from 表名;\\n```\\n\\n``` sql\\nSELECT * FROM 表名 ;\\n```\\n\\n> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。\\n\\n2）. 字段设置别名\\n\\n``` sql\\nSELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;\\n```\\n\\n``` sql\\n# as 也可省略\\nSELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;\\n```\\n\\n3）. 去除重复记录\\n\\n``` sql\\nselect distinct 字段列表 from 表名;\\n```\\n\\n案例：\\n\\nA. 查询指定字段 name，workno，age并返回\\n\\n``` sql\\nselect name,workno,age from emp;\\n```\\n\\nB. 查询返回所有字段\\n\\n``` sql\\nselect id,workno,name,gender,age,idcard,workaddress,entrydate from emp;\\n```\\n\\n``` sql\\nselect * from emp;\\n```\\n\\nC. 查询所有员工的工作地址，起别名\\n\\n``` sql\\nselect workaddress as \'工作地址\' from emp;\\n```\\n\\n``` sql\\n-- as可以省略\\nselect workaddress \'工作地址\' from emp;\\n```\\n\\nD. 查询公司员工的上班地址有哪些（去重）\\n\\n``` sql\\nselect distinct workaddress \'工作地址\' from emp;\\n```\\n\\n#### 1.6.3 条件查询\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 where 条件列表;\\n```\\n\\n2）. 条件\\n\\n常用的比较运算符如下：\\n\\n| 比较运算符          | 功能                                     |\\n| ------------------- | ---------------------------------------- |\\n| >                   | 大于                                     |\\n| >=                  | 大于等于                                 |\\n| <                   | 小于                                     |\\n| <=                  | 小于等于                                 |\\n| =                   | 等于                                     |\\n| <> 或 !=            | 不等于                                   |\\n| BETWEEN ... AND ... | 在某个范围之内(含最小、最大值)           |\\n| IN(...)             | 在in之后的列表中的值，多选一             |\\n| LIKE 占位符         | 模糊匹配(_匹配单个字符, %匹配任意个字符) |\\n| IS NULL             | 是NULL                                   |\\n\\n常用的逻辑运算符如下：\\n\\n|逻辑运算符|功能|\\n|----|----|\\n|AND 或 &&|并且 (多个条件同时成立)|\\n|OR 或 \\\\|\\\\||或者 (多个条件任意一个成立)|\\n|NOT 或 !|非 , 不是|\\n\\n案例：\\n\\nA. 查询年龄等于88的员工\\n\\n``` sql\\nselect * from emp where age=88;\\n```\\n\\nB. 查询年龄小于20的员工信息\\n\\n``` sql\\nselect * from emp where age<20;\\n```\\n\\nC. 查询年龄小于等于20的员工信息\\n\\n``` sql\\nselect * from emp where age<=20;\\n```\\n\\nD. 查询没有身份证号的员工信息\\n\\n``` sql\\nselect * from emp where idcard is null;\\n```\\n\\nE. 查询有身份证号的员工信息\\n\\n``` sql\\nselect * from emp where idcard is not null;\\n```\\n\\nF. 查询年龄不等于88的员工信息\\n\\n``` sql\\nselect * from emp where age!=88;\\n```\\n\\n``` sql\\nselect * from emp where age<>88;\\n```\\n\\nG. 查询年龄在15岁（包含）到20岁（包含）之间的员工信息\\n\\n``` sql\\nselect * from emp where age >=15 and age <= 20;\\nselect * from emp where age>=15 && age <=20;\\nselect * from emp where age between 15 and 20;\\n```\\n\\nH. 查询性别为女 且年龄小于25的员工信息\\n\\n``` sql\\nselect * from emp where gender =\'女\' and age<25;\\n```\\n\\nI. 查询年龄等于18或20或40的员工信息\\n\\n``` sql\\nselect * from emp where age =18 or age =20 or age =40;\\nselect * from emp where age in(18,20,40)\\n```\\n\\nJ. 查询姓名为两个字的员工信息 _ %\\n\\n``` sql\\nselect * from emp where name like \'__\'\\n```\\n\\nK. 查询身份证号最后以为是x的员工信息\\n\\n``` sql\\nselect * from emp where idcard like \'%x\';\\nselect * from emp where idcard like \'_________________x\';\\n```\\n\\n#### 1.6.4 聚合函数\\n\\n1）. 介绍\\n\\n将一列数据作为一个整体，进行纵向计算。\\n\\n2）. 常见的聚合函数\\n\\n| 函数  | 功能     |\\n| ----- | -------- |\\n| count | 统计数量 |\\n| max   | 最大值   |\\n| min   | 最小值   |\\n| avg   | 平均值   |\\n| sum   | 求和     |\\n\\n3）. 语法\\n\\n``` sql\\nselect 聚合函数（字段列表） from 表名;\\n```\\n\\n> 注意：null值是不参与所有聚合函数运算的。\\n\\n案例：\\n\\nA. 统计该企业员工数量\\n\\n``` sql\\nselect count(*) from emp; -- 统计的是总记录数,也就是记录行数\\nselect count(idcard) from emp; -- 统计的是idcard字段不为null的记录数\\n```\\n\\n对于count聚合函数，统计符合条件的总记录数，还可以通过count（数字/字符串）的形式进行统计查询，比如：\\n\\n``` sql\\nselect count(1) from emp;\\n-- 效果等于 select count(*) from emp;\\n```\\n\\nB. 统计该企业员工的平均年龄\\n\\n``` sql\\nselect avg(age) from emp;\\n```\\n\\nC. 统计该企业员工的最大年龄\\n\\n``` sql\\nselect max(age) from emp;\\n```\\n\\nD. 统计该企业员工的最小年龄\\n\\n``` sql\\nselect min(age) from emp;\\n```\\n\\nE. 统计西安地区员工的年龄之和\\n\\n``` sql\\nselect sum(age) from emp where wordaddress=\'西安\';\\n```\\n\\n#### 1.6.5 分组查询\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\\n```\\n\\n2）. where与having区别\\n\\n- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\\n- 判断条件不同：where不能对聚合函数进行判断，而having可以。\\n\\n> 注意事项：\\n>\\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\\n> - 执行顺序: where > 聚合函数 > having 。\\n> - 支持多字段分组, 具体语法为 : group by columnA,columnB\\n\\n案例：\\n\\nA. 根据性别分组，统计男性员工和女性员工的数量\\n\\n``` sql\\nselect gender,count(*) from emp group by gender;\\n```\\n\\n![image-20220525150636926](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251506016.png)\\n\\nB. 根据性别分组，统计男性员工和女性员工的平均年龄\\n\\n``` sql\\nselect gender,avg(age) from emp group by gender;\\n```\\n\\n![image-20220525150757361](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251507435.png)\\n\\nC. 查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址\\n\\n``` sql\\nselect workaddress, count(*) address_count\\nfrom emp\\nwhere age < 45\\ngroup by workaddress\\nhaving address_count >= 3;\\n```\\n\\n![image-20220525151427330](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251514414.png)\\n\\nD. 统计各个工作地址上班的男性及女性员工的数量\\n\\n``` sql\\nselect workaddress \'地区\', gender \'性别\', count(*) \'数量\'\\nfrom emp\\ngroup by gender, workaddress;\\n```\\n\\n#### 1.6.6 排序查询\\n\\n排序是日常开发只能够非常常见的一个操作，分为升序和降序排序\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;\\n```\\n\\n2）. 排序方式\\n\\n- ASC：升序（默认值）\\n- DESC：降序\\n\\n> 注意事项\\n>\\n> - 如果是升序, 可以不指定排序方式ASC ; \\n> - 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;\\n\\n案例：\\n\\nA. 根据年龄对公司的员工进行升序排序\\n\\n``` sql\\nselect * from emp order by age asc;\\nselect * from emp order by age;\\n```\\n\\nB. 根据入职时间，对员工进行降序排序\\n\\n``` sql\\nselect * from emp order by entry date desc;\\n```\\n\\nC. 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序\\n\\n``` sql\\nselect * from emp order by age asc , entrydate desc;\\n```\\n\\n#### 1.6.7 分页查询\\n\\n分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台 都需要借助于数据库的分页操作。\\n\\n1）. 语法\\n\\n``` sql\\nselect 字段列表 from 表名 limit 起始索引 , 查询记录数;\\n```\\n\\n> 注意事项: \\n>\\n> - **起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数**。 \\n> - 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 \\n> - 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10\\n\\n案例：\\n\\nA. 查询第一页员工数据，每页显示十条记录\\n\\n``` sql\\n-- 起始索引为 （查询页码）-1*每页显示记录数\\nselect * from emp limit 0,10;\\n-- 查询的为第一页数据，起始索引可以省略\\nselect * from emp limit 10;\\n```\\n\\nB. 查询第二页员工数据，每页展示10条记录\\n\\n--------> (页码-1)*页展示记录数\\n\\n``` sql\\n-- 需要查询的为第二页员工数据\\n-- 起始索引等于 （查询页码-1）*每页显示记录数\\n-- 因此，此处起始索引为（2-1）*10\\nselect * from emp limit 10,10;\\n```\\n\\n#### 1.6.8 案例\\n\\n1）. 查询年龄为20,21,22,23岁的员工信息。\\n\\n``` sql\\nselect * from emp where age in(20,21,22,23);\\n```\\n\\n2）. 查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\\n\\n``` sql\\n#  查询性别为男，并且年龄在20-40岁（包含）以内的姓名为三个字的员工。\\nselect *\\nfrom emp\\nwhere gender = \'男\'\\n  and age between 20 and 40\\n  and name like \'___\';\\n```\\n\\n3）. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\\n\\n``` sql\\n# 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。\\nselect gender, count(*)\\nfrom emp\\nwhere age < 60\\ngroup by gender;\\n```\\n\\n4）. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按 入职时间降序排序。\\n\\n``` sql\\nselect name, age\\nfrom emp\\nwhere age <= 35\\norder by age, entrydate desc;\\n```\\n\\n5）.  查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序， 年龄相同按入职时间升序排序。\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere gender = \'男\'\\n  and age between 20 and 40\\norder by age, entrydate desc\\nlimit 5;\\n```\\n\\n#### 1.6.9 执行顺序\\n\\n![image-20220525154935887](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251549982.png)\\n\\n**DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...**\\n\\n### 1.7 DCL\\n\\n> DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。\\n\\n![image-20220525155152013](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251551105.png)\\n\\n#### 1.7.1 管理用户\\n\\n1）. 查询用户\\n\\n``` sql\\nselect * from mysql.user;\\n```\\n\\n查询结果如下：\\n\\n![image-20220525155335839](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251619656.png)\\n\\n**其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户**\\n\\n2）. 创建用户\\n\\n``` sql\\ncreate user \'用户名\'@\'主机名\' identified by \'密码\';\\n```\\n\\n3）. 修改用户密码\\n\\n``` sql\\nalter user \'用户名\'@\'主机名\' identified with mysql_native_password by \'新密码\';\\n```\\n\\n4）. 删除用户\\n\\n``` sql\\ndrop user \'用户名\'@\'主机名\';\\n```\\n\\n> 注意事项: \\n>\\n> - 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\\n> - 主机名可以使用 % 通配。 \\n> - 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。\\n\\n案例：\\n\\nA. 创建用户icat, 只能够在当前主机localhost访问, 密码123456;\\n\\n``` sql\\ncreate user \'icat\'@\'localhost\' identified by \'123456\';\\n```\\n\\nB. 创建用户icatw, 可以在任意主机访问该数据库, 密码123456;\\n\\n``` sql\\ncreate user \'icatw\'@\'%\' identified by \'123456\';\\n```\\n\\nC. 修改用户icatw的访问密码为1234;\\n\\n``` sql\\nalter user \'icatw\'@\'%\' identified with mysql_native_password by \'1234\';\\n```\\n\\nD. 删除 icat@localhost 用户\\n\\n``` sql\\ndrop user \'icat\'@\'localhost\';\\n```\\n\\n#### 1.7.2 权限控制\\n\\nMySQL中定义了很多种权限，但是常用的就以下几种：\\n\\n| 权限                | 说明               |\\n| ------------------- | ------------------ |\\n| ALL, ALL PRIVILEGES | 所有权限           |\\n| SELECT              | 查询数据           |\\n| INSERT              | 插入数据           |\\n| UPDATE              | 修改数据           |\\n| DELETE              | 删除数据           |\\n| ALTER               | 修改表             |\\n| DROP                | 删除数据库/表/视图 |\\n| CREATE              | 创建数据库/表      |\\n\\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html)。\\n\\n1）. 查询权限\\n\\n``` sql\\nSHOW GRANTS FOR \'用户名\'@\'主机名\' ;\\n```\\n\\n2）. 授予权限\\n\\n``` sql\\nGRANT 权限列表 ON 数据库名.表名 TO \'用户名\'@\'主机名\';\\n```\\n\\n3）. 撤销权限\\n\\n``` sql\\nREVOKE 权限列表 ON 数据库名.表名 FROM \'用户名\'@\'主机名\';\\n```\\n\\n> 注意事项： \\n>\\n> - 多个权限之间，使用逗号分隔 \\n> - 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\\n\\n案例: \\n\\nA. 查询 \'heima\'@\'%\' 用户的权限\\n\\n``` sql\\nshow grants for \'heima\'@\'%\';\\n```\\n\\nB. 授予 \'heima\'@\'%\' 用户itcast数据库所有表的所有操作权限\\n\\n``` sql\\ngrant all on itcast.* to \'heima\'@\'%\'\\n```\\n\\nC. 撤销 \'heima\'@\'%\' 用户的itcast数据库的所有权限\\n\\n``` sql\\nrevoke all on itcast.* from \'heima\'@\'%\';\\n```\\n\\n\\n\\n## 2. 函数\\n\\n函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那 么，函数到底在哪儿使用呢？ 我们先来看两个场景：\\n\\n![image-20220525162834366](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251628459.png)\\n\\n1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能 够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，那如果快速计 算出天数呢？ \\n\\n2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的 分数值，如98/75，如何快速判定分数的等级呢？ 其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。\\n\\n其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。 \\n\\nMySQL中的函数主要分为以下四类： **字符串函数、数值函数、日期函数、流程函数。**\\n\\n### 2.1 字符串函数\\n\\nMySQL中内置了很多字符串函数，常用的几个如下：\\n\\n| 函数                     | 功能                                                       |\\n| ------------------------ | ---------------------------------------------------------- |\\n| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串               |\\n| LOWER(str)               | 将字符串str全部转为小写                                    |\\n| UPPER(str)               | 将字符串str全部转为大写                                    |\\n| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 |\\n| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 |\\n| TRIM(str)                | 去掉字符串头部和尾部的空格                                 |\\n| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串            |\\n\\n演示如下：\\n\\nA. concat：字符串拼接\\n\\n``` sql\\nselect concat(\'Hello\' , \' MySQL\');\\n```\\n\\n结果如下：\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251651650.png\\\" alt=\\\"image-20220525165104555\\\" style=\\\"zoom:67%;\\\" />\\n\\nB. lower : 全部转小写\\n\\n``` sql\\nselect lower(\'Hello\');\\n```\\n\\n![image-20220525165228376](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251652464.png)\\n\\nC. upper : 全部转大写\\n\\n``` sql\\nselect upper(\'Hello\');\\n```\\n\\n![image-20220525165323592](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251653679.png)\\n\\nD.  lpad : 左填充\\n\\n``` sql\\nselect lpad(\'01\', 5, \'-\');\\n```\\n\\n![image-20220525165433666](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251654755.png)\\n\\nE. rpad : 右填充\\n\\n``` sql\\nselect rpad(\'01\', 5, \'-\');\\n```\\n\\n![image-20220525165713762](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251657320.png)\\n\\nF. trim : 去除空格\\n\\n``` sql\\nselect trim(\' Hello MySQL \');\\n```\\n\\nG. substring : 截取子字符串\\n\\n``` sql\\nselect substring(\'Hello MySQL\',1,5);\\n```\\n\\n案例：\\n\\n![image-20220525174936078](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251749181.png)\\n\\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员 工的工号应该为00001。\\n\\n``` sql\\nupdate emp set workno = lpad(workno, 5, \'0\');\\n```\\n\\n处理完毕后, 具体的数据为:\\n\\n![image-20220525175223093](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251752289.png)\\n\\n### 2.2 数值函数\\n\\n常见的数值函数如下：\\n\\n| 函数       | 功能                               |\\n| ---------- | ---------------------------------- |\\n| CEIL(x)    | 向上取整                           |\\n| FLOOR(x)   | 向下取整                           |\\n| MOD(x,y)   | 返回x/y的模                        |\\n| RAND()     | 返回0~1内的随机数                  |\\n| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |\\n\\n演示如下：\\n\\nA. ceil：向上取整\\n\\n``` sql\\nselect ceil(1.1);\\n```\\n\\nB. floor：向下取整\\n\\n``` sql\\nselect floor(1.9)\\n```\\n\\nC. mod：取模\\n\\n``` sql\\nselect mod(7,4);\\n```\\n\\nD. rand：获取随机数\\n\\n``` sql\\nselect rand();\\n```\\n\\nE. round：四舍五入\\n\\n``` sql\\nselect round(2.344,2);\\n```\\n\\n案例： \\n\\n通过数据库的函数，生成一个六位数的随机验证码。\\n\\n思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础 上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0\\n\\n``` sql\\nselect lpad(round(rand()*1000000 , 0), 6, \'0\');\\n```\\n\\n### 2.3 日期函数\\n\\n常见的日期函数如下：\\n\\n| 函数                               | 功能                                               |\\n| ---------------------------------- | -------------------------------------------------- |\\n| CURDATE()                          | 返回当前日期                                       |\\n| CURTIME()                          | 返回当前时间                                       |\\n| NOW()                              | 返回当前日期和时间                                 |\\n| YEAR(date)                         | 获取指定date的年份                                 |\\n| MONTH(date)                        | 获取指定date的月份                                 |\\n| DAY(date)                          | 获取指定date的日期                                 |\\n| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的 时间值 |\\n| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天 数      |\\n\\n演示如下：\\n\\nA. curdate：当前日期\\n\\n``` sql\\nselect curdate();\\n```\\n\\nB. curtime：当前时间\\n\\n``` SQL\\nselect curtime();\\n```\\n\\nC. now：当前日期和时间\\n\\n``` sql\\nselect now();\\n```\\n\\nD. YEAR , MONTH , DAY：当前年、月、日\\n\\n``` sql\\nselect YEAR(now());\\nselect MONTH(now());\\nselect DAY(now());\\n```\\n\\nE. date_add：增加指定的时间间隔\\n\\n``` sql\\nselect date_add(now(), INTERVAL 70 YEAR );\\n```\\n\\nF. datediff：获取两个日期相差的天数\\n\\n``` sql\\nselect datediff(\'2021-10-01\', \'2021-12-01\');\\n```\\n\\n案例： \\n\\n查询所有员工的入职天数，并根据入职天数倒序排序。 \\n\\n思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。\\n\\n``` sql\\nselect name, datediff(curdate(), entrydate) as \'entrydays\' from emp order by entrydays desc;\\n\\n```\\n\\n### 2.4 流程函数\\n\\n流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\\n\\n| 函数                                                         | 功能                                                       |\\n| ------------------------------------------------------------ | ---------------------------------------------------------- |\\n| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回 f                       |\\n| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则 返回value2              |\\n| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |\\n| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |\\n演示如下：\\n\\nA. if\\n\\n``` sql\\nselect if(false, \'Ok\', \'Error\');\\n```\\n\\nB. ifnull \\n\\n``` sql\\nselect ifnull(\'Ok\',\'Default\');\\nselect ifnull(\'\',\'Default\');\\n-- 只有这个才会输出default\\nselect ifnull(null,\'Default\');\\n```\\n\\nC. case when then else end\\n\\n需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----> 一线城市 , 其他 ----> 二线城市)\\n\\n``` sql\\nselect name,\\n       (case workaddress\\n            when \'北京\' then \'一线城市\'\\n            when \'上海\' then \'一线城市\'\\n            else\\n                \'二线城市\' end) as \'工作地址\'\\nfrom emp;\\n```\\n\\n案例：\\n\\n将学生表按成绩分类\\n\\n首先，准备数据\\n\\n``` sql\\ncreate table score\\n(\\n    id      int comment \'ID\',\\n    name    varchar(20) comment \'姓名\',\\n    math    int comment \'数学\',\\n    english int comment \'英语\',\\n    chinese int comment \'语文\'\\n) comment \'学员成绩表\';\\ninsert into score(id, name, math, english, chinese)\\nVALUES (1, \'Tom\', 67, 88, 95),\\n       (2, \'Rose\', 23, 66, 90),\\n       (3, \'Jack\', 56, 98, 76);\\n\\n```\\n\\n具体SQL如下\\n\\n``` sql\\nselect id,\\n       name,\\n       (case when math >= 85 then \'优秀\' when math >= 60 then \'及格\' else \'不及格\' end)\\n                \'数学\',\\n       (case\\n            when english >= 85 then \'优秀\'\\n            when english >= 60 then \'及格\'\\n            else \'不及格\'\\n           end) \'英语\',\\n       (case\\n            when chinese >= 85 then \'优秀\'\\n            when chinese >= 60 then \'及格\'\\n            else \'不及格\'\\n           end) \'语文\'\\nfrom score;\\n```\\n\\n![image-20220525181610736](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205251816834.png)\\n\\nMySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景， 思考一下需要用到什么样的函数来实现? \\n\\n1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ --------> \\n\\n答案: datediff \\n\\n2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ----------> \\n\\n答案: case ... when ...\\n\\n## 3. 约束\\n\\n### 3.1 概述\\n\\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\\n\\n目的：保证数据库中数据的正确、有效性和完整性。\\n\\n分类：\\n\\n| 约束                      | 描述                                                      | 关键字      |\\n| ------------------------- | --------------------------------------------------------- | ----------- |\\n| 非空约束                  | 限制该字段的数据不能为null                                | NOT NULL    |\\n| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                    | UNIQUE      |\\n| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                  | PRIMARY KEY |\\n| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值            | DEFAULT     |\\n| 检查约束(8.0.16版本 之后) | 保证字段值满足某一个条件                                  | CHECK       |\\n| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致 性和完整性 | FOREIGN KEY |\\n\\n> 注意：**约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。**\\n\\n### 3.2 约束演示\\n\\n案例需求： 根据需求，完成表结构的创建。需求如下：\\n\\n| 字段名 | 字段含 义   | 字段类型    | 约束条件                   | 约束关键字                  |\\n| ------ | ----------- | ----------- | -------------------------- | --------------------------- |\\n| id     | ID唯一 标识 | int         | 主键，并且自动增长         | PRIMARY KEY, AUTO_INCREMENT |\\n| name   | 姓名        | varchar(10) | 不为空，并且唯一           | NOT NULL , UNIQUE           |\\n| age    | 年龄        | int         | 大于0，并且小于等 于120    | CHECK                       |\\n| status | 状态        | char(1)     | 如果没有指定该值， 默认为1 | DEFAULT                     |\\n| gender | 性别        | char(1)     | 无                         |                             |\\n\\n对应的建表语句为：\\n\\n``` sql\\nCREATE TABLE tb_user\\n(\\n    id     int AUTO_INCREMENT PRIMARY KEY COMMENT \'ID唯一标识\',\\n    name   varchar(10) NOT NULL UNIQUE COMMENT \'姓名\',\\n    age    int check (age > 0 && age <= 120) COMMENT \'年龄\',\\n    status char(1) default \'1\' COMMENT \'状态\',\\n    gender char(1) COMMENT \'性别\'\\n);\\n```\\n\\n在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。\\n\\n### 3.3 外键约束\\n\\n#### 3.3.1 介绍\\n\\n外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\\n\\n准备数据\\n\\n``` sql\\ncreate table dept\\n(\\n    id   int auto_increment comment \'ID\' primary key,\\n    name varchar(50) not null comment \'部门名称\'\\n) comment \'部门表\';\\nINSERT INTO dept (id, name)\\nVALUES (1, \'研发部\'),\\n       (2, \'市场部\'),\\n       (3, \'财务部\'),\\n       (4,\\n        \'销售部\'),\\n       (5, \'总经办\');\\ndrop table if exists icatw.emp;\\ncreate table emp\\n(\\n    id        int auto_increment comment \'ID\' primary key,\\n    name      varchar(50) not null comment \'姓名\',\\n    age       int comment \'年龄\',\\n    job       varchar(20) comment \'职位\',\\n    salary    int comment \'薪资\',\\n    entrydate date comment \'入职时间\',\\n    managerid int comment \'直属领导ID\',\\n    dept_id   int comment \'部门ID\'\\n) comment \'员工表\';\\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\\n       (2, \'张无忌\', 20,\\n        \'项目经理\', 12500, \'2005-12-05\', 1, 1),\\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1);\\n\\n```\\n\\n\\n\\n#### 3.3.2 语法\\n\\n1）. 添加外键\\n\\n``` sql\\nCREATE TABLE 表名(\\n字段名 数据类型,\\n...\\n[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)\\n);\\n```\\n\\n``` sql\\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)\\nREFERENCES 主表 (主表列名) ;\\n```\\n\\n案例：\\n\\n为emp表的dept_id字段添加外键约束，关联dept表的主键id。\\n\\n``` sql\\nalter table emp\\n    add constraint fk foreign key (dept_id) references dept (id);\\n```\\n\\n![image-20220525212454577](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252124722.png)\\n\\n**当添加外键约束之后，不能直接删除父表的记录，需要先删除子表所关联数据，否则会报错。**\\n\\n2）. 删除外键\\n\\n``` sql\\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\\n```\\n\\n案例：\\n\\n删除emp表的外键fk。\\n\\n``` sql\\nalter table emp\\n    drop foreign key fk;\\n```\\n\\n#### 3.3.3 删除/更新行为\\n\\n添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:\\n\\n| 行为        | 说明                                                         |\\n| ----------- | ------------------------------------------------------------ |\\n| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为 |\\n| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为 |\\n| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。 |\\n| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。 |\\n| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)  |\\n\\n具体语法为：\\n\\n``` sql\\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES\\n主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;\\n```\\n\\n## 4. 多表查询\\n\\n### 4.1 多表关系\\n\\n项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\\n\\n- 一对多(多对一) \\n- 多对多 \\n- 一对一\\n\\n#### 4.1.1 一对多\\n\\n- 案例：部门与员工的关系\\n- 关系：一个部门对应多名员工，一个员工对应一个部门\\n- 实现：在多的一方建立外键，指向另一方的主键\\n\\n![image-20220525213949714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252139778.png)\\n\\n#### 4.1.2 多对多\\n\\n- 案例：学生与课程的关系\\n- 关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\\n- 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\\n\\n![image-20220525214004144](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252140207.png)\\n\\n对应的SQL脚本：\\n\\n``` sql\\ncreate table student\\n(\\n    id   int auto_increment primary key comment \'主键ID\',\\n    name varchar(10) comment \'姓名\',\\n    no   varchar(10) comment \'学号\'\\n) comment \'学生表\';\\ninsert into student\\nvalues (null, \'黛绮丝\', \'2000100101\'),\\n       (null, \'谢逊\',\\n        \'2000100102\'),\\n       (null, \'殷天正\', \'2000100103\'),\\n       (null, \'韦一笑\', \'2000100104\');\\ncreate table course\\n(\\n    id   int auto_increment primary key comment \'主键ID\',\\n    name varchar(10) comment \'课程名称\'\\n) comment \'课程表\';\\ninsert into course\\nvalues (null, \'Java\'),\\n       (null, \'PHP\'),\\n       (null, \'MySQL\'),\\n       (null, \'Hadoop\');\\n\\ncreate table student_course\\n(\\n    id        int auto_increment comment \'主键\' primary key,\\n    studentid int not null comment \'学生ID\',\\n    courseid  int not null comment \'课程ID\',\\n    constraint fk_courseid foreign key (courseid) references course (id),\\n    constraint fk_studentid foreign key (studentid) references student (id)\\n) comment \'学生课程中间表\';\\ninsert into student_course\\nvalues (null, 1, 1),\\n       (null, 1, 2),\\n       (null, 1, 3),\\n       (null, 2, 2),\\n       (null, 2, 3),\\n       (null, 3, 4);\\n```\\n\\n#### 4.1.3 一对一\\n\\n- 案例：用户与用户详情的关系\\n- 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\\n- 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\\n\\n![image-20220525214650949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205252146016.png)\\n\\n对应的SQL脚本：\\n\\n``` sql\\ncreate table if not exists tb_user\\n(\\n    id     int auto_increment primary key comment \'主键ID\',\\n    name   varchar(10) comment \'姓名\',\\n    age    int comment \'年龄\',\\n    gender char(1) comment \'1: 男 , 2: 女\',\\n    phone  char(11) comment \'手机号\'\\n) comment \'用户基本信息表\';\\ncreate table if not exists tb_user_edu\\n(\\n    id            int auto_increment primary key comment \'主键ID\',\\n    degree        varchar(20) comment \'学历\',\\n    major         varchar(50) comment \'专业\',\\n    primaryschool varchar(50) comment \'小学\',\\n    middleschool  varchar(50) comment \'中学\',\\n\\n    university    varchar(50) comment \'大学\',\\n    userid        int unique comment \'用户ID\',\\n    constraint fk_userid foreign key (userid) references tb_user (id)\\n) comment \'用户教育信息表\';\\ninsert into tb_user(id, name, age, gender, phone)\\nvalues (null, \'黄渤\', 45, \'1\', \'18800001111\'),\\n       (null, \'冰冰\', 35, \'2\', \'18800002222\'),\\n       (null, \'码云\', 55, \'1\', \'18800008888\'),\\n       (null, \'李彦宏\', 50, \'1\', \'18800009999\');\\ninsert into tb_user_edu(id, degree, major, primaryschool, middleschool,\\n                        university, userid)\\nvalues (null, \'本科\', \'舞蹈\', \'静安区第一小学\', \'静安区第一中学\', \'北京舞蹈学院\', 1),\\n       (null, \'硕士\', \'表演\', \'朝阳区第一小学\', \'朝阳区第一中学\', \'北京电影学院\', 2),\\n       (null, \'本科\', \'英语\', \'杭州市第一小学\', \'杭州市第一中学\', \'杭州师范大学\', 3),\\n       (null, \'本科\', \'应用数学\', \'阳泉第一小学\', \'阳泉区第一中学\', \'清华大学\', 4);\\n```\\n\\n### 4.2 多表查询概述\\n\\n#### 4.2.1 数据准备\\n\\n1）. 删除之前emp，dept表的测试数据\\n\\n2）. 执行如下脚本，创建emp表与dept表并插入测试数据\\n\\n``` sql\\n-- 创建dept表，并插入数据\\ndrop table if exists dept;\\ncreate table dept\\n(\\n    id   int auto_increment comment \'ID\' primary key,\\n    name varchar(50) not null comment \'部门名称\'\\n) comment \'部门表\';\\nINSERT INTO dept (id, name)\\nVALUES (1, \'研发部\'),\\n       (2, \'市场部\'),\\n       (3, \'财务部\'),\\n       (4,\\n        \'销售部\'),\\n       (5, \'总经办\'),\\n       (6, \'人事部\');\\n-- 创建emp表，并插入数据\\ndrop table if exists emp;\\ncreate table emp\\n(\\n    id        int auto_increment comment \'ID\' primary key,\\n    name      varchar(50) not null comment \'姓名\',\\n    age       int comment \'年龄\',\\n    job       varchar(20) comment \'职位\',\\n    salary    int comment \'薪资\',\\n    entrydate date comment \'入职时间\',\\n    managerid int comment \'直属领导ID\',\\n    dept_id   int comment \'部门ID\'\\n) comment \'员工表\';\\n-- 添加外键\\nalter table emp\\n    add constraint fk_emp_dept_id foreign key (dept_id) references\\n        dept (id);\\nINSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)\\nVALUES (1, \'金庸\', 66, \'总裁\', 20000, \'2000-01-01\', null, 5),\\n       (2, \'张无忌\', 20, \'项目经理\', 12500, \'2005-12-05\', 1, 1),\\n       (3, \'杨逍\', 33, \'开发\', 8400, \'2000-11-03\', 2, 1),\\n       (4, \'韦一笑\', 48, \'开发\', 11000, \'2002-02-05\', 2, 1),\\n       (5, \'常遇春\', 43, \'开发\', 10500, \'2004-09-07\', 3, 1),\\n       (6, \'小昭\', 19, \'程序员鼓励师\', 6600, \'2004-10-12\', 2, 1),\\n       (7, \'灭绝\', 60, \'财务总监\', 8500, \'2002-09-12\', 1, 3),\\n       (8, \'周芷若\', 19, \'会计\', 48000, \'2006-06-02\', 7, 3),\\n       (9, \'丁敏君\', 23, \'出纳\', 5250, \'2009-05-13\', 7, 3),\\n       (10, \'赵敏\', 20, \'市场部总监\', 12500, \'2004-10-12\', 1, 2),\\n       (11, \'鹿杖客\', 56, \'职员\', 3750, \'2006-10-03\', 10, 2),\\n       (12, \'鹤笔翁\', 19, \'职员\', 3750, \'2007-05-09\', 10, 2),\\n       (13, \'方东白\', 19, \'职员\', 5500, \'2009-02-12\', 10, 2),\\n       (14, \'张三丰\', 88, \'销售总监\', 14000, \'2004-10-12\', 1, 4),\\n       (15, \'俞莲舟\', 38, \'销售\', 4600, \'2004-10-12\', 14, 4),\\n       (16, \'宋远桥\', 40, \'销售\', 4600, \'2004-10-12\', 14, 4),\\n       (17, \'陈友谅\', 42, null, 2000, \'2011-10-12\', 1, null);\\n```\\n\\ndept表共6条记录，emp表共17条记录。\\n\\n#### 4.2.2 概述\\n\\n多表查询就是指从多张表中查询数据。\\n\\n原来查询单表数据，执行的SQL形式为：select * from emp; \\n\\n那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，\\n\\n如： `select * from emp , dept` ; 具体的执行结果如下:\\n\\n![image-20220526085113395](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260851744.png)\\n\\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。\\n\\n**笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。**\\n\\n![image-20220526085212058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260853700.png)\\n\\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\\n\\n![image-20220526085430499](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260854637.png)\\n\\n![image-20220526085521044](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260855198.png)\\n\\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。\\n\\n``` sql\\nselect *\\nfrom icatw.emp,\\n     icatw.dept\\nwhere emp.dept_id = dept.id;\\n```\\n\\n![image-20220526085719946](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260857204.png)\\n\\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。\\n\\n#### 4.2.3 分类\\n\\n- 连接查询\\n  - 内连接：相当于查询A、B交集部分数据 \\n  - 外连接： \\n  - 左外连接：查询左表所有数据，以及两张表交集部分数据 \\n  - 右外连接：查询右表所有数据，以及两张表交集部分数据 \\n  - 自连接：当前表与自身的连接查询，自连接必须使用表别名\\n- 子查询\\n\\n![image-20220526090006541](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900675.png)\\n\\n### 4.3 内连接\\n\\n![image-20220526090056077](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260900217.png)\\n\\n内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构\\n\\n1）. 隐式内连接\\n\\n``` sql\\nselect 字段列表 from 表1 , 表2 where 条件...;\\n```\\n\\n2）. 显式内连接\\n\\n``` sql\\nselect 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;\\n```\\n\\n案例：\\n\\nA. 查询每一个员工的姓名，及关联的部门的名称（隐式内连接）\\n\\n表结构：emp , dept\\n\\n连接条件：emp.dept_id = dept.id\\n\\n``` sql\\nselect emp.name, dept.name\\nfrom emp,\\n     dept\\nwhere emp.dept_id = dept.id;\\n\\n-- 为每一张表起别名,简化SQL编写\\nselect e.name, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n![image-20220526091506843](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205260915000.png)\\n\\nB. 查询每一个员工的姓名，及关联的部门的名称（显示内连接实现）\\n\\n--- INNER JOIN ... ON ...\\n\\n表结构：emp，dept\\n\\n连接条件：emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, d.name\\nfrom emp e\\n         inner join dept d on e.dept_id = d.id;\\n         \\n-- 为每一张表起别名,简化SQL编写\\nselect e.name, d.name\\nfrom emp e\\n         join dept d on e.dept_id = d.id;\\n```\\n\\n> 表的别名：\\n>\\n> - tablea as 别名1 ,  tableb as 别名2 ;\\n> -  tablea 别名1 , tableb 别名2 ;\\n>\\n> 注意事项：\\n>\\n> ​\\t\\t一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\\n\\n### 4.4 外连接\\n\\n![image-20220526105436328](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261054413.png)\\n\\n外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：\\n\\n1）. 左外连接\\n\\n``` sql\\nselect 字段列表 from 表1 left [outer] join 表2 on 条件 ...;\\n```\\n\\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\\n\\n2）. 右外连接\\n\\n``` sql\\nselect 字段列表 from 表1 right [outer] join 表2 on 条件...;\\n```\\n\\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\\n\\n案例: \\n\\nA. 查询emp表的所有数据, 和对应的部门信息 \\n\\n由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。 \\n\\n表结构: emp, dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.*, d.name\\nfrom icatw.emp e\\n         left join icatw.dept d on e.dept_id = d.id;\\n\\nselect e.*, d.name\\nfrom emp e\\n         left outer join dept d on e.dept_id = d.id;\\n```\\n\\nB. 查询dept表的所有数据, 和对应的员工信息(右外连接)\\n\\n由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 \\n\\n表结构: emp, dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;\\n\\nselect d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;\\n```\\n\\n> 注意事项：\\n>\\n> ​\\t\\t左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。而我们在日常开发使用时，更偏向于左外连接。\\n\\n### 4.5 自连接\\n\\n#### 4.5.1 自连接查询\\n\\n自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。下面是自连接 的查询语法：\\n\\n``` sql\\nselect 字段列表 from 表A 别名A join 表A 别名B on 条件...;\\n```\\n\\n而对于自连接查询，可以是内连接查询，也可以是外连接查询。\\n\\n案例：\\n\\nA. 查询员工 及其 所属领导的名字 \\n\\n表结构: emp\\n\\n``` SQL\\n# A. 查询员工 及其 所属领导的名字\\nselect a.name \'领导名\', b.name \'员工名\'\\nfrom emp a\\n         join emp b on a.id = b.managerid;\\n```\\n\\nB. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 \\n\\n表结构: emp a , emp b\\n\\n``` SQL\\nselect a.name \'员工\', b.name \'领导\'\\nfrom emp a\\n         left join emp b on a.managerid =\\n                            b.id;\\n```\\n\\n> 注意事项: \\n>\\n> ​\\t\\t在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底 是哪一张表的字段。\\n\\n#### 4.5.2 联合查询\\n\\n对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\\n\\n``` sql\\nSELECT 字段列表 FROM 表A ...\\nUNION [ ALL ]\\nSELECT 字段列表 FROM 表B ....;\\n```\\n\\n- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 \\n- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。\\n\\n案例: \\n\\nA. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. \\n\\n当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们 也可以通过union/union all来联合查询.\\n\\nunion all: 会有重复值\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary < 5000\\nunion all\\nselect *\\nfrom emp\\nwhere age > 50;\\n```\\n\\n相当于\\n\\n``` sql\\nselect * from emp where salary < 5000 or age > 50;\\n```\\n\\n![image-20220526112549321](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261125429.png)\\n\\nunion 联合查询，会对查询出来的结果进行去重处理\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary < 5000\\nunion\\nselect *\\nfrom emp\\nwhere age > 50;\\n```\\n\\n相当于\\n\\n``` sql\\nselect distinct *\\nfrom emp\\nwhere salary < 5000\\n   or age > 50;\\n```\\n\\n> 注意： \\n>\\n> ​\\t\\t如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报 错。如：\\n\\n![image-20220526112722744](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205261127805.png)\\n\\n### 4.6 子查询\\n\\n#### 4.6.1 概述\\n\\n1）. 概念\\n\\nSQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。\\n\\n``` sql\\nselect * from t1 where column1=(select column1 from t2); \\n```\\n\\n子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。\\n\\n2）. 分类\\n\\n根据子查询结果不同，分为： \\n\\nA. 标量子查询（子查询结果为单个值） \\n\\nB. 列子查询(子查询结果为一列) \\n\\nC. 行子查询(子查询结果为一行) \\n\\nD. 表子查询(子查询结果为多行多列)\\n\\n\\n\\n根据子查询位置，分为： \\n\\nA. WHERE之后 \\n\\nB. FROM之后 \\n\\nC. SELECT之后\\n\\n#### 4.6.2 标量子查询\\n\\n子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= <> > >= < <=\\n\\n案例：\\n\\nA. 查询 \\\"销售部\\\" 的所有员工信息 \\n\\n完成这个需求时，我们可以将需求分解为两步： \\n\\n①. 查询 \\\"销售部\\\" 部门ID\\n\\n``` sql\\nselect id\\n                 from dept\\n                 where name = \'销售部\';\\n```\\n\\n②. 根据 \\\"销售部\\\" 部门ID, 查询员工信息\\n\\n``` sql\\n# 查询 \\\"销售部\\\" 的所有员工信息\\nselect *\\nfrom emp\\nwhere dept_id = (select id\\n                 from dept\\n                 where name = \'销售部\');\\n```\\n\\n内连接：\\n\\n``` sql\\nselect e.*\\nfrom emp e\\n         join dept d on e.dept_id = d.id and d.name = \'销售部\';\\n```\\n\\nB. 查询在 \\\"方东白\\\" 入职之后的员工信息 \\n\\n完成这个需求时，我们可以将需求分解为两步： \\n\\n①. 查询 方东白 的入职日期\\n\\n``` sql\\n# 查询在 \\\"方东白\\\" 入职之后的员工信息\\nselect entrydate\\nfrom emp\\nwhere name = \'方东白\';\\n```\\n\\n②. 查询指定入职日期之后入职的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere entrydate > (select entrydate\\n                   from emp\\n                   where name = \'方东白\');\\n```\\n\\n#### 4.6.3 列子查询\\n\\n子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 \\n\\n常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\\n\\n| 操作符 | 描述                                   |\\n| ------ | -------------------------------------- |\\n| IN     | 在指定的集合范围之内，多选一           |\\n| NOT IN | 不在指定的集合范围之内                 |\\n| ANY    | 子查询返回列表中，有任意一个满足即可   |\\n| SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |\\n| ALL    | 子查询返回列表的所有值都必须满足       |\\n\\n案例：\\n\\nA. 查询 \\\"销售部\\\" 和 \\\"市场部\\\" 的所有员工信息\\n\\n分解为以下两步: \\n\\n①. 查询 \\\"销售部\\\" 和 \\\"市场部\\\" 的部门ID\\n\\n``` sql\\nselect id\\nfrom dept\\nwhere name = \'销售部\'\\n   or name = \'市场部\';\\n```\\n\\n②. 根据部门ID, 查询员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere dept_id in (select id\\n                  from dept\\n                  where name = \'销售部\'\\n                     or name = \'市场部\');\\n```\\n\\nB. 查询比 财务部 所有人工资都高的员工信息\\n\\n分解为以下两步: \\n\\n①. 查询所有 财务部 人员工资\\n\\n``` sql\\nselect id from dept where name = \'财务部\';\\nselect salary from emp where dept_id = (select id from dept where name = \'财务部\');\\n```\\n\\n②. 比 财务部 所有人工资都高的员工信息\\n\\n``` sql\\nselect * from emp where salary > all ( select salary from emp where dept_id =\\n(select id from dept where name = \'财务部\') );\\n```\\n\\nC. 查询比研发部其中任意一人工资高的员工信息\\n\\n分解为以下两步: \\n\\n①. 查询研发部所有人工资\\n\\n``` sql\\nselect salary\\nfrom emp\\nwhere dept_id = (select id from dept where name = \'研发部\');\\n```\\n\\n②. 比研发部其中任意一人工资高的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > any (select salary\\n                    from emp\\n                    where dept_id = (select id from dept where name = \'研发部\'));\\n```\\n\\n#### 4.6.4 行子查询\\n\\n子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：= 、<> 、IN 、NOT IN\\n\\n案例: \\n\\nA. 查询与 \\\"张无忌\\\" 的薪资及直属领导相同的员工信息 ; \\n\\n这个需求同样可以拆解为两步进行:\\n\\n①. 查询 \\\"张无忌\\\" 的薪资及直属领导\\n\\n```sql\\nselect salary, managerid\\nfrom emp\\nwhere name = \'张无忌\';\\n```\\n\\n②. 查询与 \\\"张无忌\\\" 的薪资及直属领导相同的员工信息 ;\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere (salary, managerid) = (select salary, managerid\\n                             from emp\\n                             where name = \'张无忌\');\\n```\\n\\n#### 4.6.5 表子查询\\n\\n子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN\\n\\n案例: \\n\\nA. 查询与 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资相同的员工信息 \\n\\n分解为两步执行:\\n\\n①. 查询 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资\\n\\n``` sql\\nselect job, salary\\nfrom emp\\nwhere name = \'鹿杖客\'\\n   or name = \'宋远桥\';\\n```\\n\\n②. 查询与 \\\"鹿杖客\\\" , \\\"宋远桥\\\" 的职位和薪资相同的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere (job, salary) in (select job, salary\\n                        from emp\\n                        where name = \'鹿杖客\'\\n                           or name = \'宋远桥\');\\n```\\n\\nB. 查询入职日期是 \\\"2006-01-01\\\" 之后的员工信息 , 及其部门信息\\n\\n分解为两步执行: \\n\\n①. 入职日期是 \\\"2006-01-01\\\" 之后的员工信息\\n\\n``` sql\\nselect *\\nfrom emp where entrydate>\'2006-01-01\';\\n```\\n\\n②. 查询这部分员工, 对应的部门信息;\\n\\n```sql\\n-- 先查询出入职日期是 \\\"2006-01-01\\\" 之后的员工信息，再将其作为新表与部门表进行左外连接查询\\nselect *\\nfrom (select *\\n      from emp\\n      where entrydate > \'2006-01-01\') e\\n         left join dept d\\n                   on e.dept_id = d.id;\\n```\\n\\n### 4.7 多表查询案例\\n\\n数据环境准备：\\n\\n``` sql\\ncreate table salgrade\\n(\\n    grade int,\\n    losal int,\\n    hisal int\\n) comment \'薪资等级表\';\\ninsert into salgrade\\nvalues (1, 0, 3000),\\n       (2, 3001, 5000),\\n       (3, 5001, 8000),\\n       (4, 8001, 10000),\\n       (5, 10001, 15000),\\n       (6, 15001, 20000),\\n       (7, 20001, 25000),\\n       (8, 25001, 30000);\\n```\\n\\n在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉 及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。\\n\\n1）. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）\\n\\n表: emp , dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, e.age, e.job, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n2）. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接） \\n\\n表: emp , dept\\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.name, e.age, e.job, d.name\\nfrom emp e\\n         inner join dept d on e.dept_id = d.id and e.age < 30;\\n```\\n\\n3）. 查询拥有员工的部门ID、部门名称\\n\\n表：emp，dept\\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect distinct d.id, d.name\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id;\\n```\\n\\n4）. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出 来(外连接) \\n\\n表: emp , dept \\n\\n连接条件: emp.dept_id = dept.id\\n\\n``` sql\\nselect e.*, d.name\\nfrom emp e\\n         left join dept d on d.id = e.dept_id and e.age > 40;\\n```\\n\\n5）. 查询所有员工的工资等级 \\n\\n表: emp , salgrade \\n\\n连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal\\n\\n``` sql\\nselect e.*, s.grade \'员工等级\'\\nfrom emp e,\\n     salgrade s\\nwhere e.salary between s.losal and s.hisal;\\n```\\n\\n6）. 查询 \\\"研发部\\\" 所有员工的信息及 工资等级 \\n\\n表: emp , salgrade , dept \\n\\n连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id \\n\\n查询条件 : dept.name = \'研发部\'\\n\\n``` sql\\nselect e.*, d.name, s.grade\\nfrom emp e,\\n     dept d,\\n     salgrade s\\nwhere d.name = \'研发部\'\\n  and e.dept_id = d.id\\n  and e.salary between s.losal and s.hisal;\\n```\\n\\n7）. 查询 \\\"研发部\\\" 员工的平均工资 \\n\\n表: emp , dept \\n\\n连接条件 : emp.dept_id = dept.id\\n\\n``` sql\\nselect avg(e.salary)\\nfrom emp e,\\n     dept d\\nwhere e.dept_id = d.id\\n  and d.name = \'研发部\';\\n```\\n\\n8）. 查询工资比 \\\"灭绝\\\" 高的员工信息。 \\n\\n①. 查询 \\\"灭绝\\\" 的薪资\\n\\n``` sql\\nselect salary\\nfrom emp\\nwhere emp.name = \'灭绝\';\\n```\\n\\n②. 查询比她工资高的员工数据\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > (select salary\\n                from emp\\n                where emp.name = \'灭绝\');\\n```\\n\\n9）.  查询比平均薪资高的员工信息 \\n\\n①. 查询员工的平均薪资\\n\\n``` sql\\nselect avg(salary)\\nfrom emp;\\n```\\n\\n②. 查询比平均薪资高的员工信息\\n\\n``` sql\\nselect *\\nfrom emp\\nwhere salary > (select avg(salary)\\n                from emp);\\n```\\n\\n10）.  查询低于本部门平均工资的员工信息 \\n\\n①. 查询指定部门平均薪资\\n\\n``` sql\\nselect avg(e1.salary) from emp e1 where e1.dept_id = 1;\\nselect avg(e1.salary) from emp e1 where e1.dept_id = 2;\\n```\\n\\n②. 查询低于本部门平均工资的员工信息\\n\\n``` sql\\nselect *\\nfrom emp e2\\nwhere e2.salary < (select avg(e1.salary)\\n                   from emp e1\\n                   where e1.dept_id = e2.dept_id);\\n```\\n\\n11）. 查询所有的部门信息, 并统计部门的员工人数\\n\\n``` sql\\nselect d.id, d.name, (select count(*) from emp e where e.dept_id = d.id) \'人数\'\\nfrom dept d;\\n```\\n\\n12）. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称\\n\\n表: student , course , student_course \\n\\n连接条件: student.id = student_course.studentid , course.id = student_course.courseid\\n\\n``` sql\\nselect s.name, s.no, c.name\\nfrom student s,\\n     student_course sc,\\n     course c\\nwhere s.id = sc.studentid\\n  and sc.courseid = c.id;\\n```\\n\\n**备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条 件的记录即可。**\\n\\n## 5. 事务\\n\\n### 5.1 事务介绍\\n\\n事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 \\n\\n就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。\\n\\n![image-20220526211221401](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112624.png)\\n\\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :\\n\\n![image-20220526211238606](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262112698.png)\\n\\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\\n\\n![image-20220526211300656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113735.png)\\n\\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。\\n\\n![image-20220526211317578](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262113661.png)\\n\\n> **注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。**\\n\\n### 5.2 事务操作\\n\\n数据准备：\\n\\n``` sql\\ndrop table if exists account;\\ncreate table account\\n(\\n    id    int primary key AUTO_INCREMENT comment \'ID\',\\n    name  varchar(10) comment \'姓名\',\\n    money double(10, 2) comment \'余额\'\\n) comment \'账户表\';\\ninsert into account(name, money)\\nVALUES (\'张三\', 2000),\\n       (\'李四\', 2000);\\n```\\n\\n#### 5.2.1 未控制事务\\n\\n1). 测试正常情况\\n\\n``` sql\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n```\\n\\n测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。\\n\\n![image-20220526211732232](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262117323.png)\\n\\n2). 测试异常情况\\n\\n``` sql\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n出错了....\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n```\\n\\n我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。\\n\\n![image-20220526211831649](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262118725.png)\\n\\n#### 5.2.2 控制事务一\\n\\n1）. 查看/设置事务提交方式\\n\\n``` sql\\nSELECT @@autocommit ;\\nSET @@autocommit = 0 ;\\n```\\n\\n2）. 提交事务\\n\\n``` sql\\ncommit;\\n```\\n\\n3）. 回滚事务\\n\\n``` sql\\nrollback;\\n```\\n\\n> 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\\n\\n#### 5.2.3 控制事务二\\n\\n1）. 开启事务\\n\\n``` sql\\nSTART TRANSACTION 或 BEGIN ;\\n```\\n\\n2）. 提交事务\\n\\n``` sql\\ncommit;\\n```\\n\\n3）. 回滚事务\\n\\n``` sql\\nROLLBACK;\\n```\\n\\n转账案例：\\n\\n``` sql\\n-- 开启事务\\nstart transaction\\n-- 1. 查询张三余额\\nselect * from account where name = \'张三\';\\n-- 2. 张三的余额减少1000\\nupdate account set money = money - 1000 where name = \'张三\';\\n-- 3. 李四的余额增加1000\\nupdate account set money = money + 1000 where name = \'李四\';\\n-- 如果正常执行完毕, 则提交事务\\ncommit;\\n-- 如果执行过程中报错, 则回滚事务\\n-- rollback;\\n```\\n\\n### 5.3  事务四大特性（ACID）\\n\\n- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 \\n- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 \\n- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。\\n- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\\n\\n上述就是事务的四大特性，简称ACID。\\n\\n![image-20220526215911714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262159820.png)\\n\\n### 5.4 并发事务问题\\n\\n1）. 脏读：一个事务读到另外一个事务还没有提交的数据。\\n\\n![image-20220526220426943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204036.png)\\n\\n2）. 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\\n\\n![image-20220526220450359](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262204455.png)\\n\\n3）. 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 \\\"幻影\\\"。\\n\\n![image-20220526220605668](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205262206753.png)\\n\\n### 5.5 事务隔离级别\\n\\n为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\\n\\n| 隔离级别                          | 脏读 | 不可重复读取 | 幻读 |\\n| --------------------------------- | ---- | ------------ | ---- |\\n| Read uncommitted（读未提交）      | √    | √            | √    |\\n| Read committed（读已提交）        | ×    | √            | √    |\\n| Repeatable Read(默认)（可重复读） | ×    | ×            | √    |\\n| Serializable（串行化）            | ×    | ×            | ×    |\\n\\n1）. 查看事务隔离级别\\n\\n``` SQL\\nSELECT @@TRANSACTION_ISOLATION;\\n```\\n\\n2）. 设置事务隔离级别\\n\\n``` sql\\nSET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |\\nREAD COMMITTED | REPEATABLE READ | SERIALIZABLE }\\n```\\n\\n> **注意：事务隔离级别越高，数据越安全，但是性能越低。**\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/96d3026e9fb9c7105723943eab40d899.jpg\",\"articleTitle\":\"MySQL学习【基础篇】\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-26 22:41:34',NULL),(1201,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Mybatis学习笔记\\n\\n## 一、Mybatis简介\\n\\n### 1、MyBatis历史\\n\\nMyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。 \\n\\niBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects（DAO）。\\n\\n### 2、MyBatis特性\\n\\n1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 \\n\\n3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 \\n\\n4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架\\n\\n### 3、MyBatis下载\\n\\nMyBatis下载地址：https://github.com/mybatis/mybatis-3\\n\\n![image-20220527082907171](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205270829457.png)\\n\\n### 4、和其它持久化层技术对比\\n\\n- JDBC\\n  - SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 \\n  - 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 \\n  - 代码冗长，开发效率低\\n- Hibernate 和 JPA\\n  - 操作简便，开发效率高 \\n  - 程序中的长难复杂 SQL 需要绕过框架 \\n  - 内部自动生产的 SQL，不容易做特殊优化 \\n  - 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 \\n  - 反射操作太多，导致数据库性能下降\\n- MyBatis\\n  - 轻量级，性能出色 \\n  - SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 \\n  - 开发效率稍逊于HIbernate，但是完全能够接受\\n\\n## 二、搭建MyBatis\\n\\n这里使用SpringBoot整合MyBatis\\n\\n### 1、开发环境\\n\\nIDE：idea 2021.3 \\n\\n构建工具：maven 3.8.3\\n\\nMySQL版本：MySQL 8.x\\n\\nMyBatis版本：MyBatis 3.5.9\\n\\n### 2、创建maven工程\\n\\n引入依赖\\n\\n``` java\\n <dependency>\\n        <groupId>org.mybatis</groupId>\\n        <artifactId>mybatis</artifactId>\\n        <version>3.5.9</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>mysql</groupId>\\n        <artifactId>mysql-connector-java</artifactId>\\n        <version>8.0.29</version>\\n    </dependency>\\n    <dependency>\\n        <groupId>junit</groupId>\\n        <artifactId>junit</artifactId>\\n        <version>4.13.2</version>\\n        <scope>test</scope>\\n    </dependency>\\n```\\n\\n### 3、创建MyBatis的核心配置文件\\n\\n> 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息\\n>\\n> 核心配置文件存放的位置是src/main/resources目录下\\n\\nmybatis-config.xml\\n\\n``` java\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE configuration\\n        PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\"\\n        \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\">\\n<configuration>\\n    <!--设置连接数据库的环境-->\\n    <environments default=\\\"development\\\">\\n        <environment id=\\\"development\\\">\\n            <transactionManager type=\\\"JDBC\\\"/>\\n            <dataSource type=\\\"POOLED\\\">\\n                <property name=\\\"driver\\\" value=\\\"com.mysql.jdbc.Driver\\\"/>\\n                <property name=\\\"url\\\"\\n                          value=\\\"jdbc:mysql://localhost:3306/MyBatis\\\"/>\\n                <property name=\\\"username\\\" value=\\\"root\\\"/>\\n                <property name=\\\"password\\\" value=\\\"12345\\\"/>\\n            </dataSource>\\n        </environment>\\n    </environments>\\n    <!--引入映射文件-->\\n    <mappers>\\n        <mapper resource=\\\"mappers/UserMapper.xml\\\"/>\\n    </mappers>\\n</configuration>\\n```\\n\\n### 4、创建mapper接口\\n\\n> MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要 提供实现类。\\n\\n``` java\\npublic interface UserMapper {\\n/**\\n* 添加用户信息\\n*/\\nint insertUser();\\n}\\n```\\n\\n### 5、创建MyBatis的映射文件\\n\\n相关概念：**ORM（Object Relationship Mapping）对象关系映射**。 \\n\\n- 对象：Java的实体类对象 \\n- 关系：关系型数据库 \\n- 映射：二者之间的对应关系\\n\\n| Java概念 | 数据库概念 |\\n| -------- | ---------- |\\n| 类       | 表         |\\n| 属性     | 字段/列    |\\n| 对象     | 记录/行    |\\n\\n>1、映射文件的命名规则： \\n>\\n>表所对应的实体类的类名+Mapper.xml \\n>\\n>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml \\n>\\n>因此一个映射文件对应一个实体类，对应一张表的操作 \\n>\\n>MyBatis映射文件用于编写SQL，访问以及操作表中的数据 \\n>\\n>MyBatis映射文件存放的位置是src/main/resources/mappers目录下 \\n>\\n>2、MyBatis中可以面向接口操作数据，要保证两个一致： \\n>\\n>a>mapper接口的全类名和映射文件的命名空间（namespace）保持一致 b>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致\\n\\n``` xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper\\n        PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\"\\n        \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\">\\n<mapper namespace=\\\"cn.icatw.mybatis.mapper.UserMapper\\\">\\n    <!--int insertUser();-->\\n    <insert id=\\\"insertUser\\\">\\n        insert into t_user\\n        values (3, \'张三\', \'123\', 23, \'女\', \'762188827@qq.com\')\\n    </insert>\\n</mapper>\\n```\\n\\n### 6、通过junit测试功能\\n\\n``` java\\n//读取MyBatis的核心配置文件\\nInputStream is = Resources.getResourceAsStream(\\\"mybatis-config.xml\\\");\\n//创建SqlSessionFactoryBuilder对象\\nSqlSessionFactoryBuilder sqlSessionFactoryBuilder = new\\nSqlSessionFactoryBuilder();\\n//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\\nSqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\\n//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\\n//SqlSession sqlSession = sqlSessionFactory.openSession();\\n//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交\\nSqlSession sqlSession = sqlSessionFactory.openSession(true);\\n//通过代理模式创建UserMapper接口的代理实现类对象\\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\\n//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配\\n映射文件中的SQL标签，并执行标签中的SQL语句\\nint result = userMapper.insertUser();\\n//sqlSession.commit();\\nSystem.out.println(\\\"结果：\\\"+result);\\n```\\n\\n> - SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的 会话） \\n>\\n> - SqlSessionFactory：是“生产”SqlSession的“工厂”。 \\n>\\n> - 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的 相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。\\n\\n### 7、加入log4j日志功能\\n\\n- 加入依赖\\n\\n  ``` java\\n      <!-- log4j日志 -->\\n      <dependency>\\n          <groupId>log4j</groupId>\\n          <artifactId>log4j</artifactId>\\n          <version>1.2.17</version>\\n      </dependency>\\n  ```\\n\\n  \\n\\n- 加入log4j配置文件\\n\\n> log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下\\n\\n``` xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE log4j:configuration SYSTEM \\\"log4j.dtd\\\">\\n<log4j:configuration xmlns:log4j=\\\"http://jakarta.apache.org/log4j/\\\">\\n    <appender name=\\\"STDOUT\\\" class=\\\"org.apache.log4j.ConsoleAppender\\\">\\n        <param name=\\\"Encoding\\\" value=\\\"UTF-8\\\"/>\\n        <layout class=\\\"org.apache.log4j.PatternLayout\\\">\\n            <param name=\\\"ConversionPattern\\\" value=\\\"%-5p %d{MM-dd HH:mm:ss,SSS}\\n%m (%F:%L) \\\\n\\\"/>\\n        </layout>\\n    </appender>\\n    <logger name=\\\"java.sql\\\">\\n        <level value=\\\"debug\\\"/>\\n    </logger>\\n    <logger name=\\\"org.apache.ibatis\\\">\\n        <level value=\\\"info\\\"/>\\n    </logger>\\n    <root>\\n        <level value=\\\"debug\\\"/>\\n        <appender-ref ref=\\\"STDOUT\\\"/>\\n    </root>\\n</log4j:configuration>\\n\\n```\\n\\n> **日志的级别**\\n>\\n> FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试) 从左到右打印的内容越来越详细\\n\\n日志效果如下：\\n\\n![image-20220527161432211](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205271614357.png)\\n\\n## 三、核心配置文件详解\\n\\n核心配置文件中的标签必须按照固定的顺序： properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?\\n\\n``` xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE configuration\\n        PUBLIC \\\"-//MyBatis.org//DTD Config 3.0//EN\\\"\\n        \\\"http://MyBatis.org/dtd/MyBatis-3-config.dtd\\\">\\n<configuration>\\n    <!--引入properties文件，此时就可以${属性名}的方式访问属性值-->\\n    <properties resource=\\\"jdbc.properties\\\"></properties>\\n    <settings>\\n        <!--将表中字段的下划线自动转换为驼峰-->\\n        <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/>\\n        <!--开启延迟加载-->\\n        <setting name=\\\"lazyLoadingEnabled\\\" value=\\\"true\\\"/>\\n    </settings>\\n    <typeAliases>\\n        <!--\\n        typeAlias：设置某个具体的类型的别名\\n        属性：\\n        type：需要设置别名的类型的全类名\\n        alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小\\n        写\\n        若设置此属性，此时该类型的别名只能使用alias所设置的值\\n        -->\\n        <!--<typeAlias type=\\\"com.atguigu.mybatis.bean.User\\\"></typeAlias>-->\\n        <!--<typeAlias type=\\\"com.atguigu.mybatis.bean.User\\\" alias=\\\"abc\\\">\\n        </typeAlias>-->\\n        <!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写-->\\n        <package name=\\\"com.atguigu.mybatis.bean\\\"/>\\n    </typeAliases>\\n    <!--\\n    environments：设置多个连接数据库的环境\\n    属性：\\n    default：设置默认使用的环境的id\\n    -->\\n    <environments default=\\\"mysql_test\\\">\\n        <!--\\n        environment：设置具体的连接数据库的环境信息\\n        属性：\\n        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，\\n        表示默认使用的环境\\n        -->\\n        <environment id=\\\"mysql_test\\\">\\n            <!--\\n            transactionManager：设置事务管理方式\\n            属性：\\n            type：设置事务管理方式，type=\\\"JDBC|MANAGED\\\"\\n            type=\\\"JDBC\\\"：设置当前环境的事务管理都必须手动处理\\n            type=\\\"MANAGED\\\"：设置事务被管理，例如spring中的AOP\\n            -->\\n            <transactionManager type=\\\"JDBC\\\"/>\\n            <!--\\n            dataSource：设置数据源\\n            属性：\\n            type：设置数据源的类型，type=\\\"POOLED|UNPOOLED|JNDI\\\"\\n            type=\\\"POOLED\\\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从\\n            缓存中直接获取，不需要重新创建\\n            type=\\\"UNPOOLED\\\"：不使用数据库连接池，即每次使用连接都需要重新创建\\n            type=\\\"JNDI\\\"：调用上下文中的数据源\\n            -->\\n            <dataSource type=\\\"POOLED\\\">\\n                <!--设置驱动类的全类名-->\\n                <property name=\\\"driver\\\" value=\\\"${jdbc.driver}\\\"/>\\n                <!--设置连接数据库的连接地址-->\\n                <property name=\\\"url\\\" value=\\\"${jdbc.url}\\\"/>\\n                <!--设置连接数据库的用户名-->\\n                <property name=\\\"username\\\" value=\\\"${jdbc.username}\\\"/>\\n                <!--设置连接数据库的密码-->\\n                <property name=\\\"password\\\" value=\\\"${jdbc.password}\\\"/>\\n            </dataSource>\\n        </environment>\\n    </environments>\\n    <!--引入映射文件-->\\n    <mappers>\\n        <mapper resource=\\\"UserMapper.xml\\\"/>\\n        <!--\\n        以包为单位，将包下所有的映射文件引入核心配置文件\\n        注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下\\n        -->\\n        <package name=\\\"com.icatw.mybatis.mapper\\\"/>\\n    </mappers>\\n</configuration>\\n```\\n\\n## 四、MyBatis的增删改查\\n\\n增删改大致都差不多\\n\\n1、添加\\n\\n``` xml\\n<!--int insertUser();-->\\n    <insert id=\\\"insertUser\\\">\\n        insert into t_user(username, password, age, sex, email)\\n        values (\'张三\', \'123\', 23, \'女\', \'762188827@qq.com\')\\n    </insert>\\n```\\n\\n2、删除\\n\\n``` xml\\n<!--int deleteUser();-->\\n<delete id=\\\"deleteUser\\\">\\ndelete from t_user where id = 7\\n</delete>\\n```\\n\\n3、修改\\n\\n``` xml\\n<!--int updateUser();-->\\n<update id=\\\"updateUser\\\">\\nupdate t_user set username=\'ybc\',password=\'123\' where id = 6\\n</update>\\n```\\n\\n4、查询一个实体类对象\\n\\n``` xml\\n<select id=\\\"getUserById\\\" resultType=\\\"cn.icatw.mybatis.pojo.User\\\">\\n        select *\\n        from t_user\\n        where id = 3;\\n</select>\\n```\\n\\n5、查询集合\\n\\n``` xml\\n<select id=\\\"getAllUsers\\\" resultType=\\\"cn.icatw.mybatis.pojo.User\\\">\\n   select *\\n   from t_user;\\n</select>\\n```\\n\\n> 注意： \\n>\\n> 1. 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 \\n>\\n>    resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 \\n>\\n> 2. 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值\\n\\n## 五、MyBatis获取参数值的两种方式（重点）\\n\\n**MyBatis获取参数值的两种方式：${}和#{}** \\n\\n**${}的本质就是字符串拼接（会有sql注入的问题），#{}的本质就是占位符赋值** \\n\\n**${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；**\\n\\n**但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号**\\n\\n### 1、单个字面量类型的参数\\n\\n若mapper接口中的方法参数为单个的字面量类型 此时可以使用${}和#{}以任意的名称获取参数的值，**注意${}需要手动加单引号**\\n\\n例如：\\n\\n- #{}\\n\\nUserMapper接口为\\n\\n``` java\\nUser getByUsername(String username);\\n```\\n\\n**对应的xml，这里的#{}内可以为任意字符串**\\n\\n``` xml\\n<select id=\\\"getByUsername\\\" resultType=\\\"User\\\">\\n        select *\\n        from t_user\\n        where username = #{username};\\n    </select>\\n```\\n\\n- ${}\\n\\nUserMapper接口为\\n\\n``` java\\nUser getByUsername(String username);\\n```\\n\\n**对应的xml，这里的${}内可以为任意字符串，但是${}外必须加单引号**\\n\\n``` xml\\n<select id=\\\"getByUsername\\\" resultType=\\\"User\\\">\\n        select *\\n        from t_user\\n        where username = \'${username}\';\\n    </select>\\n```\\n\\n\\n\\n### 2、多个字面量类型的参数\\n\\n若mapper接口中的方法参数为多个时 \\n\\n此时MyBatis会自动将这些参数放在一个map集合中，**以arg0,arg1...为键，以参数为值；以 param1,param2...为键，以参数为值；**因此只需要通过${}和#{}访问map集合的键就可以获取相对应的 值，**注意${}需要手动加单引号**\\n\\n例如：\\n\\nUserMapper接口为\\n\\n``` java\\nUser checkLogin(String username, String password);\\n```\\n\\n对应的xml为\\n\\n``` xml\\n<select id=\\\"checkLogin\\\" resultType=\\\"cn.icatw.mybatis.pojo.User\\\">\\n        select *\\n        from t_user\\n        where username = #{arg0}\\n          and password = #{arg1};\\n    </select>\\n```\\n\\n或者为\\n\\n``` xml\\n<select id=\\\"checkLogin\\\" resultType=\\\"cn.icatw.mybatis.pojo.User\\\">\\n        select *\\n        from t_user\\n        where username = #{param1}\\n          and password = #{param2};\\n    </select>\\n```\\n\\n> 也可以将arg和param混合使用，但是参数位置需要对应\\n>\\n> arg0 -> param2\\n>\\n> param1 -> arg1\\n\\n\\n\\n### 3、map集合类型的参数\\n\\n若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\\n\\n### 4、实体类类型的参数\\n\\n若mapper接口中的方法参数为实体类对象时 \\n\\n此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号\\n\\n### 5、使用@Param标识参数 \\n\\n可以通过@Param注解标识mapper接口中的方法参数 此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以 param1,param2...为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值， 注意${}需要手动加单引号\\n\\n## 六、MyBatis的各种查询功能\\n\\n### 1、查询一个实体类对象\\n\\n``` java\\n/**\\n* 根据用户id查询用户信息\\n* @param id\\n* @return\\n*/\\nUser getUserById(@Param(\\\"id\\\") int id);\\n```\\n\\n``` xml\\n<!--User getUserById(@Param(\\\"id\\\") int id);-->\\n<select id=\\\"getUserById\\\" resultType=\\\"User\\\">\\nselect * from t_user where id = #{id}\\n</select>\\n```\\n\\n### 2、查询一个list集合\\n\\n``` java\\n/**\\n* 查询所有用户信息\\n* @return\\n*/\\nList<User> getUserList();\\n```\\n\\n``` xml\\n<!--List<User> getUserList();-->\\n<select id=\\\"getUserList\\\" resultType=\\\"User\\\">\\nselect * from t_user\\n</select>\\n```\\n\\n### 3、查询单个数据\\n\\n``` java\\n/**\\n* 查询用户的总记录数\\n* @return\\n* 在MyBatis中，对于Java中常用的类型都设置了类型别名\\n* 例如：java.lang.Integer-->int|integer\\n* 例如：int-->_int|_integer\\n* 例如：Map-->map,List-->list\\n*/\\nint getCount();\\n```\\n\\n``` xml\\n<!--int getCount();-->\\n<select id=\\\"getCount\\\" resultType=\\\"_integer\\\">\\nselect count(id) from t_user\\n</select>\\n```\\n\\n### 4、查询一条数据为map集合\\n\\n``` java\\n/**\\n* 根据用户id查询用户信息为map集合\\n* @param id\\n* @return\\n*/\\nMap<String, Object> getUserToMap(@Param(\\\"id\\\") int id);\\n```\\n\\n``` xml\\n<!--Map<String, Object> getUserToMap(@Param(\\\"id\\\") int id);-->\\n<select id=\\\"getUserToMap\\\" resultType=\\\"map\\\">\\nselect * from t_user where id = #{id}\\n</select>\\n<!--结果：{password=123456, sex=男, id=1, age=23, username=admin}-->\\n```\\n\\n### 5、查询多条数据为map集合\\n\\n方式一：\\n\\n``` java\\n/**\\n* 查询所有用户信息为map集合\\n* @return\\n* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此\\n时可以将这些map放在一个list集合中获取\\n*/\\nList<Map<String, Object>> getAllUserToMap();\\n```\\n\\n```xml\\n<!--Map<String, Object> getAllUserToMap();-->\\n<select id=\\\"getAllUserToMap\\\" resultType=\\\"map\\\">\\nselect * from t_user\\n</select>\\n```\\n\\n方式二：\\n\\n``` java\\n/**\\n* 查询所有用户信息为map集合\\n* @return\\n* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并\\n且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的\\nmap集合\\n*/\\n@MapKey(\\\"id\\\")\\nMap<String, Object> getAllUserToMap();\\n```\\n\\n``` xml\\n<!--Map<String, Object> getAllUserToMap();-->\\n<select id=\\\"getAllUserToMap\\\" resultType=\\\"map\\\">\\nselect * from t_user\\n</select>\\n结果：\\n<!--\\n{\\n1={password=123456, sex=男, id=1, age=23, username=admin},\\n2={password=123456, sex=男, id=2, age=23, username=张三},\\n3={password=123456, sex=男, id=3, age=23, username=张三}\\n}\\n-->\\n```\\n\\n## 七、特殊SQL的执行\\n\\n### 1、模糊查询\\n\\n``` java\\n/**\\n* 测试模糊查询\\n* @param mohu\\n* @return\\n*/\\nList<User> testMohu(@Param(\\\"mohu\\\") String mohu);\\n```\\n\\n``` xml\\n<!--List<User> testMohu(@Param(\\\"mohu\\\") String mohu);-->\\n<select id=\\\"testMohu\\\" resultType=\\\"User\\\">\\n<!--select * from t_user where username like \'%${mohu}%\'-->\\n<!--select * from t_user where username like concat(\'%\',#{mohu},\'%\')-->\\nselect * from t_user where username like \\\"%\\\"#{mohu}\\\"%\\\"\\n</select>\\n```\\n\\n### 2、批量删除\\n\\n``` java\\n/**\\n* 批量删除\\n* @param ids\\n* @return\\n*/\\nint deleteMore(@Param(\\\"ids\\\") String ids);\\n```\\n\\n```` xml\\n<!--int deleteMore(@Param(\\\"ids\\\") String ids);-->\\n<delete id=\\\"deleteMore\\\">\\ndelete from t_user where id in (${ids})\\n</delete>\\n````\\n\\n### 3、动态设置表名\\n\\n``` java\\n/**\\n* 动态设置表名，查询所有的用户信息\\n* @param tableName\\n* @return\\n*/\\nList<User> getAllUser(@Param(\\\"tableName\\\") String tableName);\\n```\\n\\n``` xml\\n<!--List<User> getAllUser(@Param(\\\"tableName\\\") String tableName);-->\\n<select id=\\\"getAllUser\\\" resultType=\\\"User\\\">\\nselect * from ${tableName}\\n</select>\\n```\\n\\n### 4、添加功能获取自增的主键\\n\\nt_clazz(clazz_id,clazz_name) \\n\\nt_student(student_id,student_name,clazz_id) \\n\\n1、添加班级信息 \\n\\n2、获取新添加的班级的id \\n\\n3、为班级分配学生，即将某学的班级id修改为新添加的班级的id\\n\\n``` java\\n/**\\n* 添加用户信息\\n* @param user\\n* @return\\n* useGeneratedKeys：设置使用自增的主键\\n* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参\\n数user对象的某个属性中\\n*/\\nint insertUser(User user);\\n```\\n\\n``` xml\\n<!--int insertUser(User user);-->\\n<insert id=\\\"insertUser\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\">\\ninsert into t_user values(null,#{username},#{password},#{age},#{sex})\\n</insert>\\n```\\n\\n## 八、自定义映射resultMap\\n\\n### 1、resultMap处理字段和属性的映射关系\\n\\n若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射\\n\\n``` xml\\n    <!--\\n    resultMap：设置自定义映射\\n    属性：\\n    id：表示自定义映射的唯一标识\\n    type：查询的数据要映射的实体类的类型\\n    子标签：\\n    id：设置主键的映射关系\\n    result：设置普通字段的映射关系\\n    association：设置多对一的映射关系\\n    collection：设置一对多的映射关系\\n    属性：\\n    property：设置映射关系中实体类中的属性名\\n    column：设置映射关系中表中的字段名\\n    -->\\n    <resultMap id=\\\"userMap\\\" type=\\\"User\\\">\\n        <id property=\\\"id\\\" column=\\\"id\\\"></id>\\n        <result property=\\\"userName\\\" column=\\\"user_name\\\"></result>\\n        <result property=\\\"password\\\" column=\\\"password\\\"></result>\\n        <result property=\\\"age\\\" column=\\\"age\\\"></result>\\n        <result property=\\\"sex\\\" column=\\\"sex\\\"></result>\\n    </resultMap>\\n    <!--List<User> testMohu(@Param(\\\"mohu\\\") String mohu);-->\\n    <select id=\\\"testMohu\\\" resultMap=\\\"userMap\\\">\\n        <!--select * from t_user where username like \'%${mohu}%\'-->\\n        select id,user_name,password,age,sex from t_user where user_name like\\n        concat(\'%\',#{mohu},\'%\')\\n    </select>\\n```\\n\\n### 2、多对一映射处理\\n\\n> 根据员工id查询员工信息以及员工所对应的部门信息\\n\\n- **级联方式处理映射关系**\\n\\n首先编写SQL语句\\n\\n``` sql\\n     select *\\n        from t_emp emp,\\n             t_dept dept\\n        where emp.did = dept.did\\n          and emp.eid = 1;\\n```\\n\\n查询结果为\\n\\n![image-20220528114839064](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205281148144.png)\\n\\n要建立员工与部门一对多的映射关系需要在员工实体中添加部门属性\\n\\n``` java\\n@ToString\\n@Data\\npublic class Emp implements Serializable {\\n    private static final long serialVersionUID = -33707633162257748L;\\n\\n    private Integer eid;\\n\\n    private String empName;\\n\\n    private Integer age;\\n\\n    private String sex;\\n\\n    private String email;\\n    \\n    private Dept dept;\\n\\n}\\n```\\n\\n之后再通过resultMap映射\\n\\n``` xml\\n<resultMap id=\\\"empAndDeptResultMapOne\\\" type=\\\"emp\\\">\\n        <id property=\\\"eid\\\" column=\\\"eid\\\"/>\\n        <result property=\\\"empName\\\" column=\\\"emp_name\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <result property=\\\"age\\\" column=\\\"age\\\" jdbcType=\\\"INTEGER\\\"/>\\n        <result property=\\\"sex\\\" column=\\\"sex\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <result property=\\\"email\\\" column=\\\"email\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <result property=\\\"dept.did\\\" column=\\\"did\\\" jdbcType=\\\"INTEGER\\\"/>\\n        <result property=\\\"dept.deptName\\\" column=\\\"dept_name\\\"/>\\n    </resultMap>\\n```\\n\\n``` xml\\n <select id=\\\"getEmpAndDept\\\" resultMap=\\\"empAndDeptResultMapOne\\\">\\n        select *\\n        from t_emp emp,\\n             t_dept dept\\n        where emp.did = dept.did\\n          and emp.eid = #{eid};\\n    </select>\\n```\\n\\n- **使用association处理映射关系**\\n\\n``` xml\\n    <resultMap id=\\\"empAndDeptResultMapTwo\\\" type=\\\"emp\\\">\\n        <id property=\\\"eid\\\" column=\\\"eid\\\"/>\\n        <result property=\\\"empName\\\" column=\\\"emp_name\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <result property=\\\"age\\\" column=\\\"age\\\" jdbcType=\\\"INTEGER\\\"/>\\n        <result property=\\\"sex\\\" column=\\\"sex\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <result property=\\\"email\\\" column=\\\"email\\\" jdbcType=\\\"VARCHAR\\\"/>\\n        <association property=\\\"dept\\\" javaType=\\\"dept\\\">\\n            <id property=\\\"did\\\" column=\\\"did\\\"/>\\n            <result property=\\\"deptName\\\" column=\\\"dept_name\\\"/>\\n        </association>\\n    </resultMap>\\n```\\n\\n- 分步查询\\n\\n1）查询员工信息\\n\\n``` java\\n/**\\n* 通过分步查询查询员工信息\\n* @param eid\\n* @return\\n*/\\nEmp getEmpByStep(@Param(\\\"eid\\\") int eid);\\n```\\n\\n``` xml\\n    <resultMap id=\\\"empDeptStepMap\\\" type=\\\"Emp\\\">\\n        <id column=\\\"eid\\\" property=\\\"eid\\\"></id>\\n        <result column=\\\"ename\\\" property=\\\"ename\\\"></result>\\n        <result column=\\\"age\\\" property=\\\"age\\\"></result>\\n        <result column=\\\"sex\\\" property=\\\"sex\\\"></result>\\n        <!--\\n        select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）\\n        column：将sql以及查询结果中的某个字段设置为分步查询的条件，将其传入select的参数\\n        -->\\n        <association property=\\\"dept\\\"\\n                     select=\\\"com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep\\\" column=\\\"did\\\">\\n        </association>\\n    </resultMap>\\n    <!--Emp getEmpByStep(@Param(\\\"eid\\\") int eid);-->\\n    <select id=\\\"getEmpByStep\\\" resultMap=\\\"empDeptStepMap\\\">\\n        select *\\n        from t_emp\\n        where eid = #{eid}\\n    </select>\\n```\\n\\n2）根据员工所对应的部门id查询部门信息\\n\\n``` java\\n/**\\n* 分步查询的第二步：根据员工所对应的did查询部门信息\\n* @param did\\n* @return\\n*/\\nDept getEmpDeptByStep(@Param(\\\"did\\\") int did);\\n```\\n\\n```  xml\\n    <!--Dept getEmpDeptByStep(@Param(\\\"did\\\") int did);-->\\n    <select id=\\\"getEmpDeptByStep\\\" resultType=\\\"Dept\\\">\\n        select *\\n        from t_dept\\n        where did = #{did}\\n    </select>\\n```\\n\\n\\n\\n### 3、一对多映射处理\\n\\n- collection\\n\\n首先修改部门实体\\n\\n``` java\\n/**\\n * (TDept)实体类\\n *\\n * @author icatw\\n * @since 2022-05-27 19:48:39\\n */\\n@Data\\n@ToString\\npublic class Dept implements Serializable {\\n    private static final long serialVersionUID = -53974633969964494L;\\n\\n    private Integer did;\\n\\n    private String deptName;\\n    private List<Emp> emps;\\n\\n}\\n```\\n\\n\\n\\n``` java\\n/**\\n* 根据部门id查新部门以及部门中的员工信息\\n* @param did\\n* @return\\n*/\\nDept getDeptEmpByDid(@Param(\\\"did\\\") int did);\\n```\\n\\n```  xml\\n<resultMap id=\\\"deptEmpMap\\\" type=\\\"dept\\\">\\n        <id property=\\\"did\\\" column=\\\"did\\\"/>\\n        <result property=\\\"deptName\\\" column=\\\"dept_name\\\"/>\\n        <collection property=\\\"emps\\\" ofType=\\\"emp\\\">\\n            <id property=\\\"eid\\\" column=\\\"eid\\\"/>\\n            <result property=\\\"empName\\\" column=\\\"emp_name\\\"/>\\n            <result property=\\\"age\\\" column=\\\"age\\\"/>\\n            <result property=\\\"sex\\\" column=\\\"sex\\\"/>\\n            <result property=\\\"email\\\" column=\\\"email\\\"/>\\n        </collection>\\n    </resultMap>\\n    <select id=\\\"getDeptEmpByDid\\\" resultMap=\\\"deptEmpMap\\\">\\n        select d.*, e.*\\n        from t_emp e,\\n             t_dept d\\n        where e.did = d.did\\n          and d.did = #{did};\\n    </select>\\n```\\n\\n![image-20220528144644567](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205281446649.png)\\n\\n- 分步查询\\n\\n1）查询部门信息\\n\\n``` java\\n/**\\n* 分步查询部门和部门中的员工\\n* @param did\\n* @return\\n*/\\nDept getDeptByStep(@Param(\\\"did\\\") int did);\\n```\\n\\n``` xml\\n<resultMap id=\\\"deptEmpStep\\\" type=\\\"dept\\\">\\n        <id property=\\\"did\\\" column=\\\"did\\\"/>\\n        <result property=\\\"deptName\\\" column=\\\"dept_name\\\"/>\\n        <collection property=\\\"emps\\\" select=\\\"cn.icatw.mybatis.mapper.EmpDao.getEmpListByDid\\\" column=\\\"did\\\"/>\\n    </resultMap>\\n <select id=\\\"getDeptByStep\\\" resultMap=\\\"deptEmpStep\\\">\\n        select *\\n        from t_dept\\n        where did = #{did};\\n    </select>\\n```\\n\\n2）查询部门员工信息\\n\\n``` java\\n    /**\\n     * 根据部门id查询员工信息\\n     *\\n     * @param did\\n     * @return\\n     */\\n    List<Emp> getEmpListByDid(@Param(\\\"did\\\") int did);\\n```\\n\\n``` xml\\n    <select id=\\\"getEmpListByDid\\\" resultType=\\\"cn.icatw.mybatis.entity.Emp\\\">\\n        select *\\n        from t_emp where did=#{did};\\n    </select>\\n```\\n\\n> 　　分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： \\n>\\n> 　lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 \\n>\\n> 　aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个 属性会按需加载 \\n>\\n> 　此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=\\\"lazy(延迟加 载)|eager(立即加载)\\\"\\n\\n## 九、动态SQL\\n\\nMybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。\\n\\n### 1、if\\n\\nif标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中 的内容不会执行\\n\\n``` xml\\n    <!--List<Emp> getEmpListByMoreTJ(Emp emp);-->\\n    <select id=\\\"getEmpListByMoreTJ\\\" resultType=\\\"Emp\\\">\\n        select * from t_emp where 1=1\\n        <if test=\\\"ename != \'\' and ename != null\\\">\\n            and ename = #{ename}\\n        </if>\\n        <if test=\\\"age != \'\' and age != null\\\">\\n            and age = #{age}\\n        </if>\\n        <if test=\\\"sex != \'\' and sex != null\\\">\\n            and sex = #{sex}\\n        </if>\\n    </select>\\n```\\n\\n### 2、where\\n\\n``` xml\\n    <select id=\\\"getEmpListByMoreTJ2\\\" resultType=\\\"Emp\\\">\\n        select * from t_emp\\n        <where>\\n            <if test=\\\"ename != \'\' and ename != null\\\">\\n                ename = #{ename}\\n            </if>\\n            <if test=\\\"age != \'\' and age != null\\\">\\n                and age = #{age}\\n            </if>\\n            <if test=\\\"sex != \'\' and sex != null\\\">\\n                and sex = #{sex}\\n            </if>\\n        </where>\\n    </select>\\n```\\n\\n> where和if一般结合使用： \\n>\\n> a>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 \\n>\\n> b>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉 **注意：where标签不能去掉条件最后多余的and**\\n\\n### 3、trim\\n\\n``` xml-dtd\\n    <select id=\\\"getEmpListByMoreTJ\\\" resultType=\\\"Emp\\\">\\n        select * from t_emp\\n        <trim prefix=\\\"where\\\" suffixOverrides=\\\"and\\\">\\n            <if test=\\\"ename != \'\' and ename != null\\\">\\n                ename = #{ename} and\\n            </if>\\n            <if test=\\\"age != \'\' and age != null\\\">\\n                age = #{age} and\\n            </if>\\n            <if test=\\\"sex != \'\' and sex != null\\\">\\n                sex = #{sex}\\n            </if>\\n        </trim>\\n    </select>\\n```\\n\\n>trim用于去掉或添加标签中的内容 \\n>\\n>常用属性： \\n>\\n>prefix：在trim标签中的内容的前面添加某些内容 \\n>\\n>prefixOverrides：在trim标签中的内容的前面去掉某些内容 \\n>\\n>suffix：在trim标签中的内容的后面添加某些内容 \\n>\\n>suffixOverrides：在trim标签中的内容的后面去掉某些内容\\n\\n### 4、choose、when、otherwise\\n\\nchoose、when、otherwise相当于if...else if..else\\n\\n``` java\\n    <!--List<Emp> getEmpListByChoose(Emp emp);-->\\n    <select id=\\\"getEmpListByChoose\\\" resultType=\\\"Emp\\\">\\n        select <include refid=\\\"empColumns\\\"></include> from t_emp\\n        <where>\\n            <choose>\\n                <when test=\\\"ename != \'\' and ename != null\\\">\\n                    ename = #{ename}\\n                </when>\\n                <when test=\\\"age != \'\' and age != null\\\">\\n                    age = #{age}\\n                </when>\\n                <when test=\\\"sex != \'\' and sex != null\\\">\\n                    sex = #{sex}\\n                </when>\\n                <when test=\\\"email != \'\' and email != null\\\">\\n                    email = #{email}\\n                </when>\\n            </choose>\\n        </where>\\n    </select>\\n```\\n\\n### 5、foreach\\n\\n``` xml\\n    <!--int insertMoreEmp(List<Emp> emps);-->\\n    <insert id=\\\"insertMoreEmp\\\">\\n        insert into t_emp values\\n        <foreach collection=\\\"emps\\\" item=\\\"emp\\\" separator=\\\",\\\">\\n            (null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)\\n        </foreach>\\n    </insert>\\n    <!--int deleteMoreByArray(int[] eids);-->\\n    <delete id=\\\"deleteMoreByArray\\\">\\n        delete from t_emp where\\n        <foreach collection=\\\"eids\\\" item=\\\"eid\\\" separator=\\\"or\\\">\\n            eid = #{eid}\\n        </foreach>\\n    </delete>\\n    <!--int deleteMoreByArray(int[] eids);-->\\n    <delete id=\\\"deleteMoreByArray\\\">\\n        delete from t_emp where eid in\\n        <foreach collection=\\\"eids\\\" item=\\\"eid\\\" separator=\\\",\\\" open=\\\"(\\\" close=\\\")\\\">\\n            #{eid}\\n        </foreach>\\n    </delete>\\n```\\n\\n> 属性： \\n>\\n> collection：设置要循环的数组或集合 \\n>\\n> item：表示集合或数组中的每一个数据 \\n>\\n> separator：设置循环体之间的分隔符 \\n>\\n> open：设置foreach标签中的内容的开始符 \\n>\\n> close：设置foreach标签中的内容的结束符\\n\\n### 6、SQL片段\\n\\nsql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入\\n\\n``` xml\\n<sql id=\\\"empColumns\\\">\\neid,ename,age,sex,did\\n</sql>\\nselect <include refid=\\\"empColumns\\\"></include> from t_emp\\n```\\n\\n## 十、MyBatis的缓存\\n\\n### 1、MyBatis的一级缓存\\n\\n一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就 会从缓存中直接获取，不会从数据库重新访问 \\n\\n使一级缓存失效的四种情况： \\n\\n-  不同的SqlSession对应不同的一级缓存 \\n-  同一个SqlSession但是查询条件不同 \\n-  同一个SqlSession两次查询期间执行了任何一次增删改操作 \\n-  同一个SqlSession两次查询期间手动清空了缓存\\n\\n### 2、MyBatis的二级缓存\\n\\n二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 \\n\\n二级缓存开启的条件： \\n\\na>在核心配置文件中，设置全局配置属性`cacheEnabled=\\\"true\\\"`，默认为true，不需要设置 \\n\\nb>在映射文件中设置标签 `<cache/>`\\n\\nc>二级缓存必须在SqlSession关闭或提交之后有效 \\n\\nd>查询的数据所转换的实体类类型必须实现序列化的接口 \\n\\n使二级缓存失效的情况： \\n\\n两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\\n\\n### 3、二级缓存的相关配置\\n\\n在mapper配置文件中添加的cache标签可以设置一些属性： \\n\\n- eviction属性：缓存回收策略 \\n\\n  - LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 \\n  - FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 \\n  - SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 \\n  - WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。 \\n\\n- flushInterval属性：刷新间隔，单位毫秒 \\n\\n  默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 \\n\\n- size属性：引用数目，正整数 \\n\\n  代表缓存最多可以存储多少个对象，太大容易导致内存溢出 \\n\\n- readOnly属性：只读，true/false \\n\\n  true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。 \\n\\n  false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。\\n\\n### 4、MyBatis缓存查询的顺序\\n\\n- 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 \\n- 如果二级缓存没有命中，再查询一级缓存 \\n- 如果一级缓存也没有命中，则查询数据库 \\n- SqlSession关闭之后，一级缓存中的数据会写入二级缓存\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/b91897a77cb0bb9bca9f7c2b50e161d2.jpg\",\"articleTitle\":\"mybatis学习笔记\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"mybatis\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-05-28 15:21:36',NULL),(1202,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# servlet生命周期\\n\\n> 今天在面试时被问到了servlet生命周期，只回答出一个初始化....因此特地写篇博客记录一下(2022/6/8)\\n\\n## 与servlet生命周期有关的方法\\n\\n**与servlet生命周期有关的方法一般有以下三个**：\\n\\n1. **init()方法**\\n\\ninit()方法是在创建servlet对象时被调用，而且只能被调用一次，用于servlet对象在整个生命周期内的唯一一次初始化。只有在init()方法调用成功后，servlet才会处于服务状态，才能够去处理客户端的请求。\\n\\n2. **service()方法**\\n\\nservice()方法是servlet工作的核心方法。当客户端请求访问servlet时，servlet容器就会调用service方法去处理来自客户端的请求，并把处理后的响应返回给客户端。\\n\\n3. **destroy()方法**\\n\\ndestroy()方法是servlet容器回收servlet对象之前调用的，且只会调用一次，而此时的服务器处于停止状态或者访问资源以及被移除。\\n\\n## Servlet生命周期(三个阶段)\\n\\nservlet生命周期大概流程可以用下图来诠释。\\n\\n![servlet生命周期示意图](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206081950424.png)\\n\\n此图描述了servlet的完整生命周期，按照功能的不同，**大致可以将servlet的生命周期分为三个阶段，分别是初始化阶段、运行阶段和销毁阶段。**\\n\\n1. 初始化阶段\\n\\n   当用户第一次向Servlet容器发出HTTP请求要求访问某个Servlet时，Servlet容器会在整个容器中搜索该Servlet对象，发现这个Servlet对象没有被实例化，于是创建这个Servlet对象，然后调用该对象的init()方法完成初始化。\\n\\n   <br>\\n\\n   当用户第二次访问这个Servlet时，Servlet容器仍然在容器中搜索该Servlet对象，结果找到了该对象的实例，则不去创建而直接使用该对象。\\n\\n   <br>\\n\\n   找到了对应的Servlet对象，随后Servlet进入到运行阶段。\\n\\n   <br>\\n\\n   **需要注意的是，在Servlet的整个生命周期内，它的init()方法只被调用一次。**\\n\\n2. 运行阶段\\n\\n   这是Servlet生命周期中最核心的阶段。在该阶段中，Servlet容器会为当前的请求创建一个ServletRequest对象和一个ServletResponse对象（它们分别对应HTTP请求和HTTP响应），并将这两个对象作为参数传递给Servlet的service()方法。\\n\\n   <br>\\n\\n   service()方法从ServletRequest对象中获得用户的详细请求信息并处理该请求，通过ServletResponse对象生成响应结果。\\n\\n   <br>\\n\\n   **需要强调的是，在Servlet的整个生命周期内，用户每次访问Servlet时，Servlet容器都会调用一次Servlet的service()方法，并且创建新的ServletRequest和ServletResponse对象。**\\n\\n3. 销毁阶段\\n\\n   当服务器停止是，Servlet容器需要回收Servlet对象所占用的内存，在回收之前，会自动调用该对象的destroy()方法做好回收内存前的准备，譬如关闭后台线程。\\n\\n   <br>\\n\\n   和init()方法类似，destroy()方法也只会被调用一次。\\n\\n   <br>\\n\\n   **注意：Servlet对象一旦创建就会驻留在内存中一直等待客户端的访问，直到服务器关闭或项目被移出容器时，Servlet对象才会被销毁。**\\n\\n## 总结\\n\\n对Servlet声明周期的几点汇总：\\n\\n1. Servlet对象被创建之后执行init()方法，并且init()方法只执行一次，其主要目的是完成Servlet对象的初始化工作。\\n2. 对于Servlet对象的service()方法，只要用户请求一次，那么service()方法就会执行一次。\\n3. Servlet对象被回收之前，destroy()方法会被调用，该方法只执行一次，执行的时候Servlet对象还在。\\n\\nServlet 对象的创建、对象提供服务、对象的销毁等操作皆由 Servlet 容器来管理，Java 程序员的任务只是负责编写 Servlet 类，无法干涉 Servlet 对象的生命周期。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d503e8958ff03839702dbce6d0b563fe.jpg\",\"articleTitle\":\"Servlet生命周期\",\"categoryName\":\"Java面经\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-08 20:15:14',NULL),(1203,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Java多线程：实现多线程的几种方式以及对比\\n\\n## 前言\\n\\nJava多线程的使用有三种方法：继承Thread类、实现Runnable接口和使用Callable和Future创建线程，本文将对这三种方法一一进行介绍。\\n\\n## 1、继承Thread类\\n\\n实现方式很简单，只需要创建一个类去继续Thread类然后重写run方法，在main中调用该类实例对象的start方法即可实现多线程并发。代码：\\n\\n``` java\\npublic class MyThread extends Thread{\\n    @Override\\n    public void run(){\\n        super.run();\\n        System.out.println(\\\"执行子线程...\\\");\\n    }\\n}\\n```\\n\\n测试用例：\\n\\n``` java\\npublic class Test {\\n    public static void main(String[] args) {\\n        MyThread myThread = new MyThread();\\n        myThread.start();\\n        System.out.println(\\\"主线程...\\\");\\n    }\\n}\\n```\\n\\n这里的结果不代表线程的执行顺序，线程是并发执行的，如果多运行几次，打印顺序可能会不一样。多线程的运行过程中，CPU是以不确定的方式去执行线程的，故运行结果与代码的执行顺序或者调用顺序无关，运行结果也可能不一样。\\n\\n这里还有一个需要注意的点就是main方法中应该调用的是myThread的start方法，而不是run()方法。调用start()方法是告诉CPU此线程已经准备就绪可以执行，进而系统有时间就会来执行其run()方法。而直接调用run()方法，则不是异步执行，而是等同于调用函数般按顺序同步执行，这就失去了多线程的意义了。\\n\\n## 2、实现Runnable接口\\n\\n这种方式的实现也很简单，就是把继承Thread类改为实现Runnable接口。代码如下：\\n\\n``` java\\npublic class MyRunnable implements Runnable {\\n    @Override\\n    public void run() {\\n        System.out.println(\\\"执行子线程...\\\");\\n    }\\n}\\n```\\n\\n测试用例：\\n\\n``` java\\npublic class Test {\\n    public static void main(String[] args) {\\n\\n        Runnable runnable = new MyRunnable();\\n        Thread thread = new Thread(runnable);\\n        thread.start();\\n        System.out.println(\\\"主线程运行结束!\\\");\\n    }\\n}\\n```\\n\\n这里main中可以看到真正创建新线程还是通过Thread创建：\\n\\n``` java\\nThread thread = new Thread(runnable);\\n```\\n\\n这一步Thread类的作用就是把run()方法包装成线程执行体，然后依然通过start去告诉系统这个线程已经准备好了可以安排执行。\\n\\n## 3、使用Callable和Future创建线程\\n\\n上面的两种方式都有这两个问题：\\n\\n1. 无法获取子线程的返回值\\n2. run方法不可以抛出异常\\n\\n为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。\\n\\n\\n\\n所以这里面其实就是要比上一个方法再多一个转换过程，最终一样是通过Thread的start来创建新线程。有了这个思路，代码就很容易理解了：\\n\\n``` java\\nimport java.util.concurrent.Callable;\\n\\npublic class MyCallable implements Callable {\\n    int i = 0;\\n    @Override\\n    public Object call() throws Exception {\\n        System.out.println(Thread.currentThread().getName()+\\\"  i的值：\\\"+ i);\\n        return i++; //call方法可以有返回值\\n    }\\n}\\n```\\n\\n测试：\\n\\n``` java\\nimport java.util.concurrent.Callable;\\nimport java.util.concurrent.FutureTask;\\n\\npublic class Test {\\n    public static void main(String[] args) {\\n        Callable callable = new MyCallable();\\n        for (int i = 0; i < 10; i++) {\\n            FutureTask task = new FutureTask(callable);\\n            new Thread(task,\\\"子线程\\\"+ i).start();\\n            try {\\n                //获取子线程的返回值\\n                System.out.println(\\\"子线程返回值：\\\"+task.get() + \\\"\\\\n\\\");\\n            }  catch (Exception e) {\\n                e.printStackTrace();\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## 4、三种方式的对比\\n\\n### 第一种和后面两种的对比：\\n\\n1、通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换\\n2、但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。\\n\\n### 第二种和第三种方式对比：\\n\\n1、同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换\\n2、第三种方法有两个优点：有返回值、可以抛出异常\\n\\n### 总结\\n\\n实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。\\n而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ebbeff20471e191c716a658e6adf435b.jpg\",\"articleTitle\":\"Java多线程：实现多线程的几种方式以及对比\",\"categoryName\":\"Java面经\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-08 21:45:01',NULL),(1204,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Spring Mvc流程\\n\\n## Spring Mvc流程\\n\\n![image-20220608233015981](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206082330104.png)\\n\\n1、 用户发送请求至前端控制器DispatcherServlet。\\n\\n2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 \\n\\n3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 \\n\\n4、 DispatcherServlet调用HandlerAdapter处理器适配器。 \\n\\n5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\\n\\n6、 Controller执行完成返回ModelAndView。 \\n\\n7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 \\n\\n8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 \\n\\n9、 ViewReslover解析后返回具体View。 \\n\\n10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\\n\\n11、DispatcherServlet响应用户。\\n\\n**组件说明：**\\n\\n以下组件通常使用框架提供实现： \\n\\nDispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件 之间的耦合性，提高每个组件的扩展性。 \\n\\nHandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方 式，注解方式等。 \\n\\nHandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 \\n\\nViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、 excel等。\\n\\n**组件：**\\n\\n**1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供** \\n\\n作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间 的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 \\n\\n**2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供** \\n\\n作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同 的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 \\n\\n**3、处理器适配器HandlerAdapter** \\n\\n作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的 处理器进行执行。 \\n\\n**4、处理器Handler(需要工程师开发)** \\n\\n**注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler** Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具 体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 \\n\\n**5、视图解析器View resolver(不需要工程师开发),由框架提供** \\n\\n作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即 具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务 需求开发具体的页面。 \\n\\n**6、视图View(需要工程师开发jsp...)** \\n\\nView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\\n\\n**核心架构的具体流程步骤如下：** \\n\\n1、首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给 其他的解析器进行处理，作为统一访问点，进行全局的流程控制； \\n\\n2、DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\\n\\n3、DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支 持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； \\n\\n4、HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真 正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视 图名）； \\n\\n5、ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术； \\n\\n6、View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数 据结构，因此很容易支持其他视图技术； \\n\\n7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\\n\\n\\n\\n下边两个组件通常情况下需要开发： \\n\\nHandler：处理器，即后端控制器用controller表示。 \\n\\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\\n\\n## 传统MVC\\n\\n**MVC：MVC是一种设计模式**\\n\\nMVC的原理图：\\n\\n![image-20220609001723558](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090017631.png)\\n\\n**分析：** \\n\\nM-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） \\n\\nV-View 视图（做界面的展示 jsp，html……） \\n\\nC-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/229d09f7e3a48762b63f384357753681.jpg\",\"articleTitle\":\"Spring Mvc流程\",\"categoryName\":\"Java面经\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"springmvc\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-09 00:19:07',NULL),(1205,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 快速排序算法（Java实现）\\n\\n## 算法思路\\n\\n> 参考b站教程 [动画教程](https://www.bilibili.com/video/BV1at411T75o?spm_id_from=333.337.search-card.all.click)\\n\\n分治思想\\n\\n1. 选定key作为中心轴（一般选取第一个）\\n2. 将大于key的数字放在key的右边\\n3. 将小于key的数字放在key的左边\\n4. 分别对左右子序列重复前三步操作\\n\\n``` java\\npublic class QuickSort {\\n    private int[] array;\\n    public QuickSort(int[] array) {\\n        this.array = array;\\n    }\\n    public void sort() {\\n        quickSort(array, 0, array.length - 1);\\n    }\\n    public void print() {\\n        for (int i = 0; i < array.length; i++) {\\n            System.out.println(array[i]);\\n        }\\n    }\\n   \\n    /**\\n     * 递归排序\\n     * @param src\\n     * @param begin\\n     * @param end\\n     */\\n    private void quickSort(int[] src, int begin, int end) {\\n        if (begin < end) {\\n            int key = src[begin];\\n            int i = begin;\\n            int j = end;\\n            while (i < j) {\\n                while (i < j && src[j] > key) {\\n                    j--;\\n                }\\n                if (i < j) {\\n                    src[i] = src[j];\\n                    i++;\\n                }\\n                while (i < j && src[i] < key) {\\n                    i++;\\n                }\\n                if (i < j) {\\n                    src[j] = src[i];\\n                    j--;\\n                }\\n            }\\n            src[i] = key;\\n            quickSort(src, begin, i - 1);\\n            quickSort(src, i + 1, end);\\n        }\\n    }\\n}\\n```\\n\\n测试代码：\\n\\n``` java\\npublic class SortTest {\\n    public static void main(String[] args) {\\n        testQuickSort();\\n\\n    } \\n    /**\\n     * 快速排序\\n     */\\n    private static void testQuickSort() {\\n        int[] array = {5, 9, 1, 9, 5, 3, 7, 6, 1};\\n        QuickSort quickSort = new QuickSort(array);\\n        quickSort.sort();\\n        quickSort.print();\\n    }\\n}\\n```\\n\\n结果：\\n\\n![image-20220609092349619](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090923880.png)\\n\\n## 特点及性能\\n\\n快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。\\n\\n但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 `O(n2)`，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 `O(nlogn)`，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。\\n\\n快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。\\n\\n快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。\\n\\n**快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。**\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e6e6bce2d43cbe793a3097b931d0aaaf.jpg\",\"articleTitle\":\"快速排序算法（Java实现）\",\"categoryName\":\"数据结构算法\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-09 09:26:02',NULL),(1206,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 快速排序算法（Java实现）\\n\\n## 算法思路\\n\\n> 参考b站教程 [动画教程](https://www.bilibili.com/video/BV1at411T75o?spm_id_from=333.337.search-card.all.click)\\n\\n分治思想\\n\\n1. 选定key作为中心轴（一般选取第一个）\\n2. 将大于key的数字放在key的右边\\n3. 将小于key的数字放在key的左边\\n4. 分别对左右子序列重复前三步操作\\n\\n``` java\\npublic class QuickSort {\\n    private int[] array;\\n    public QuickSort(int[] array) {\\n        this.array = array;\\n    }\\n    public void sort() {\\n        quickSort(array, 0, array.length - 1);\\n    }\\n    public void print() {\\n        for (int i = 0; i < array.length; i++) {\\n            System.out.println(array[i]);\\n        }\\n    }\\n   \\nprivate void quickSort(int[] src, int begin, int end) {\\n        if (begin < end) {\\n            //第一次排序将第一个元素指定为key\\n            int key = src[begin];\\n            //指定i为开始下标\\n            //j为结束下标\\n            int i = begin;\\n            int j = end;\\n            // 从右向左找小于key的数来填s[i]\\n            while (i < j) {\\n                //如果最后的值比key大的话，j--，结束下标-1\\n                // 从右向左找小于x的数来填s[i]\\n                while (i < j && src[j] > key) {\\n                    j--;\\n                }\\n                if (i < j) {\\n                    //将s[j]填到s[i]中，s[j]就形成了一个新的坑\\n                    src[i] = src[j];\\n                    i++;\\n                }\\n                // 从左向右找大于或等于x的数来填s[j]\\n                while (i < j && src[i] < key) {\\n                    i++;\\n                }\\n                if (i < j) {\\n                    //将s[i]填到s[j]中，s[i]就形成了一个新的坑\\n                    src[j] = src[i];\\n                    j--;\\n                }\\n            }\\n            src[i] = key;\\n            //再次将左右两边的数组进行排序，递归\\n            quickSort(src, begin, i - 1);\\n            quickSort(src, i + 1, end);\\n        }\\n    }\\n}\\n```\\n\\n测试代码：\\n\\n``` java\\npublic class SortTest {\\n    public static void main(String[] args) {\\n        testQuickSort();\\n\\n    } \\n    /**\\n     * 快速排序\\n     */\\n    private static void testQuickSort() {\\n        int[] array = {5, 9, 1, 9, 5, 3, 7, 6, 1};\\n        QuickSort quickSort = new QuickSort(array);\\n        quickSort.sort();\\n        quickSort.print();\\n    }\\n}\\n```\\n\\n结果：\\n\\n![image-20220609092349619](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090923880.png)\\n\\n## 特点及性能\\n\\n快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。\\n\\n但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 `O(n2)`，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 `O(nlogn)`，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。\\n\\n快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。\\n\\n快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。\\n\\n**快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。**\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e6e6bce2d43cbe793a3097b931d0aaaf.jpg\",\"articleTitle\":\"快速排序算法（Java实现）\",\"categoryName\":\"数据结构算法\",\"id\":102,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-09 09:29:48',NULL),(1207,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 快速排序算法（Java实现）\\n\\n## 算法思路\\n\\n> 参考b站教程 [动画教程](https://www.bilibili.com/video/BV1at411T75o?spm_id_from=333.337.search-card.all.click)\\n\\n分治思想\\n\\n1. 选定key作为中心轴（一般选取第一个）\\n2. 将大于key的数字放在key的右边\\n3. 将小于key的数字放在key的左边\\n4. 分别对左右子序列重复前三步操作\\n\\n个人理解:\\n``` text \\n1. 先定一个基准值key(一般选取第一个值为key)\\n2. 指定left为下标0，right为length-1，即最后一个元素下标\\n3. 从右往左找比key小的书放至左边，找到之后R--\\n4. 再从左往右找比key大的数放至右边，找到之后L++\\n5. 以此类推\\n6. 直到L==R时，将key放到L==R的位置\\n7. 此时得到key左边的数都小于key，key右边的数都大于key\\n8. 最后再通过分别递归key左边和右边的数组进行排序\\n\\n```\\n\\n\\n``` java\\npublic class QuickSort {\\n    private int[] array;\\n    public QuickSort(int[] array) {\\n        this.array = array;\\n    }\\n    public void sort() {\\n        quickSort(array, 0, array.length - 1);\\n    }\\n    public void print() {\\n        for (int i = 0; i < array.length; i++) {\\n            System.out.println(array[i]);\\n        }\\n    }\\n   \\nprivate void quickSort(int[] src, int begin, int end) {\\n        if (begin < end) {\\n            //第一次排序将第一个元素指定为key\\n            int key = src[begin];\\n            //指定i为开始下标\\n            //j为结束下标\\n            int i = begin;\\n            int j = end;\\n            // 从右向左找小于key的数来填s[i]\\n            while (i < j) {\\n                //如果最后的值比key大的话，j--，结束下标-1\\n                // 从右向左找小于x的数来填s[i]\\n                while (i < j && src[j] > key) {\\n                    j--;\\n                }\\n                if (i < j) {\\n                    //将s[j]填到s[i]中，s[j]就形成了一个新的坑\\n                    src[i] = src[j];\\n                    i++;\\n                }\\n                // 从左向右找大于或等于x的数来填s[j]\\n                while (i < j && src[i] < key) {\\n                    i++;\\n                }\\n                if (i < j) {\\n                    //将s[i]填到s[j]中，s[i]就形成了一个新的坑\\n                    src[j] = src[i];\\n                    j--;\\n                }\\n            }\\n            src[i] = key;\\n            //再次将左右两边的数组进行排序，递归\\n            quickSort(src, begin, i - 1);\\n            quickSort(src, i + 1, end);\\n        }\\n    }\\n}\\n```\\n\\n测试代码：\\n\\n``` java\\npublic class SortTest {\\n    public static void main(String[] args) {\\n        testQuickSort();\\n\\n    } \\n    /**\\n     * 快速排序\\n     */\\n    private static void testQuickSort() {\\n        int[] array = {5, 9, 1, 9, 5, 3, 7, 6, 1};\\n        QuickSort quickSort = new QuickSort(array);\\n        quickSort.sort();\\n        quickSort.print();\\n    }\\n}\\n```\\n\\n结果：\\n\\n![image-20220609092349619](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206090923880.png)\\n\\n## 特点及性能\\n\\n快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。\\n\\n但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 `O(n2)`，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 `O(nlogn)`，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。\\n\\n快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 `O(logn)`，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 `O(n)`。所以我们一般认为快速排序的空间复杂度为 `O(logn)`。\\n\\n快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。\\n\\n**快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。**\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e6e6bce2d43cbe793a3097b931d0aaaf.jpg\",\"articleTitle\":\"快速排序算法（Java实现）\",\"categoryName\":\"数据结构算法\",\"id\":102,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','220.202.152.89','湖南省长沙市 联通','2022-06-09 09:51:34',NULL),(1208,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 数据库三大范式\\n\\n**数据库三大范式**\\n\\n数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。\\n\\n## 1.第一范式（1NF）：列不可再分\\n\\n1. 每一列属性都是不可再分的属性值，确保每一列的原子性\\n2. 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据\\n\\n## 2.第二范式（2NF）：属性完全依赖于主键\\n\\n第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键\\n\\n## 3.第三范式（3NF）：属性不依赖于其它非主属性   属性直接依赖于主键\\n\\n数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。\\n\\n\\n\\n总结：三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。所以不能一味的去追求范式建立数据库。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c8459141d27224bd7621b5c5ba187486.jpg\",\"articleTitle\":\"数据库三大范式\",\"categoryName\":\"Java面经\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-11 18:38:56',NULL),(1209,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Redis缓存击穿、穿透及雪崩\\n\\n## 缓存更新策略\\n\\n缓存更新策略的最佳实践方案：\\n\\n1. 低一致性需求：使用Redis自带的内存淘汰机制\\n\\n2. 高一致性需求：主动更新，并以超时剔除作为兜底方案\\n\\n- 读操作：\\n  - 缓存命中则直接返回\\n  - 缓存未命中则查询数据库，并写入缓存，设定超时时间\\n\\n- 写操作：\\n  - 先写数据库，然后再删除缓存\\n  - 要确保数据库与缓存操作的原子性\\n\\n## 缓存穿透\\n\\n**缓存穿透**是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\\n\\n常见的解决方案有两种：\\n\\n- 缓存空对象\\n  - 优点：实现简单，维护方便\\n  - 缺点：\\n    - 额外的内存消耗\\n    - 可能造成短期的不一致\\n- 布隆过滤器\\n  - 优点：内存占用较少，没有多余key\\n  - 缺点：\\n    - 实现复杂\\n    - 存在判误可能\\n\\n![image-20220606170719663](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061735632.png)\\n\\n缓存穿透产生的原因是什么？\\n\\n- 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\\n\\n缓存穿透的解决方案有哪些？\\n\\n- 缓存null值\\n\\n- 布隆过滤\\n\\n- 增强id的复杂度，避免被猜测id规律\\n\\n- 做好数据的基础格式校验\\n\\n- 加强用户权限校验\\n\\n- 做好热点参数的限流\\n\\n## 缓存雪崩\\n\\n**缓存雪崩**是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力\\n\\n**解决方案：**\\n\\n- 给不同的Key的TTL添加随机值\\n\\n- 利用Redis集群提高服务的可用性\\n\\n- 给缓存业务添加降级限流策略\\n\\n- 给业务添加多级缓存\\n\\n![image-20220606180317024](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061803093.png)\\n\\n## 缓存击穿\\n\\n**缓存击穿问题**也叫热点Key问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\\n\\n常见的解决方案有两种：\\n\\n- 互斥锁\\n- 逻辑过期\\n\\n![image-20220606180444992](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061804056.png)\\n\\n![image-20220606181304579](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061813654.png)\\n\\n![image-20220606181723834](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206061817658.png)\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/6cae80187ea5f083fc26f3072da4f858.jpg\",\"articleTitle\":\"Redis缓存击穿、穿透及雪崩\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"Redis\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-12 11:53:44',NULL),(1210,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Redis入门\\n\\nRedis的常见命令和客户端使用\\n\\n## 一、初识Redis\\n\\n### （一）认识NoSQL\\n\\n#### 1. SQL\\n\\n> SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL等。\\n\\n关系型数据库适合存储结构化数据\\n\\n如用户的帐号、地址等：\\n\\n1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹\\n\\n2）这些数据的规模、增长的速度通常是可以预期的\\n\\n3）保证数据的事务性、一致性要求（ACID）。\\n\\n#### 2. NoSQL\\n\\n> NoSQL（Not Only SQL）泛指非关系型数据库，主要代表：MongoDB，Redis等。\\n\\n非关系型数据库适合存储非结构化数据\\n\\n如发微博、文章、评论：\\n\\n1）这些数据通常用于模糊处理，如全文搜索、机器学习\\n\\n2）这些数据是海量的，而且增长的速度是难以预期的，\\n\\n3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性\\n\\n4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差\\n\\n目前许多大型互联网项目都会选用MySQL（或任何关系型数据库） + NoSQL的组合方案。\\n\\n![image-20220528205407889](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282054974.png)\\n\\n### （二）认识Redis\\n\\nRedis诞生于2009年全称是**Re**mote **Di**ctionary **S**erver，远程词典服务器**，是一个基于内存的键值型NoSQL数据库**。\\n\\n**特征**：\\n\\n- 键值（key-value）型，value支持多种不同数据结构，功能丰富\\n\\n- 单线程，每个命令具备原子性\\n\\n- 低延迟，速度快（基于内存、IO多路复用、良好的编码）。\\n\\n- 支持数据持久化\\n\\n- 支持主从集群、分片集群\\n\\n- 支持多语言客户端\\n\\n### （三）安装Redis\\n\\n这里使用虚拟机docker安装Redis\\n\\n#### 1. 安装Redis\\n\\n通过`docker search redis`和`docker pull redis`下载redis镜像\\n\\n#### 2. 新建挂载配置文件夹\\n\\n因为 redis 默认配置你会发现只能够本地连接，不能进行远程访问，使用 Redis Desktop Manager连接都会报错，因此需要手动挂载 redis 配置文件\\n\\n新建data和conf两个文件夹，位置随意。\\n\\neg：\\n\\n``` shell\\nmkdir -p /root/docker/redis/data\\nmkdir -p /root/docker/redis/conf\\n```\\n\\n#### 3. 增加配置文件 redis.conf\\n\\n在刚才新建的redis/conf中新建文件redis.conf，内容如下：\\n\\n``` tex\\nbind 0.0.0.0\\nprotected-mode yes\\nport 6379\\ntcp-backlog 511\\ntimeout 0\\ntcp-keepalive 0\\nloglevel notice\\nlogfile \\\"redis.log\\\"\\ndatabases 16\\nsave 900 1\\nsave 300 10\\nsave 60 10000\\nstop-writes-on-bgsave-error yes\\nrdbcompression yes\\nrdbchecksum yes\\ndbfilename dump.rdb\\ndir ./\\nslave-serve-stale-data yes\\nslave-read-only yes\\nrepl-diskless-sync no\\nrepl-diskless-sync-delay 5\\nrepl-disable-tcp-nodelay no\\nslave-priority 100\\nappendonly no\\nappendfilename \\\"appendonly.aof\\\"\\nappendfsync everysec\\nno-appendfsync-on-rewrite no\\nauto-aof-rewrite-percentage 100\\nauto-aof-rewrite-min-size 64mb\\naof-load-truncated yes\\nlua-time-limit 5000\\nslowlog-log-slower-than 10000\\nslowlog-max-len 128\\nlatency-monitor-threshold 0\\nnotify-keyspace-events \\\"\\\"\\nhash-max-ziplist-entries 512\\nhash-max-ziplist-value 64\\nlist-max-ziplist-size -2\\nlist-compress-depth 0\\nset-max-intset-entries 512\\nzset-max-ziplist-entries 128\\nzset-max-ziplist-value 64\\nhll-sparse-max-bytes 3000\\nactiverehashing yes\\nclient-output-buffer-limit normal 0 0 0\\nclient-output-buffer-limit slave 256mb 64mb 60\\nclient-output-buffer-limit pubsub 32mb 8mb 60\\nhz 10\\naof-rewrite-incremental-fsync yes\\nrequirepass 123321\\n```\\n\\n#### 4. 创建redis容器并启动\\n\\n执行命令如下：\\n\\n``` shell\\ndocker run --name redis -p 6379:6379 -v /root/docker/redis/data:/data -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf\\n\\n```\\n\\n释义如下：\\n\\n> –name：给容器起一个名\\n> -p：端口映射 宿主机:容器\\n> -v：挂载自定义配置 自定义配置:容器内部配置\\n> -d：后台运行 redis-server --appendonly yes： 在容器执行redis-server启动命令，并打开redis持久化配置\\n\\n#### 5. 启动成功，查看状态\\n\\n通过`docker ps`查看启动状态，是否成功\\n\\n#### 6. 容器内部连接进行测试\\n\\n执行docker exec -it redis redis-cli 命令，进入终端。\\n通过auth password进行登陆。\\n\\n## 二、Redis常见命令\\n\\n## （一）Redis数据结构介绍\\n\\nRedis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：\\n\\n![image-20220528215631822](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282156887.png)\\n\\nRedis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ [https://redis.io/commands ](https://redis.io/commands)）可以查看到不同的命令：\\n\\n![image-20220528215850343](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282158400.png)\\n\\n## （二）通用命令\\n\\n通用指令是部分数据类型的，都可以使用的指令，常见的有：\\n\\n- KEYS：查看符合模板的所有key\\n\\n- DEL：删除一个指定的key\\n\\n- EXISTS：判断key是否存在\\n\\n- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除\\n\\n- TTL：查看一个KEY的剩余有效期\\n\\n通过help [command] 可以查看一个命令的具体用法，例如：\\n\\n![image-20220528220236830](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282202927.png)\\n\\n## （三）String类型\\n\\nString类型，也就是字符串类型，是Redis中最简单的存储类型。\\n\\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\\n\\n- string：普通字符串\\n\\n- int：整数类型，可以做自增、自减操作\\n\\n- float：浮点类型，可以做自增、自减操作\\n\\n不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.\\n\\n|  KEY  |    VALUE    |\\n| :---: | :---------: |\\n|  msg  | hello world |\\n|  num  |     10      |\\n| score |    92.5     |\\n\\n#### **String类型的常见命令**\\n\\nString的常见命令有：\\n\\n- SET：添加或者修改已经存在的一个String类型的键值对\\n\\n- GET：根据key获取String类型的value\\n\\n- MSET：批量添加多个String类型的键值对\\n\\n- MGET：根据多个key获取多个String类型的value\\n\\n- INCR：让一个整型的key自增1\\n\\n- INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\\n\\n- INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\\n\\n- SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\\n\\n- SETEX：添加一个String类型的键值对，并且指定有效期\\n\\nKey的结构\\n\\nRedis的key允许有多个单词形成层级结构，多个单词之间用\':\'隔开，格式如下：\\n\\n``` tex\\n项目名:业务名:类型:id\\n```\\n\\n这个格式并非固定，也可以根据自己的需求来删除或添加词条。\\n\\n例如我们的项目名称叫 icatw，有user和product两种不同类型的数据，我们可以这样定义key：\\n\\n- user相关的key：icatw:user:1\\n\\n- product相关的key：icatw:product:1\\n\\n在图形化界面窗口中可以清晰的看到层级结构\\n\\n![image-20220528222847431](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202205282228488.png)\\n\\n如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：\\n\\n| KEY             | VALUE                                 |\\n| --------------- | ------------------------------------- |\\n| icatw:user:1    | {\\\"id\\\":1, \\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}   |\\n| icatw:product:1 | {\\\"id\\\":1,\\\"name\\\":\\\"小米11\\\",\\\"price\\\":4999} |\\n\\n> 　　总结：\\n>\\n> 　String类型的三种格式：\\n>\\n> 　- 字符串\\n> 　- int\\n> 　- float\\n>\\n> 　Redis的key的格式：\\n>\\n> 　- [项目名] : [业务名] : [类型] : [id]\\n\\n## （四）Hash类型\\n\\nHash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\\n\\n<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>\\n\\n| KEY          | VALUE                 |\\n| ------------ | --------------------- |\\n| icatw:user:1 | {name:\\\"Jack\\\", age:21} |\\n| icatw:user:2 | {name:\\\"Rose\\\", age:22} |\\n\\nHash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：\\n\\n<table align=\\\"center\\\">\\n    <tr align=\\\"center\\\">\\n        <td rowspan=\\\"2\\\">KEY</td> \\n        <td colspan=\\\"2\\\">VALUE</td> \\n   </tr>\\n    <tr>\\n        <td >field</td>    \\n  \\t\\t <td >value</td> \\n    </tr>\\n    <tr>\\n        <td rowspan=\\\"2\\\">icatw:user:1</td> \\n        <td>name</td> \\n        <td>Jack</td> \\n    </tr>\\n    <tr>\\n        <td>age</td> \\n        <td>21</td> \\n    </tr>\\n    <tr>\\n  <td rowspan=\\\"2\\\">icatw:user:1</td> \\n        <td>name</td> \\n        <td>Rose</td> \\n    </tr>\\n    <tr>\\n        <td>age</td>\\n        <td>18</td> \\n    </tr>\\n</table>\\n\\n\\n#### **Hash的常见命令**\\n\\nHash的常见命令有：\\n\\n- HSET key field value：添加或者修改hash类型key的field的值\\n\\n- HGET key field：获取一个hash类型key的field的值\\n\\n- HMSET：批量添加多个hash类型key的field的值\\n\\n- HMGET：批量获取多个hash类型key的field的值\\n\\n- HGETALL：获取一个hash类型的key中的所有的field和value\\n\\n- HKEYS：获取一个hash类型的key中的所有的field\\n\\n- HVALS：获取一个hash类型的key中的所有的value\\n\\n- HINCRBY:让一个hash类型key的字段值自增并指定步长\\n\\n- HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\\n\\n## （五）List类型\\n\\nRedis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\\n\\n特征也与LinkedList类似：\\n\\n- 有序\\n\\n- 元素可以重复\\n\\n- 插入和删除快\\n\\n- 查询速度一般\\n\\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\\n\\n**List类型的常见命令**\\n\\nList的常见命令有：\\n\\n- LPUSH key element ... ：向列表左侧插入一个或多个元素\\n\\n- LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\\n\\n- RPUSH key element ... ：向列表右侧插入一个或多个元素\\n\\n- RPOP key：移除并返回列表右侧的第一个元素\\n\\n- LRANGE key star end：返回一段角标范围内的所有元素\\n\\n- BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\\n\\n  ![image-20220531160158776](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220531160158776.png)\\n\\n## （六）Set类型\\n\\nRedis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\\n\\n- 无序\\n\\n- 元素不可重复\\n\\n- 查找快\\n\\n- 支持交集、并集、差集等功能\\n\\nSet的常见命令\\n\\nSet的常见命令有：\\n\\n- SADD key member ... ：向set中添加一个或多个元素\\n\\n- SREM key member ... : 移除set中的指定元素\\n\\n- SCARD key： 返回set中元素的个数\\n\\n- SISMEMBER key member：判断一个元素是否存在于set中\\n\\n- SMEMBERS：获取set中的所有元素\\n\\n- SINTER key1 key2 ... ：求key1与key2的交集\\n- SDIFF key1 key2 ... ：求key1与key2的差集\\n- SUNION key1 key2 ..：求key1和key2的并集\\n\\n## （七）SortedSet类型\\n\\nRedis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\\n\\nSortedSet具备下列特性：\\n\\n- 可排序\\n\\n- 元素不重复\\n\\n- 查询速度快\\n\\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\\n\\n**SortedSet类型的常见命令**\\n\\nSortedSet的常见命令有：\\n\\n- ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\\n\\n- ZREM key member：删除sorted set中的一个指定元素\\n\\n- ZSCORE key member : 获取sorted set中的指定元素的score值\\n\\n- ZRANK key member：获取sorted set 中的指定元素的排名\\n\\n- ZCARD key：获取sorted set中的元素个数\\n\\n- ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\\n\\n- ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\\n\\n- ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\\n\\n- ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\\n\\n- ZDIFF、ZINTER、ZUNION：求差集、交集、并集\\n\\n注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可\\n\\n## 三、Redis的Java的客户端\\n\\n![image-20220531162938681](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220531162938681.png)\\n\\n### （一）Jedis客户端\\n\\n#### **Jedis**\\n\\nJedis的官网地址： https://github.com/redis/jedis，我们先来个快速入门：\\n\\n新建maven项目\\n\\n1. 引入依赖：\\n\\n``` xml\\n    <dependencies>\\n        <dependency>\\n            <groupId>redis.clients</groupId>\\n            <artifactId>jedis</artifactId>\\n            <version>3.7.1</version>\\n        </dependency>\\n    </dependencies>\\n```\\n\\n2. 建立连接\\n\\n``` java\\n    @BeforeEach\\n    void setUp() {\\n        //1.建立连接\\n        jedis = new Jedis(\\\"192.168.17.130\\\", 6379);\\n        //2.设置密码\\n        jedis.auth(\\\"123321\\\");\\n        //3.选择库\\n        jedis.select(0);\\n    }\\n```\\n\\n3. 测试string\\n\\n``` java\\n    @Test\\n    void testString() {\\n        //    存入数据\\n        String result = jedis.set(\\\"name\\\", \\\"王顺\\\");\\n        System.out.println(\\\"result:=============\\\" + result);\\n        //    获取数据\\n        String name = jedis.get(\\\"name\\\");\\n        System.out.println(\\\"name=>\\\" + name);\\n    }\\n```\\n\\n4. 释放连接\\n\\n``` java\\n    @AfterEach\\n    void tearDown() {\\n        if (jedis != null) {\\n            jedis.close();\\n        }\\n    }\\n```\\n\\n**总结：**\\n\\nJedis使用的基本步骤：\\n\\n1.引入依赖\\n\\n2.创建Jedis对象，建立连接\\n\\n3.使用Jedis，方法名与Redis命令一致\\n\\n4.释放资源\\n\\n#### Jedis连接池\\n\\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。\\n\\n``` java\\n//jedis连接池工具类\\npublic class JedisConnectionFactory {\\n    private static final JedisPool JEDIS_POOL;\\n\\n    static {\\n        //配置连接池\\n        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\\n        // 最大连接\\n        jedisPoolConfig.setMaxTotal(8);\\n        // 最大空闲连接\\n        jedisPoolConfig.setMaxIdle(8);\\n        // 最小空闲连接\\n        jedisPoolConfig.setMinIdle(0);\\n        // 设置最长等待时间， ms\\n        jedisPoolConfig.setMaxWaitMillis(200);\\n        //创建连接池对象\\n        JEDIS_POOL = new JedisPool(jedisPoolConfig,\\n                \\\"192.168.150.101\\\", 6379, 1000, \\\"123321\\\");\\n    }\\n\\n    /**\\n     * 获取jedis对象\\n     *\\n     * @return {@link Jedis}\\n     */\\n    public static Jedis getJedis() {\\n        return JEDIS_POOL.getResource();\\n    }\\n}\\n```\\n\\n测试\\n\\n``` java\\n    @BeforeEach\\n    void setUp() {\\n        //1.建立连接\\n        jedis = JedisConnectionFactory.getJedis();\\n        //2.设置密码\\n        jedis.auth(\\\"123321\\\");\\n        //3.选择库\\n        jedis.select(0);\\n    }\\n```\\n\\n\\n\\n### （二）SpringDataRedis客户端\\n\\n#### **SpringDataRedis**\\n\\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis\\n\\n- 提供了对不同Redis客户端的整合（Lettuce和Jedis）\\n\\n- 提供了RedisTemplate统一API来操作Redis\\n\\n- 支持Redis的发布订阅模型\\n\\n- 支持Redis哨兵和Redis集群\\n\\n- 支持基于Lettuce的响应式编程\\n\\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\\n\\n- 支持基于Redis的JDKCollection实现\\n\\n#### **SpringDataRedis快速入门**\\n\\nSpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\\n\\n| API                             | 返回值类型      | 说明                  |\\n| ------------------------------- | --------------- | --------------------- |\\n| **redisTemplate**.opsForValue() | ValueOperations | 操作String类型数据    |\\n| **redisTemplate**.opsForHash()  | HashOperations  | 操作Hash类型数据      |\\n| **redisTemplate**.opsForList()  | ListOperations  | 操作List类型数据      |\\n| **redisTemplate**.opsForSet()   | SetOperations   | 操作Set类型数据       |\\n| **redisTemplate**.opsForZSet()  | ZSetOperations  | 操作SortedSet类型数据 |\\n| **redisTemplate**               |                 | 通用的命令            |\\n\\nSpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：\\n\\n新建springboot项目\\n\\n1. 引入依赖\\n\\n``` xml\\n<!--Redis依赖-->\\n<dependency>\\n    <groupId>org.springframework.boot</groupId\\n    <artifactId>spring-boot-starter-data-redis</artifactId></dependency>\\n<!--连接池依赖-->\\n<dependency>\\n    <groupId>org.apache.commons</groupId>\\n    <artifactId>commons-pool2</artifactId>\\n</dependency>\\n```\\n\\n2. 配置文件\\n\\n``` yaml\\nspring:\\n  redis:\\n    host: 192.168.17.130\\n    port: 6379\\n    password: 123321\\n    lettuce:\\n      pool:\\n        max-active: 8 # 最大连接\\n        max-idle: 8 # 最大空闲连接\\n        min-idle: 0 # 最小空闲连接\\n        max-wait: 100 # 连接等待时间\\n```\\n\\n3. 注入RedisTemplate\\n\\n``` java\\n@Autowired\\nprivate RedisTemplate redisTemplate;\\n```\\n\\n4. 编写测试\\n\\n``` java\\n/**\\n *\\n * @author icatw\\n * @date 2022/06/01\\n */\\n@SpringBootTest\\nclass RedisDemoApplicationTests {\\n    @Autowired\\n    RedisTemplate redisTemplate;\\n\\n    @Test\\n    void contextLoads() {\\n    }\\n\\n    @Test\\n    void testString() {\\n        redisTemplate.opsForValue().set(\\\"name\\\", \\\"李四\\\");\\n        Object name = redisTemplate.opsForValue().get(\\\"name\\\");\\n        System.out.println(\\\"name=\\\" + name);\\n    }\\n}\\n```\\n\\n**总结**：\\n\\nSpringDataRedis的使用步骤：\\n\\n1.引入spring-boot-starter-data-redis依赖\\n\\n2.在application.yml配置Redis信息\\n\\n3.注入RedisTemplate\\n\\n#### **SpringDataRedis的序列化方式**\\n\\nRedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：\\n\\n![image-20220601160515943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601160515943.png)\\n\\n缺点：\\n\\n- 可读性差\\n\\n- 内存占用较大\\n\\n我们可以自定义RedisTemplate的序列化方式，代码如下：\\n\\n``` java\\n@Configuration\\npublic class RedisConfig {\\n    @Bean\\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\\n        // 创建Template\\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\\n        // 设置连接工厂\\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\\n        // 设置序列化工具\\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer =\\n                new GenericJackson2JsonRedisSerializer();\\n        // key和 hashKey采用 string序列化\\n        redisTemplate.setKeySerializer(RedisSerializer.string());\\n        redisTemplate.setHashKeySerializer(RedisSerializer.string());\\n        //value和 hashValue采用 JSON序列化\\n        redisTemplate.setValueSerializer(jsonRedisSerializer);\\n        redisTemplate.setHashValueSerializer(jsonRedisSerializer);\\n        return redisTemplate;\\n    }\\n\\n}\\n```\\n\\n注：\\n\\n如果没有使用web依赖则需要手动引入jackson依赖，否则将会报错\\n\\n``` xml\\n<!--        jackson依赖 json序列化-->\\n        <dependency>\\n            <groupId>com.fasterxml.jackson.core</groupId>\\n            <artifactId>jackson-databind</artifactId>\\n        </dependency>\\n```\\n\\n#### **StringRedisTemplate**\\n\\n尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：\\n\\n![image-20220601164333457](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601164333457.png)\\n\\n为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。\\n\\n为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。\\n\\n![image-20220601164530393](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601164530393.png)\\n\\nSpring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程：\\n\\n``` java\\n@Autowired\\nprivate StringRedisTemplate stringRedisTemplate;\\n// JSON工具\\nprivate static final ObjectMapper mapper = new ObjectMapper();\\n@Test\\nvoid testStringTemplate() throws JsonProcessingException {\\n    // 准备对象\\n    User user = new User(\\\"虎哥\\\", 18);\\n    // 手动序列化\\n    String json = mapper.writeValueAsString(user);\\n    // 写入一条数据到redis\\n    stringRedisTemplate.opsForValue().set(\\\"user:200\\\", json);     // 读取数据\\n    String val = stringRedisTemplate.opsForValue().get(\\\"user:200\\\");\\n    // 反序列化 \\n    User user1 = mapper.readValue(val, User.class); System.out.println(\\\"user1 = \\\" + user1);}\\n\\n```\\n\\n使用fastjson\\n\\n1. 引依赖\\n\\n```xml\\n<dependency>\\n    <groupId>com.alibaba</groupId>\\n    <artifactId>fastjson</artifactId>\\n    <version>1.2.80</version>\\n</dependency>\\n```\\n\\n2. 注入StringRedisTemplate\\n\\n``` java\\n@Autowired\\nStringRedisTemplate stringRedisTemplate;\\n```\\n\\n3. 测试\\n\\n``` java\\n    @Test\\n    void stringRedisTemplate() {\\n        User user = new User(\\\"cs\\\", \\\"123\\\");\\n        String jsonString = JSON.toJSONString(user);\\n        //先把java对象转为json再存入redis，序列化\\n        stringRedisTemplate.opsForValue().set(\\\"user\\\", jsonString);\\n        String s = stringRedisTemplate.opsForValue().get(\\\"user\\\");\\n        //将取出的redis数据转为java对象，反序列化\\n        User json =JSON.parseObject(s, User.class);\\n        System.out.println(json);\\n    }\\n```\\n\\n![image-20220601165839022](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601165839022.png)\\n\\n![image-20220601170500767](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20220601170500767.png)\\n\\n#### 总结：\\n\\nRedisTemplate的两种序列化实践方案：\\n\\n**方案一：**\\n\\n1.自定义RedisTemplate\\n\\n2.修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer\\n\\n**方案二：**\\n\\n1.使用StringRedisTemplate\\n\\n2.写入Redis时，手动把对象序列化为JSON\\n\\n3.读取Redis时，手动把读取到的JSON反序列化为对象\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/f2941c745e5433ebb770f76498b36d76.jpg\",\"articleTitle\":\"Redis基础篇\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-06-13 12:55:58',NULL),(1211,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 事务注解 @Transactional 失效的3种场景及解决办法\\n\\n## **Transactional失效场景**\\n\\n### **第一种失效场景**\\n\\n**当Transactional注解标注方法修饰符为非public时**，@Transactional注解将会不起作用。例如以下代码，定义一个错误的@Transactional标注实现，修饰一个默认访问符的方法：\\n\\n```java\\n@Component\\npublic class TestServiceImpl {\\n    @Resource\\n    TestMapper testMapper;\\n    \\n    @Transactional\\n    void insertTestWrongModifier() {\\n        int re = testMapper.insert(new Test(10,20,30));\\n        if (re > 0) {\\n            throw new NeedToInterceptException(\\\"need intercept\\\");\\n        }\\n        testMapper.insert(new Test(210,20,30));\\n    }\\n \\n}\\n```\\n\\n在同一个包内，新建调用对象，进行访问。\\n\\n``` java\\n@Component\\npublic class InvokcationService {\\n    @Resource\\n    private TestServiceImpl testService;\\n    public void invokeInsertTestWrongModifier(){\\n        //调用@Transactional标注的默认访问符方法\\n        testService.insertTestWrongModifier();\\n    }\\n}\\n```\\n\\n测试用例：\\n\\n``` java\\n@RunWith(SpringRunner.class)\\n@SpringBootTest\\npublic class DemoApplicationTests {\\n   @Resource\\n   InvokcationService invokcationService;\\n \\n   @Test\\n   public void  testInvoke(){\\n      invokcationService.invokeInsertTestWrongModifier();\\n   }\\n}\\n```\\n\\n以上的访问方式，导致事务没开启，因此在方法抛出异常时，testMapper.insert(new Test(10,20,30));操作不会进行回滚。如果`TestServiceImpl#insertTestWrongModifier`方法改为public的话将会正常开启事务，testMapper.insert(new Test(10,20,30));将会进行回滚。\\n\\n### 第二种失效场景\\n\\n**在类内部调用调用类内部@Transactional标注的方法**，这种情况下也会导致事务不开启。示例代码如下，设置一个内部调用：\\n\\n```php\\n@Component\\npublic class TestServiceImpl implements TestService {\\n    @Resource\\n    TestMapper testMapper;\\n \\n    @Transactional\\n    public void insertTestInnerInvoke() {\\n        //正常public修饰符的事务方法\\n        int re = testMapper.insert(new Test(10,20,30));\\n        if (re > 0) {\\n            throw new NeedToInterceptException(\\\"need intercept\\\");\\n        }\\n        testMapper.insert(new Test(210,20,30));\\n    }\\n \\n \\n    public void testInnerInvoke(){\\n        //类内部调用@Transactional标注的方法。\\n        insertTestInnerInvoke();\\n    }\\n \\n}\\n```\\n\\n测试用例：\\n\\n``` java\\n@RunWith(SpringRunner.class)\\n@SpringBootTest\\npublic class DemoApplicationTests {\\n \\n   @Resource\\n   TestServiceImpl testService;\\n \\n   /**\\n    * 测试内部调用@Transactional标注方法\\n    */\\n   @Test\\n   public void  testInnerInvoke(){\\n       //测试外部调用事务方法是否正常\\n      //testService.insertTestInnerInvoke();\\n       //测试内部调用事务方法是否正常\\n      testService.testInnerInvoke();\\n   }\\n}\\n```\\n\\n上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，testMapper.insert(new Test(10,20,30))操作将会被回滚；\\n\\n然后运行另外一个测试用例，调用一个方法在类内部调用内部被@Transactional标注的事务方法，运行结果是事务不会正常开启，testMapper.insert(new Test(10,20,30))操作将会保存到数据库不会进行回滚。\\n\\n### 第三种失效场景\\n\\n事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下。\\n\\n``` java\\n@Component\\npublic class TestServiceImpl implements TestService {\\n    @Resource\\n    TestMapper testMapper;\\n \\n    @Transactional\\n    public void insertTestCatchException() {\\n        try {\\n            int re = testMapper.insert(new Test(10,20,30));\\n            if (re > 0) {\\n                //运行期间抛异常\\n                throw new NeedToInterceptException(\\\"need intercept\\\");\\n            }\\n            testMapper.insert(new Test(210,20,30));\\n        }catch (Exception e){\\n            System.out.println(\\\"i catch exception\\\");\\n        }\\n    }\\n    \\n}\\n```\\n\\n测试用例代码如下：\\n\\n``` java\\n@RunWith(SpringRunner.class)\\n@SpringBootTest\\npublic class DemoApplicationTests {\\n \\n   @Resource\\n   TestServiceImpl testService;\\n \\n   @Test\\n   public void testCatchException(){\\n      testService.insertTestCatchException();\\n   }\\n}\\n```\\n\\n运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， testMapper.insert(new Test(210,20,30))操作并没有回滚。\\n\\n以上三种就是@Transactional注解不起作用，@Transactional注解失效的主要原因。下面结合spring中对于@Transactional的注解实现源码分析为何导致@Transactional注解不起作用。\\n\\n**@Transactional注解不起作用原理分析**\\n\\n### 第一种场景分析\\n\\n`@Transactional`注解标注方法修饰符为非public时，`@Transactional`注解将会不起作用。这里分析 的原因是，`@Transactional`是基于动态代理实现的，`@Transactional`注解实现原理中分析了实现方法，在bean初始化过程中，对含有`@Transactional`标注的bean实例创建代理对象，这里就存在一个spring扫描`@Transactional`注解信息的过程，不幸的是源码中体现，标注@Transactional的方法如果修饰符不是public，那么就默认方法的`@Transactional`信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用\\n\\n`@Transactional`注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是。根据spring创建好一个aop切点`BeanFactoryTransactionAttributeSourceAdvisor`实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含`@Transactional`，如果bean任何一个方法包含`@Transactional`注解信息，那么就是适配这个BeanFactoryTransactionAttributeSourceAdvisor切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。\\n\\nspring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@Transactional信息，如果有，就表示切点BeanFactoryTransactionAttributeSourceAdvisor能够应用（canApply）到bean中，\\n\\n```\\nAopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class<?>, boolean)\\n```\\n\\n``` java\\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\\n   Assert.notNull(pc, \\\"Pointcut must not be null\\\");\\n   if (!pc.getClassFilter().matches(targetClass)) {\\n      return false;\\n   }\\n \\n   MethodMatcher methodMatcher = pc.getMethodMatcher();\\n   if (methodMatcher == MethodMatcher.TRUE) {\\n      // No need to iterate the methods if we\'re matching any method anyway...\\n      return true;\\n   }\\n \\n   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\\n   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\\n      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\\n   }\\n \\n    //遍历class的方法对象\\n   Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\\n   classes.add(targetClass);\\n   for (Class<?> clazz : classes) {\\n      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\\n      for (Method method : methods) {\\n         if ((introductionAwareMethodMatcher != null &&\\n               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\\n             //适配查询方法上的@Transactional注解信息  \\n             methodMatcher.matches(method, targetClass)) {\\n            return true;\\n         }\\n      }\\n   }\\n \\n   return false;\\n}\\n```\\n\\n我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。\\n\\n```\\nAbstractFallbackTransactionAttributeSource#getTransactionAttribute\\n```\\n\\n- `AbstractFallbackTransactionAttributeSource#computeTransactionAttribute`\\n\\n``` java\\nprotected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {\\n   // Don\'t allow no-public methods as required.\\n   //非public 方法，返回@Transactional信息一律是null\\n   if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\\n      return null;\\n   }\\n   //后面省略.......\\n }\\n```\\n\\n#### 不创建代理对象\\n\\n所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。\\n\\n![image-20220630010117451](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206300101513.png)\\n\\n如果class中的方法都是非public的那么将不是代理对象。\\n\\n![image-20220630010131173](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206300101213.png)\\n\\n#### 不进行代理调用\\n\\n考虑一种情况，如下面代码所示。两个方法都被@Transactional注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的@Transactional注解标注方法。\\n\\n创建了代理对象，insertTestWrongModifier就会开启事务吗？答案是不会。\\n\\n``` java\\n@Component\\npublic class TestServiceImpl implements TestService {\\n    @Resource\\n    TestMapper testMapper;\\n \\n    @Override\\n    @Transactional\\n    public void insertTest() {\\n        int re = testMapper.insert(new Test(10,20,30));\\n        if (re > 0) {\\n            throw new NeedToInterceptException(\\\"need intercept\\\");\\n        }\\n        testMapper.insert(new Test(210,20,30));\\n    }\\n    \\n    @Transactional\\n    void insertTestWrongModifier() {\\n        int re = testMapper.insert(new Test(10,20,30));\\n        if (re > 0) {\\n            throw new NeedToInterceptException(\\\"need intercept\\\");\\n        }\\n        testMapper.insert(new Test(210,20,30));\\n    }\\n}\\n \\n```\\n\\n原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中`CglibAopProxy.DynamicAdvisedInterceptor#intercept`，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。\\n\\n``` java\\nList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\\n\\n```\\n\\n而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次\\n\\n```\\nAbstractFallbackTransactionAttributeSource#getTransactionAttribute\\n```\\n\\n- `AbstractFallbackTransactionAttributeSource#computeTransactionAttribute`\\n\\n也就是说还需要找一个方法上的@Transactional注解信息，没有的话就不执行代理@Transactional对应的代理逻辑，直接执行方法。没有了@Transactional注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。\\n\\n### 第二种场景分析\\n\\n在类内部调用调用类内部@Transactional标注的方法。这种情况下也会导致事务不开启。\\n\\n经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到；\\n\\n> 既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。\\n\\n其实我们可以这样玩，内部调用也能实现开启事务，代码如下。\\n\\n``` java\\n@Component\\npublic class TestServiceImpl implements TestService {\\n    @Resource\\n    TestMapper testMapper;\\n \\n    @Resource\\n    TestServiceImpl testServiceImpl;\\n \\n \\n    @Transactional\\n    public void insertTestInnerInvoke() {\\n        int re = testMapper.insert(new Test(10,20,30));\\n        if (re > 0) {\\n            throw new NeedToInterceptException(\\\"need intercept\\\");\\n        }\\n        testMapper.insert(new Test(210,20,30));\\n    }\\n \\n \\n    public void testInnerInvoke(){\\n        //内部调用事务方法\\n        testServiceImpl.insertTestInnerInvoke();\\n    }\\n \\n}\\n```\\n\\n上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩~\\n\\n### 第三种场景分析\\n\\n事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。\\n\\n这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里卖弄动态代理逻辑是如何为我们管理事务的。\\n\\n```\\nTransactionAspectSupport#invokeWithinTransaction\\n```\\n\\n代码如下。\\n\\n``` java\\nprotected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)\\n      throws Throwable {\\n \\n   // If the transaction attribute is null, the method is non-transactional.\\n   final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);\\n   final PlatformTransactionManager tm = determineTransactionManager(txAttr);\\n   final String joinpointIdentification = methodIdentification(method, targetClass);\\n \\n   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\\n      // Standard transaction demarcation with getTransaction and commit/rollback calls.\\n       //开启事务\\n      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\\n      Object retVal = null;\\n      try {\\n         // This is an around advice: Invoke the next interceptor in the chain.\\n         // This will normally result in a target object being invoked.\\n          //反射调用业务方法\\n         retVal = invocation.proceedWithInvocation();\\n      }\\n      catch (Throwable ex) {\\n         // target invocation exception\\n          //异常时，在catch逻辑中回滚事务\\n         completeTransactionAfterThrowing(txInfo, ex);\\n         throw ex;\\n      }\\n      finally {\\n         cleanupTransactionInfo(txInfo);\\n      }\\n       //提交事务\\n      commitTransactionAfterReturning(txInfo);\\n      return retVal;\\n   }\\n \\n   else {\\n     //....................\\n   }\\n}\\n```\\n\\n所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/321e9090797e8a5dbbe46528503198ca.jpg\",\"articleTitle\":\"事务注解 @Transactional 失效的3种场景及解决办法\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"https://blog.csdn.net/hollis_chuang/article/details/115713374\",\"status\":1,\"tagNameList\":[],\"type\":2}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.7.236','湖南省永州市 电信','2022-06-30 01:07:40',NULL),(1212,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Redis消息队列\\n\\n**消息队列**（**M**essage **Q**ueue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：\\n\\n- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）\\n\\n- 生产者：发送消息到消息队列\\n\\n- 消费者：从消息队列获取消息并处理消息\\n\\n![image-20220630231817103](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302318189.png)\\n\\nRedis提供了三种不同的方式来实现消息队列：\\n\\n- list结构：基于List结构模拟消息队列\\n\\n- PubSub：基本的点对点消息模型\\n\\n- Stream：比较完善的消息队列模型\\n\\n## 基于List消息队列\\n\\n**Redis的list数据结构是一个双向链表，很容易模拟出队列效果。**\\n\\n队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。\\n\\n不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用**BRPOP**或者**BLPOP**来实现阻塞效果。\\n\\n![image-20220630232001933](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302320983.png)\\n\\n### 总结\\n\\n基于List的消息队列有哪些优缺点？\\n\\n优点：\\n\\n- 利用Redis存储，不受限于JVM内存上限\\n\\n- 基于Redis的持久化机制，数据安全性有保证\\n\\n- 可以满足消息有序性\\n\\n缺点：\\n\\n- 无法避免消息丢失\\n\\n- 只支持单消费者\\n\\n## 基于PubSub的消息队列\\n\\n**PubSub（发布订阅）**是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。\\n\\n-  SUBSCRIBE channel [channel] ：订阅一个或多个频道\\n\\n*  PUBLISH channel msg ：向一个频道发送消息\\n\\n-  PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道\\n\\n![image-20220630232343307](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202206302323359.png)\\n\\n### 总结\\n\\n基于PubSub的消息队列有哪些优缺点？\\n\\n优点：\\n\\n- 采用发布订阅模型，支持多生产、多消费\\n\\n缺点：\\n\\n- 不支持数据持久化\\n\\n- 无法避免消息丢失\\n\\n- 消息堆积有上限，超出时数据丢失\\n\\n## 基于Stream的消息队列\\n\\nStream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。\\n\\n![image-20220701141016083](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410178.png)\\n\\n![image-20220701141027340](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410411.png)\\n\\n![image-20220701141051694](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011410758.png)\\n\\n### 总结\\n\\nSTREAM类型消息队列的XREAD命令特点：\\n\\n- 消息可回溯\\n\\n- 一个消息可以被多个消费者读取\\n\\n- 可以阻塞读取\\n\\n- 有消息漏读的风险\\n\\n## 基于Stream的消息队列-消费者组\\n\\n**消费者组（Consumer Group）**：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：\\n\\n![image-20220701142516546](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425603.png)\\n\\n![image-20220701142528396](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425454.png)\\n\\n![image-20220701142539919](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011425975.png)\\n\\n![image-20220701142601370](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011426421.png)\\n\\n### 总结\\n\\nSTREAM类型消息队列的XREADGROUP命令特点：\\n\\n- 消息可回溯\\n\\n- 可以多消费者争抢消息，加快消费速度\\n\\n- 可以阻塞读取\\n\\n- 没有消息漏读的风险\\n\\n- 有消息确认机制，保证消息至少被消费一次\\n\\n![image-20220701142648622](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207011426688.png)\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/4f607a38bb9f9d333c858205bfd38a55.jpg\",\"articleTitle\":\"Redis实现消息队列\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.4.227','湖南省永州市 电信','2022-07-02 17:20:53',NULL),(1213,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 分布式缓存\\n\\n-- 基于Redis集群解决单机Redis存在的问题\\n\\n\\n\\n单机的Redis存在四大问题：\\n\\n![image-20210725144240631](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723923.png)\\n\\n\\n\\n\\n\\n# 0.学习目标\\n\\n\\n\\n# 1.Redis持久化\\n\\nRedis有两种持久化方案：\\n\\n- RDB持久化\\n- AOF持久化\\n\\n\\n\\n## 1.1.RDB持久化\\n\\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\\n\\n### 1.1.1.执行时机\\n\\nRDB持久化在四种情况下会执行：\\n\\n- 执行save命令\\n- 执行bgsave命令\\n- Redis停机时\\n- 触发RDB条件时\\n\\n\\n\\n**1）save命令**\\n\\n执行下面的命令，可以立即执行一次RDB：\\n\\n![image-20210725144536958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723924.png)\\n\\nsave命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\\n\\n\\n\\n**2）bgsave命令**\\n\\n下面的命令可以异步执行RDB：\\n\\n![image-20210725144725943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723925.png)\\n\\n这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。\\n\\n\\n\\n**3）停机时**\\n\\nRedis停机时会执行一次save命令，实现RDB持久化。\\n\\n\\n\\n**4）触发RDB条件**\\n\\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\\n\\n```properties\\n# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \\\"\\\" 则表示禁用RDB\\nsave 900 1  \\nsave 300 10  \\nsave 60 10000 \\n```\\n\\n\\n\\nRDB的其它配置也可以在redis.conf文件中设置：\\n\\n```properties\\n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\\nrdbcompression yes\\n\\n# RDB文件名称\\ndbfilename dump.rdb  \\n\\n# 文件保存的路径目录\\ndir ./ \\n```\\n\\n\\n\\n### 1.1.2.RDB原理\\n\\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。\\n\\nfork采用的是copy-on-write技术：\\n\\n- 当主进程执行读操作时，访问共享内存；\\n- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。\\n\\n![image-20210725151319695](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723926.png)\\n\\n\\n\\n\\n\\n### 1.1.3.小结\\n\\nRDB方式bgsave的基本流程？\\n\\n- fork主进程得到一个子进程，共享内存空间\\n- 子进程读取内存数据并写入新的RDB文件\\n- 用新RDB文件替换旧的RDB文件\\n\\nRDB会在什么时候执行？save 60 1000代表什么含义？\\n\\n- 默认是服务停止时\\n- 代表60秒内至少执行1000次修改则触发RDB\\n\\nRDB的缺点？\\n\\n- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\\n- fork子进程、压缩、写出RDB文件都比较耗时\\n\\n\\n\\n## 1.2.AOF持久化\\n\\n\\n\\n### 1.2.1.AOF原理\\n\\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\\n\\n![image-20210725151543640](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723927.png)\\n\\n\\n\\n### 1.2.2.AOF配置\\n\\nAOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\\n\\n```properties\\n# 是否开启AOF功能，默认是no\\nappendonly yes\\n# AOF文件的名称\\nappendfilename \\\"appendonly.aof\\\"\\n```\\n\\n\\n\\nAOF的命令记录的频率也可以通过redis.conf文件来配：\\n\\n```properties\\n# 表示每执行一次写命令，立即记录到AOF文件\\nappendfsync always \\n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\\nappendfsync everysec \\n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\\nappendfsync no\\n```\\n\\n\\n\\n三种策略对比：\\n\\n![image-20210725151654046](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723928.png)\\n\\n\\n\\n### 1.2.3.AOF文件重写\\n\\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\\n\\n![image-20210725151729118](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723929.png)\\n\\n如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。\\n\\n所以重写命令后，AOF文件内容就是：`mset name jack num 666`\\n\\n\\n\\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\\n\\n```properties\\n# AOF文件比上次文件 增长超过多少百分比则触发重写\\nauto-aof-rewrite-percentage 100\\n# AOF文件体积最小多大以上才触发重写 \\nauto-aof-rewrite-min-size 64mb \\n```\\n\\n\\n\\n## 1.3.RDB与AOF对比\\n\\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。\\n\\n![image-20210725151940515](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723930.png)\\n\\n\\n\\n# 2.Redis主从\\n\\n## 2.1.搭建主从架构\\n\\n单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。\\n\\n![image-20210725152037611](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723931.png)\\n\\n具体搭建流程参考课前资料《Redis集群.md》：\\n\\n![image-20210725152052501](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723932.png) \\n\\n\\n\\n\\n\\n## 2.2.主从数据同步原理\\n\\n\\n\\n### 2.2.1.全量同步\\n\\n主从第一次建立连接时，会执行**全量同步**，将master节点的所有数据都拷贝给slave节点，流程：\\n\\n![image-20210725152222497](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723933.png)\\n\\n\\n\\n这里有一个问题，master如何得知salve是第一次来连接呢？？\\n\\n有几个概念，可以作为判断依据：\\n\\n- **Replication Id**：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid\\n- **offset**：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。\\n\\n因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。\\n\\n\\n\\n因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。\\n\\nmaster判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。\\n\\nmaster会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。\\n\\n因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致**。\\n\\n如图：\\n\\n![image-20210725152700914](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723934.png)\\n\\n\\n\\n完整流程描述：\\n\\n- slave节点请求增量同步\\n- master节点判断replid，发现不一致，拒绝增量同步\\n- master将完整内存数据生成RDB，发送RDB到slave\\n- slave清空本地数据，加载master的RDB\\n- master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave\\n- slave执行接收到的命令，保持与master之间的同步\\n\\n\\n\\n### 2.2.2.增量同步\\n\\n全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做**增量同步**。\\n\\n什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：\\n\\n![image-20210725153201086](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723935.png)\\n\\n\\n\\n那么master怎么知道slave与自己的数据差异在哪里呢?\\n\\n\\n\\n### 2.2.3.repl_backlog原理\\n\\nmaster怎么知道slave与自己的数据差异在哪里呢?\\n\\n这就要说到全量同步时的repl_baklog文件了。\\n\\n这个文件是一个固定大小的数组，只不过数组是环形，也就是说**角标到达数组末尾后，会再次从0开始读写**，这样数组头部的数据就会被覆盖。\\n\\nrepl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：\\n\\n![image-20210725153359022](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723937.png) \\n\\nslave与master的offset之间的差异，就是salve需要增量拷贝的数据了。\\n\\n随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：\\n\\n![image-20210725153524190](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723938.png) \\n\\n\\n\\n直到数组被填满：\\n\\n![image-20210725153715910](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723939.png) \\n\\n此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。\\n\\n\\n\\n但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： \\n\\n![image-20210725153937031](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723940.png) \\n\\n如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：\\n\\n![image-20210725154155984](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723941.png) \\n\\n\\n\\n棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。\\n\\n![image-20210725154216392](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723942.png)\\n\\n\\n\\n\\n\\n## 2.3.主从同步优化\\n\\n主从同步可以保证主从数据的一致性，非常重要。\\n\\n可以从以下几个方面来优化Redis主从就集群：\\n\\n- 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。\\n- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO\\n- 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步\\n- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力\\n\\n主从从架构图：\\n\\n![image-20210725154405899](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723943.png)\\n\\n\\n\\n## 2.4.小结\\n\\n简述全量同步和增量同步区别？\\n\\n- 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。\\n- 增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave\\n\\n什么时候执行全量同步？\\n\\n- slave节点第一次连接master节点时\\n- slave节点断开时间太久，repl_baklog中的offset已经被覆盖时\\n\\n什么时候执行增量同步？\\n\\n- slave节点断开又恢复，并且在repl_baklog中能找到offset时\\n\\n\\n\\n\\n\\n# 3.Redis哨兵\\n\\nRedis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。\\n\\n## 3.1.哨兵原理\\n\\n### 3.1.1.集群结构和作用\\n\\n哨兵的结构如图：\\n\\n![image-20210725154528072](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723944.png)\\n\\n哨兵的作用如下：\\n\\n- **监控**：Sentinel 会不断检查您的master和slave是否按预期工作\\n- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主\\n- **通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端\\n\\n\\n\\n### 3.1.2.集群监控原理\\n\\nSentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：\\n\\n•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。\\n\\n•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。\\n\\n![image-20210725154632354](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723945.png)\\n\\n\\n\\n### 3.1.3.集群故障恢复原理\\n\\n一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：\\n\\n- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点\\n- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举\\n- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高\\n- 最后是判断slave节点的运行id大小，越小优先级越高。\\n\\n\\n\\n当选出一个新的master后，该如何实现切换呢？\\n\\n流程如下：\\n\\n- sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master\\n- sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。\\n- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点\\n\\n\\n\\n![image-20210725154816841](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723946.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n### 3.1.4.小结\\n\\nSentinel的三个作用是什么？\\n\\n- 监控\\n- 故障转移\\n- 通知\\n\\nSentinel如何判断一个redis实例是否健康？\\n\\n- 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线\\n- 如果大多数sentinel都认为实例主观下线，则判定服务下线\\n\\n故障转移步骤有哪些？\\n\\n- 首先选定一个slave作为新的master，执行slaveof no one\\n- 然后让所有节点都执行slaveof 新master\\n- 修改故障节点配置，添加slaveof 新master\\n\\n\\n\\n## 3.2.搭建哨兵集群\\n\\n具体搭建流程参考课前资料《Redis集群.md》：\\n\\n![image-20210725155019276](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723947.png) \\n\\n\\n\\n## 3.3.RedisTemplate\\n\\n在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。\\n\\n下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。\\n\\n### 3.3.1.导入Demo工程\\n\\n首先，我们引入课前资料提供的Demo工程：\\n\\n![image-20210725155124958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723948.png) \\n\\n\\n\\n### 3.3.2.引入依赖\\n\\n在项目的pom文件中引入依赖：\\n\\n```xml\\n<dependency>\\n    <groupId>org.springframework.boot</groupId>\\n    <artifactId>spring-boot-starter-data-redis</artifactId>\\n</dependency>\\n```\\n\\n\\n\\n### 3.3.3.配置Redis地址\\n\\n然后在配置文件application.yml中指定redis的sentinel相关信息：\\n\\n```java\\nspring:\\n  redis:\\n    sentinel:\\n      master: mymaster\\n      nodes:\\n        - 192.168.150.101:27001\\n        - 192.168.150.101:27002\\n        - 192.168.150.101:27003\\n```\\n\\n\\n\\n### 3.3.4.配置读写分离\\n\\n在项目的启动类中，添加一个新的bean：\\n\\n```java\\n@Bean\\npublic LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){\\n    return clientConfigurationBuilder -> clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);\\n}\\n```\\n\\n\\n\\n这个bean中配置的就是读写策略，包括四种：\\n\\n- MASTER：从主节点读取\\n- MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica\\n- REPLICA：从slave（replica）节点读取\\n- REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master\\n\\n\\n\\n\\n\\n# 4.Redis分片集群\\n\\n\\n\\n## 4.1.搭建分片集群\\n\\n主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\\n\\n- 海量数据存储问题\\n\\n- 高并发写的问题\\n\\n使用分片集群可以解决上述问题，如图:\\n\\n![image-20210725155747294](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723949.png)\\n\\n\\n\\n分片集群特征：\\n\\n- 集群中有多个master，每个master保存不同数据\\n\\n- 每个master都可以有多个slave节点\\n\\n- master之间通过ping监测彼此健康状态\\n\\n- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点\\n\\n\\n\\n具体搭建流程参考课前资料《Redis集群.md》：\\n\\n![image-20210725155806288](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723950.png) \\n\\n\\n\\n## 4.2.散列插槽\\n\\n### 4.2.1.插槽原理\\n\\nRedis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：\\n\\n![image-20210725155820320](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723951.png)\\n\\n\\n\\n数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：\\n\\n- key中包含\\\"{}\\\"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分\\n- key中不包含“{}”，整个key都是有效部分\\n\\n\\n\\n\\n\\n例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。\\n\\n![image-20210725155850200](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723952.png) \\n\\n如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。\\n\\n到了7003后，执行`get num`时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点\\n\\n\\n\\n### 4.2.1.小结\\n\\nRedis如何判断某个key应该在哪个实例？\\n\\n- 将16384个插槽分配到不同的实例\\n- 根据key的有效部分计算哈希值，对16384取余\\n- 余数作为插槽，寻找插槽所在实例即可\\n\\n如何将同一类数据固定的保存在同一个Redis实例？\\n\\n- 这一类数据使用相同的有效部分，例如key都以{typeId}为前缀\\n\\n\\n\\n\\n\\n\\n\\n## 4.3.集群伸缩\\n\\nredis-cli --cluster提供了很多操作集群的命令，可以通过下面方式查看：\\n\\n![image-20210725160138290](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723953.png)\\n\\n比如，添加节点的命令：\\n\\n![image-20210725160448139](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723954.png)\\n\\n\\n\\n### 4.3.1.需求分析\\n\\n需求：向集群中添加一个新的master节点，并向其中存储 num = 10\\n\\n- 启动一个新的redis实例，端口为7004\\n- 添加7004到之前的集群，并作为一个master节点\\n- 给7004节点分配插槽，使得num这个key可以存储到7004实例\\n\\n\\n\\n这里需要两个新的功能：\\n\\n- 添加一个节点到集群中\\n- 将部分插槽分配到新插槽\\n\\n\\n\\n### 4.3.2.创建新的redis实例\\n\\n创建一个文件夹：\\n\\n```sh\\nmkdir 7004\\n```\\n\\n拷贝配置文件：\\n\\n```sh\\ncp redis.conf /7004\\n```\\n\\n修改配置文件：\\n\\n```sh\\nsed /s/6379/7004/g 7004/redis.conf\\n```\\n\\n启动\\n\\n```sh\\nredis-server 7004/redis.conf\\n```\\n\\n\\n\\n### 4.3.3.添加新节点到redis\\n\\n添加节点的语法如下：\\n\\n![image-20210725160448139](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723954.png)\\n\\n\\n\\n执行命令：\\n\\n```sh\\nredis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001\\n```\\n\\n\\n\\n通过命令查看集群状态：\\n\\n```sh\\nredis-cli -p 7001 cluster nodes\\n```\\n\\n\\n\\n如图，7004加入了集群，并且默认是一个master节点：\\n\\n![image-20210725161007099](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723955.png)\\n\\n但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上\\n\\n\\n\\n### 4.3.4.转移插槽\\n\\n我们要将num存储到7004节点，因此需要先看看num的插槽是多少：\\n\\n![image-20210725161241793](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723956.png)\\n\\n如上图所示，num的插槽为2765.\\n\\n\\n\\n我们可以将0~3000的插槽从7001转移到7004，命令格式如下：\\n\\n![image-20210725161401925](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723957.png)\\n\\n\\n\\n具体命令如下：\\n\\n建立连接：\\n\\n![image-20210725161506241](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723958.png)\\n\\n得到下面的反馈：\\n\\n![image-20210725161540841](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723959.png)\\n\\n\\n\\n询问要移动多少个插槽，我们计划是3000个：\\n\\n新的问题来了：\\n\\n![image-20210725161637152](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723960.png)\\n\\n那个node来接收这些插槽？？\\n\\n显然是7004，那么7004节点的id是多少呢？\\n\\n![image-20210725161731738](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723961.png)\\n\\n复制这个id，然后拷贝到刚才的控制台后：\\n\\n![image-20210725161817642](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723962.png)\\n\\n这里询问，你的插槽是从哪里移动过来的？\\n\\n- all：代表全部，也就是三个节点各转移一部分\\n- 具体的id：目标节点的id\\n- done：没有了\\n\\n\\n\\n这里我们要从7001获取，因此填写7001的id：\\n\\n![image-20210725162030478](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723963.png)\\n\\n填完后，点击done，这样插槽转移就准备好了：\\n\\n![image-20210725162101228](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723964.png)\\n\\n确认要转移吗？输入yes：\\n\\n然后，通过命令查看结果：\\n\\n![image-20210725162145497](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723965.png) \\n\\n可以看到： \\n\\n![image-20210725162224058](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723966.png)\\n\\n目的达成。\\n\\n\\n\\n\\n\\n## 4.4.故障转移\\n\\n集群初识状态是这样的：\\n\\n![image-20210727161152065](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723967.png)\\n\\n其中7001、7002、7003都是master，我们计划让7002宕机。\\n\\n\\n\\n### 4.4.1.自动故障转移\\n\\n当集群中有一个master宕机会发生什么呢？\\n\\n直接停止一个redis实例，例如7002：\\n\\n```sh\\nredis-cli -p 7002 shutdown\\n```\\n\\n\\n\\n1）首先是该实例与其它实例失去连接\\n\\n2）然后是疑似宕机：\\n\\n![image-20210725162319490](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723968.png)\\n\\n3）最后是确定下线，自动提升一个slave为新的master：\\n\\n![image-20210725162408979](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723969.png)\\n\\n4）当7002再次启动，就会变为一个slave节点了：\\n\\n![image-20210727160803386](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723970.png)\\n\\n\\n\\n### 4.4.2.手动故障转移\\n\\n利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：\\n\\n![image-20210725162441407](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723971.png)\\n\\n\\n\\n这种failover命令可以指定三种模式：\\n\\n- 缺省：默认的流程，如图1~6歩\\n- force：省略了对offset的一致性校验\\n- takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见\\n\\n\\n\\n**案例需求**：在7002这个slave节点执行手动故障转移，重新夺回master地位\\n\\n步骤如下：\\n\\n1）利用redis-cli连接7002这个节点\\n\\n2）执行cluster failover命令\\n\\n如图：\\n\\n![image-20210727160037766](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723972.png)\\n\\n\\n\\n效果：\\n\\n![image-20210727161152065](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723967.png)\\n\\n\\n\\n## 4.5.RedisTemplate访问分片集群\\n\\nRedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：\\n\\n1）引入redis的starter依赖\\n\\n2）配置分片集群地址\\n\\n3）配置读写分离\\n\\n与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：\\n\\n```yaml\\nspring:\\n  redis:\\n    cluster:\\n      nodes:\\n        - 192.168.150.101:7001\\n        - 192.168.150.101:7002\\n        - 192.168.150.101:7003\\n        - 192.168.150.101:8001\\n        - 192.168.150.101:8002\\n        - 192.168.150.101:8003\\n```\\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/ad41d14a2ca9c12b629ac97ab0387df3.jpg\",\"articleTitle\":\"Redis高级-分布式缓存\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.4.227','湖南省永州市 电信','2022-07-02 18:57:46',NULL),(1214,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 1.Redis持久化\\n\\nRedis有两种持久化方案：\\n\\n- RDB持久化\\n- AOF持久化\\n\\n\\n\\n## 1.1.RDB持久化\\n\\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。\\n\\n### 1.1.1.执行时机\\n\\nRDB持久化在四种情况下会执行：\\n\\n- 执行save命令\\n- 执行bgsave命令\\n- Redis停机时\\n- 触发RDB条件时\\n\\n\\n\\n**1）save命令**\\n\\n执行下面的命令，可以立即执行一次RDB：\\n\\n![image-20210725144536958](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723924.png)\\n\\nsave命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。\\n\\n\\n\\n**2）bgsave命令**\\n\\n下面的命令可以异步执行RDB：\\n\\n![image-20210725144725943](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723925.png)\\n\\n这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。\\n\\n\\n\\n**3）停机时**\\n\\nRedis停机时会执行一次save命令，实现RDB持久化。\\n\\n\\n\\n**4）触发RDB条件**\\n\\nRedis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：\\n\\n```properties\\n# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save \\\"\\\" 则表示禁用RDB\\nsave 900 1  \\nsave 300 10  \\nsave 60 10000 \\n```\\n\\n\\n\\nRDB的其它配置也可以在redis.conf文件中设置：\\n\\n```properties\\n# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱\\nrdbcompression yes\\n\\n# RDB文件名称\\ndbfilename dump.rdb  \\n\\n# 文件保存的路径目录\\ndir ./ \\n```\\n\\n\\n\\n### 1.1.2.RDB原理\\n\\nbgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。\\n\\nfork采用的是copy-on-write技术：\\n\\n- 当主进程执行读操作时，访问共享内存；\\n- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。\\n\\n![image-20210725151319695](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723926.png)\\n\\n\\n\\n\\n\\n### 1.1.3.小结\\n\\nRDB方式bgsave的基本流程？\\n\\n- fork主进程得到一个子进程，共享内存空间\\n- 子进程读取内存数据并写入新的RDB文件\\n- 用新RDB文件替换旧的RDB文件\\n\\nRDB会在什么时候执行？save 60 1000代表什么含义？\\n\\n- 默认是服务停止时\\n- 代表60秒内至少执行1000次修改则触发RDB\\n\\nRDB的缺点？\\n\\n- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险\\n- fork子进程、压缩、写出RDB文件都比较耗时\\n\\n\\n\\n## 1.2.AOF持久化\\n\\n\\n\\n### 1.2.1.AOF原理\\n\\nAOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。\\n\\n![image-20210725151543640](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723927.png)\\n\\n\\n\\n### 1.2.2.AOF配置\\n\\nAOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：\\n\\n```properties\\n# 是否开启AOF功能，默认是no\\nappendonly yes\\n# AOF文件的名称\\nappendfilename \\\"appendonly.aof\\\"\\n```\\n\\n\\n\\nAOF的命令记录的频率也可以通过redis.conf文件来配：\\n\\n```properties\\n# 表示每执行一次写命令，立即记录到AOF文件\\nappendfsync always \\n# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案\\nappendfsync everysec \\n# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘\\nappendfsync no\\n```\\n\\n\\n\\n三种策略对比：\\n\\n![image-20210725151654046](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723928.png)\\n\\n\\n\\n### 1.2.3.AOF文件重写\\n\\n因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。\\n\\n![image-20210725151729118](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723929.png)\\n\\n如图，AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。\\n\\n所以重写命令后，AOF文件内容就是：`mset name jack num 666`\\n\\n\\n\\nRedis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：\\n\\n```properties\\n# AOF文件比上次文件 增长超过多少百分比则触发重写\\nauto-aof-rewrite-percentage 100\\n# AOF文件体积最小多大以上才触发重写 \\nauto-aof-rewrite-min-size 64mb \\n```\\n\\n\\n\\n## 1.3.RDB与AOF对比\\n\\nRDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。\\n\\n![image-20210725151940515](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207021723930.png)\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e25d332a34576199842e1298e8b06000.jpg\",\"articleTitle\":\"面试官：Redis持久化了解吗\",\"categoryName\":\"Java面经\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.4.227','湖南省永州市 电信','2022-07-02 19:01:31',NULL),(1215,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# MySQL进阶（存储引擎）\\n\\n# 1. 存储引擎\\n\\n## 1.1 MySQL体系结构\\n\\n![image-20220707010322642](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070103898.png)\\n\\n1). 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。 \\n\\n2). 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。 \\n\\n3). 引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。 \\n\\n4). 存储层 数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。\\n\\n## 1.2 存储引擎介绍\\n\\n![image-20220707010442964](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070104051.png)\\n\\n大家可能没有听说过存储引擎，但是一定听过引擎这个词，引擎就是发动机，是一个机器的核心组件。 比如，对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择 引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎 一样。 \\n\\n而对于存储引擎，也是一样，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。 \\n\\n**存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。**\\n\\n我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。\\n\\n1). 建表时指定存储引擎\\n\\n``` sql\\nCREATE TABLE 表名(\\n字段1 字段1类型 [ COMMENT 字段1注释 ] ,\\n......\\n字段n 字段n类型 [COMMENT 字段n注释 ]\\n) ENGINE = INNODB [ COMMENT 表注释 ] ;\\n```\\n\\n2). 查询当前数据库支持的存储引擎\\n\\n``` sql\\nshow engines;\\n```\\n\\n示例演示: \\n\\nA. 查询建表语句 --- 默认存储引擎: InnoDB\\n\\n``` sql\\nshow create table account;\\n```\\n\\n![image-20220707010813226](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070108263.png)\\n\\n我们可以看到，创建表时，即使我们没有指定存储引擎，数据库也会自动选择默认的存储引擎。\\n\\nB. 查询当前数据库支持的存储引擎\\n\\n``` sql\\n show engines ;\\n```\\n\\n![image-20220707010908844](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070109879.png)\\n\\nC. 创建表 my_myisam , 并指定MyISAM存储引擎\\n\\n``` sql\\ncreate table my_myisam(\\nid int,\\nname varchar(10)\\n) engine = MyISAM ;\\n```\\n\\nD. 创建表 my_memory , 指定Memory存储引擎\\n\\n``` sql\\ncreate table my_memory(\\nid int,\\nname varchar(10)\\n) engine = Memory ;\\n```\\n\\n## 1.3 存储引擎特点\\n\\n上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面 重点提到的三种存储引擎 **InnoDB、MyISAM、Memory**的特点。\\n\\n### 1.3.1 InnoDB \\n\\n#### 1). 介绍 \\n\\nInnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。\\n\\n#### 2). 特点 \\n\\n- DML操作遵循ACID模型，支持事务； \\n\\n- 行级锁，提高并发访问性能； \\n\\n- 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\\n\\n  **事务、外键，行级锁**\\n\\n#### 3). 文件 \\n\\nxxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。\\n\\n参数：innodb_file_per_table\\n\\n``` sql\\nshow variables like \'innodb_file_per_table\\n```\\n\\n![image-20220707011241280](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070112316.png)\\n\\n如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的 数据存放目录： C:\\\\ProgramData\\\\MySQL\\\\MySQL Server 8.0\\\\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。\\n\\n![image-20220707011305747](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070113777.png)\\n\\n可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。\\n\\n![image-20220707011400729](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070114794.png)\\n\\n#### 4). 逻辑存储结构\\n\\n![image-20220707011441036](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070114094.png)\\n\\n- 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 \\n- 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 \\n- 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 \\n- 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 \\n- 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。\\n\\n### 1.3.2 MyISAM \\n\\n#### 1). 介绍 \\n\\nMyISAM是MySQL早期的默认存储引擎。\\n\\n#### 2). 特点 \\n\\n- 不支持事务，不支持外键 \\n\\n- 支持表锁，不支持行锁 \\n\\n- 访问速度快\\n\\n#### 3). 文件 \\n\\nxxx.sdi：存储表结构信息 \\n\\nxxx.MYD: 存储数据 \\n\\nxxx.MYI: 存储索引\\n\\n![image-20220707011634576](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070116613.png)\\n\\n### 1.3.3 Memory \\n\\n#### 1). 介绍 \\n\\nMemory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。 \\n\\n#### 2). 特点 \\n\\n内存存放 hash索引（默认） \\n\\n#### 3).文件 \\n\\nxxx.sdi：存储表结构信息\\n\\n### 1.3.4 区别及特点\\n\\n![image-20220707011808103](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207070118166.png)\\n\\n> 面试题: \\n>\\n> InnoDB引擎与MyISAM引擎的区别 ? \\n>\\n> ①. InnoDB引擎, 支持事务, 而MyISAM不支持。 \\n>\\n> ②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 \\n>\\n> ③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 \\n>\\n> 主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：\\n>\\n> https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html \\n>\\n> https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html\\n\\n## 1.4 存储引擎选择 \\n\\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 \\n\\n- InnoDB: 是Mysql的默认存储引擎，支持**事务、外键，行级锁**。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 \\n- MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 \\n- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/754cca93d7c5838b8ffb899b7d7e8b7e.jpg\",\"articleTitle\":\"MySQL进阶（存储引擎）\",\"categoryName\":\"MySQL\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.6.18','湖南省永州市 电信','2022-07-07 21:54:01',NULL),(1216,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# MySQL进阶（索引）\\n\\n## 2.索引 \\n\\n### 2.1 索引概述 \\n\\n#### 2.1.1 介绍 \\n\\n**索引（index）是帮助MySQL高效获取数据的数据结构(有序)。**在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。\\n\\n![image-20220707215557913](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072155020.png)\\n\\n#### 2.1.2 演示 \\n\\n表结构及其数据如下：\\n\\n![image-20220707215622697](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072156746.png)\\n\\n假如我们要执行的SQL语句为 ： select * from user where age = 45;\\n\\n1). 无索引情况\\n\\n![image-20220707220024388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072200456.png)\\n\\n**在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。** \\n\\n2). 有索引情况\\n\\n如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。\\n\\n![image-20220707220150036](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072201094.png)\\n\\n此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。\\n\\n> 备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并 不是索引的真实结构，索引的真实结构，后面会详细介绍。\\n\\n#### 2.1.3 特点\\n\\n| 优势                                                         | 劣势                                                         |\\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\\n| 提高数据检索的效率，降低数据库的IO成本                       | 索引列也是要占用空间的                                       |\\n| 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。 |\\n\\n### 2.2 索引结构 \\n\\n#### 2.2.1 概述 \\n\\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\\n\\n| 索引结构             | 描述                                                         |\\n| -------------------- | ------------------------------------------------------------ |\\n| B+Tree索引           | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |\\n| Hash索引             | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询 |\\n| R-tree(空间索 引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少 |\\n| Full-text(全文 索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES |\\n\\n上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持 情况。\\n\\n| 索引        | InnoDB          | MyISAM | Memory |\\n| ----------- | --------------- | ------ | ------ |\\n| B+tree索引  | 支持            | 支持   | 支持   |\\n| Hash 索引   | 不支持          | 不支持 | 支持   |\\n| R-tree 索引 | 不支持          | 支持   | 不支持 |\\n| Full-text   | 5.6版本之后支持 | 支持   | 不支持 |\\n\\n> 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。\\n\\n#### 2.2.2 二叉树 \\n\\n假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：\\n\\n![image-20220707221524346](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215390.png)\\n\\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\\n\\n![image-20220707221541844](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215881.png)\\n\\n所以，如果选择二叉树作为索引结构，会存在以下缺点\\n\\n- 顺序插入时，会形成一个链表，查询性能大大降低。\\n- 大数据量情况下，层级较深，检索速度慢。\\n\\n此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:\\n\\n![image-20220707221654789](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072216826.png)\\n\\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\\n\\n- 大数据量情况下，层级较深，检索速度慢。\\n\\n所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是 B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。\\n\\n#### 2.2.3 B-Tree\\n\\nB-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 \\n\\n以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：\\n\\n![image-20220707222217777](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072222823.png)\\n\\n> 知识小贴士: 树的度数指的是一个节点的子节点个数。\\n\\n特点： \\n\\n- 5阶的B树，每一个节点最多存储4个key，对应5个指针。 \\n- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 \\n- 在B树中，非叶子节点和叶子节点都会存放数据。\\n\\n#### 2.2.4 B+Tree \\n\\nB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：\\n\\n![image-20220707222506931](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072225965.png)\\n\\n我们可以看到，两部分： \\n\\n- 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 \\n- 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\\n\\n最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： \\n\\n- 所有的数据都会出现在叶子节点。 \\n- 叶子节点形成一个单向链表。 \\n- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\\n\\n上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的 B+Tree。 \\n\\n**MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。**\\n\\n#### 2.2.5 Hash \\n\\nMySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。 \\n\\n1). 结构 \\n\\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。\\n\\n![image-20220707223044525](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072230585.png)\\n\\n如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。\\n\\n2). 特点 \\n\\nA. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...） \\n\\nB. 无法利用索引完成排序操作 \\n\\nC. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引\\n\\n3). 存储引擎支持 \\n\\n在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。\\n\\n> 面试题：为什么InnoDB选择B+Tree作为索引结构\\n>\\n> A. 相对于二叉树，层级更少，搜索效率高； \\n>\\n> B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； \\n>\\n> C. 相对Hash索引，B+tree支持范围匹配及排序操作；\\n\\n### 2.3 索引分类 \\n\\n#### 2.3.1 索引分类 \\n\\n在MySQL数据库，将索引的具体类型主要分为以下几类：**主键索引、唯一索引、常规索引、全文索引**。\\n\\n| 分类      | 含义                                                  | 特点                      | 关键字   |\\n| --------- | ----------------------------------------------------- | ------------------------- | -------- |\\n| 主键 索引 | 针对于表中主键创建的索引                              | 默认自动创建, 只能 有一个 | PRIMARY  |\\n| 唯一 索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                | UNIQUE   |\\n| 常规 索引 | 快速定位特定数据                                      | 可以有多个                |          |\\n| 全文 索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                | FULLTEXT |\\n\\n#### 2.3.2 聚集索引&二级索引 \\n\\n而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\\n\\n| 分类                      | 含义                                                        | 特点                 |\\n| ------------------------- | ----------------------------------------------------------- | -------------------- |\\n| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 | 必须有,而且只 有一个 |\\n| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 | 可以存在多个         |\\n\\n聚集索引选取规则: \\n\\n- 如果存在主键，主键索引就是聚集索引。\\n- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 \\n- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。\\n\\n聚集索引和二级索引的具体结构如下：\\n\\n![image-20220707224328188](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072243281.png)\\n\\n- 聚集索引的叶子节点下挂的是这一行的数据 。 \\n- 二级索引的叶子节点下挂的是该字段值对应的主键值。\\n\\n接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\\n\\n![image-20220707224404166](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072244220.png)\\n\\n具体过程如下:\\n\\n①. 由于是根据name字段进行查询，所以先根据name=\'Arm\'到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。\\n\\n②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。 \\n\\n③. 最终拿到这一行的数据，直接返回即可\\n\\n> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。\\n\\n### 2.4 索引语法 \\n\\n1). 创建索引\\n\\n``` sql\\nCREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (\\nindex_col_name,... ) ;\\n```\\n\\n2). 查看索引\\n\\n``` sql\\nshow index FROM table_name ;\\n```\\n\\n3). 删除索引\\n\\n``` sql\\nDROP INDEX index_name ON table_name ;\\n```\\n\\n4). 创建联合索引\\n\\n``` sql\\nCREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);\\n```\\n\\n### 2.5 SQL性能分析 \\n\\n#### 2.5.1 SQL执行频率\\n\\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\\n\\n``` sql\\n-- session 是查看当前会话 ;\\n-- global 是查询全局数据 ;\\nSHOW GLOBAL STATUS LIKE \'Com_______\';\\n-- 7个下划线\\n```\\n\\n> Com_delete: 删除次数\\n>\\n> Com_insert: 插入次数 \\n>\\n> Com_select: 查询次数 \\n>\\n> Com_update: 更新次数\\n>\\n> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。\\n\\n那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假 如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询 日志。 \\n\\n接下来，我们就来介绍一下MySQL中的慢查询日志。\\n\\n#### 2.5.2 慢查询日志 \\n\\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。\\n\\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\\n\\n``` sql\\nshow variables like \'slow_query_log\'\\n```\\n\\n![image-20220707225306618](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072253672.png)\\n\\n如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\\n\\n``` shell\\n# 开启MySQL慢日志查询开关\\nslow_query_log=1\\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\\nlong_query_time=2\\n```\\n\\n配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。\\n\\n``` sh\\nsystemctl restart mysqld\\n```\\n\\n然后，再次查看开关情况，慢查询日志就已经打开了。\\n\\n![image-20220707225447531](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072254588.png)\\n\\n#### 2.5.3 profile详情\\n\\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：\\n\\n``` sql\\nSELECT @@have_profiling ;\\n```\\n\\n![image-20220707230356949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072303036.png)\\n\\n可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：\\n\\n``` sql\\nSET profiling = 1;\\n```\\n\\n开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 我们直接执行如下的SQL语句：\\n\\n``` sql\\nselect * from tb_user;\\nselect * from tb_user where id = 1;\\nselect * from tb_user where name = \'白起\';\\nselect count(*) from tb_sku;\\n```\\n\\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\\n\\n``` sql\\n-- 查看每一条SQL的耗时基本情况\\nshow profiles;\\n-- 查看指定query_id的SQL语句各个阶段的耗时情况\\nshow profile for query query_id;\\n-- 查看指定query_id的SQL语句CPU的使用情况\\nshow profile cpu for query query_id;\\n```\\n\\n查看每一条SQL的耗时情况:\\n\\n``` sql\\nshow profiles\\n```\\n\\n![image-20220707230532714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072305799.png)\\n\\n查看指定SQL各个阶段的耗时情况 :\\n\\n![image-20220707230606309](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072306430.png)\\n\\n#### 2.5.4 explain（执行计划）\\n\\nEXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。\\n\\n语法:\\n\\n``` sql\\n-- 直接在select语句之前加上关键字 explain / desc\\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;\\n```\\n\\n![image-20220707230717108](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072307176.png)\\n\\nExplain 执行计划中各个字段的含义:\\n\\n| 字段         | 含义                                                         |\\n| ------------ | ------------------------------------------------------------ |\\n| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |\\n| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 |\\n| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 |\\n| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |\\n| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |\\n| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 |\\n| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |\\n| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |\\n\\n### 2.6 索引使用\\n\\n#### 2.6.1 最左前缀法则\\n\\n如果索引了多列（联合索引），要遵守最左前缀法则。\\n\\n**最左前缀法则指的是查询从联合索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。**\\n\\n> 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。\\n\\n#### 2.6.2 范围查询 \\n\\n联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。\\n\\n``` sql\\nexplain select * from tb_user where profession = \'软件工程\' and age > 30 and status\\n= \'0\';\\n```\\n\\n![image-20220707232234948](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072322008.png)\\n\\n当范围查询使用> 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。\\n\\n``` sql\\nexplain select * from tb_user where profession = \'软件工程\' and age >= 30 and\\nstatus = \'0\';\\n```\\n\\n![image-20220707232306611](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072323670.png)\\n\\n当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。\\n\\n所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 < 。\\n\\n#### 2.6.3 索引失效情况 \\n\\n##### 2.6.3.1 索引列运算 \\n\\n不要在索引列上进行运算操作， 索引将失效。\\n\\n- 比如各种运算符运算（substring）\\n\\n##### 2.6.3.2 字符串不加引号 \\n\\n字符串类型字段使用时，不加引号，索引将失效。\\n\\n**如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。**\\n\\n##### 2.6.3.3 模糊查询 \\n\\n**如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。**\\n\\n##### 2.6.3.4 or连接条件 \\n\\n**用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。**（or前后必须都有索引）\\n\\n##### 2.6.3.5 数据分布影响 \\n\\n如果MySQL评估使用索引比全表更慢，则不使用索引。\\n\\n就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。\\n\\n#### 2.6.5 SQL提示\\n\\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。\\n\\n1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。\\n\\n``` sql\\nexplain select * from tb_user use index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n2). ignore index ： 忽略指定的索引。\\n\\n``` sql\\nexplain select * from tb_user ignore index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n3). force index ： 强制使用索引。\\n\\n``` sql\\nexplain select * from tb_user force index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n#### 2.6.6 覆盖索引 \\n\\n尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。\\n\\n#### 2.6.7 前缀索引 \\n\\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。\\n\\n1). 语法\\n\\n``` sql\\ncreate index idx_xxxx on table_name(column(n)) ;\\n```\\n\\n2). 前缀长度 \\n\\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\\n\\n``` sql\\nselect count(distinct email) / count(*) from tb_user ;\\nselect count(distinct substring(email,1,5)) / count(*) from tb_user ;\\n```\\n\\n3). 前缀索引的查询流程\\n\\n![image-20220707233417388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072334452.png)\\n\\n#### 2.6.8 单列索引与联合索引 \\n\\n单列索引：即一个索引只包含单个列。 \\n\\n联合索引：即一个索引包含了多个列\\n\\n> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。\\n\\n### 2.7 索引设计原则 \\n\\n1). 针对于数据量较大，且查询比较频繁的表建立索引。 \\n\\n2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。 \\n\\n3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 \\n\\n4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 \\n\\n5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 \\n\\n6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。 \\n\\n7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2a392709367b0c972a09663e2c2ca44.jpg\",\"articleTitle\":\"MySQL进阶（索引）\",\"categoryName\":\"MySQL\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.6.18','湖南省永州市 电信','2022-07-07 23:36:45',NULL),(1217,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"# <center>梦想是成为一个浪漫的程序员</center> #\\n### 个人简介\\n**编程小白**，一名就读于长沙的在校大二学生，软件技术专业，主修**java后端**\\n\\n### 联系方式：\\nQQ:**762188827**\\n\\nGitee：**[Gitee](https://gitee.com/icatw)**\\n\\nGitHub：**[GitHub](https://github.com/icatw)**\\n\\n欢迎与我交流~\\n\\n**个人微信**：\\n![个人微信.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d729cb701da0db0f7146025c611ef332.png)\\n\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-09-06 14:11:37',NULL),(1218,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# MySQL进阶（索引）\\n\\n## 2.索引 \\n\\n### 2.1 索引概述 \\n\\n#### 2.1.1 介绍 \\n\\n**索引（index）是帮助MySQL高效获取数据的数据结构(有序)。**在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。\\n\\n![image-20220707215557913](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072155020.png)\\n\\n#### 2.1.2 演示 \\n\\n表结构及其数据如下：\\n\\n![image-20220707215622697](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072156746.png)\\n\\n假如我们要执行的SQL语句为 ： select * from user where age = 45;\\n\\n1). 无索引情况\\n\\n![image-20220707220024388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072200456.png)\\n\\n**在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很低。** \\n\\n2). 有索引情况\\n\\n如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。\\n\\n![image-20220707220150036](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072201094.png)\\n\\n此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。\\n\\n> 备注： 这里我们只是假设索引的结构是二叉树，介绍一下索引的大概原理，只是一个示意图，并 不是索引的真实结构，索引的真实结构，后面会详细介绍。\\n\\n#### 2.1.3 特点\\n\\n| 优势                                                         | 劣势                                                         |\\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\\n| 提高数据检索的效率，降低数据库的IO成本                       | 索引列也是要占用空间的                                       |\\n| 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。 |\\n\\n### 2.2 索引结构 \\n\\n#### 2.2.1 概述 \\n\\nMySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：\\n\\n| 索引结构             | 描述                                                         |\\n| -------------------- | ------------------------------------------------------------ |\\n| B+Tree索引           | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |\\n| Hash索引             | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询 |\\n| R-tree(空间索 引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少 |\\n| Full-text(全文 索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES |\\n\\n上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持 情况。\\n\\n| 索引        | InnoDB          | MyISAM | Memory |\\n| ----------- | --------------- | ------ | ------ |\\n| B+tree索引  | 支持            | 支持   | 支持   |\\n| Hash 索引   | 不支持          | 不支持 | 支持   |\\n| R-tree 索引 | 不支持          | 支持   | 不支持 |\\n| Full-text   | 5.6版本之后支持 | 支持   | 不支持 |\\n\\n> 注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。\\n\\n#### 2.2.2 二叉树 \\n\\n假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：\\n\\n![image-20220707221524346](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215390.png)\\n\\n如果主键是顺序插入的，则会形成一个单向链表，结构如下：\\n\\n![image-20220707221541844](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072215881.png)\\n\\n所以，如果选择二叉树作为索引结构，会存在以下缺点\\n\\n- 顺序插入时，会形成一个链表，查询性能大大降低。\\n- 大数据量情况下，层级较深，检索速度慢。\\n\\n此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:\\n\\n![image-20220707221654789](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072216826.png)\\n\\n但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：\\n\\n- 大数据量情况下，层级较深，检索速度慢。\\n\\n所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是 B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。\\n\\n#### 2.2.3 B-Tree\\n\\nB-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 \\n\\n以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：\\n\\n![image-20220707222217777](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072222823.png)\\n\\n> 知识小贴士: 树的度数指的是一个节点的子节点个数。\\n\\n特点： \\n\\n- 5阶的B树，每一个节点最多存储4个key，对应5个指针。 \\n- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 \\n- 在B树中，非叶子节点和叶子节点都会存放数据。\\n\\n#### 2.2.4 B+Tree \\n\\nB+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：\\n\\n![image-20220707222506931](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072225965.png)\\n\\n我们可以看到，两部分： \\n\\n- 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 \\n- 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。\\n\\n最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： \\n\\n- 所有的数据都会出现在叶子节点。 \\n- 叶子节点形成一个单向链表。 \\n- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。\\n\\n上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的 B+Tree。 \\n\\n**MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。**\\n\\n#### 2.2.5 Hash \\n\\nMySQL中除了支持B+Tree索引，还支持一种索引类型---Hash索引。 \\n\\n1). 结构 \\n\\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。\\n\\n![image-20220707223044525](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072230585.png)\\n\\n如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。\\n\\n2). 特点 \\n\\nA. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...） \\n\\nB. 无法利用索引完成排序操作 \\n\\nC. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引\\n\\n3). 存储引擎支持 \\n\\n在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。\\n\\n> 面试题：为什么InnoDB选择B+Tree作为索引结构\\n>\\n> A. 相对于二叉树，层级更少，搜索效率高； \\n>\\n> B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低； \\n>\\n> C. 相对Hash索引，B+tree支持范围匹配及排序操作；\\n\\n### 2.3 索引分类 \\n\\n#### 2.3.1 索引分类 \\n\\n在MySQL数据库，将索引的具体类型主要分为以下几类：**主键索引、唯一索引、常规索引、全文索引**。\\n\\n| 分类      | 含义                                                  | 特点                      | 关键字   |\\n| --------- | ----------------------------------------------------- | ------------------------- | -------- |\\n| 主键 索引 | 针对于表中主键创建的索引                              | 默认自动创建, 只能 有一个 | PRIMARY  |\\n| 唯一 索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                | UNIQUE   |\\n| 常规 索引 | 快速定位特定数据                                      | 可以有多个                |          |\\n| 全文 索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                | FULLTEXT |\\n\\n#### 2.3.2 聚集索引&二级索引 \\n\\n而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\\n\\n| 分类                      | 含义                                                        | 特点                 |\\n| ------------------------- | ----------------------------------------------------------- | -------------------- |\\n| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 | 必须有,而且只 有一个 |\\n| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 | 可以存在多个         |\\n\\n聚集索引选取规则: \\n\\n- 如果存在主键，主键索引就是聚集索引。\\n- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 \\n- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。\\n\\n聚集索引和二级索引的具体结构如下：\\n\\n![image-20220707224328188](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072243281.png)\\n\\n- 聚集索引的叶子节点下挂的是这一行的数据 。 \\n- 二级索引的叶子节点下挂的是该字段值对应的主键值。\\n\\n接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。\\n\\n![image-20220707224404166](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072244220.png)\\n\\n具体过程如下:\\n\\n①. 由于是根据name字段进行查询，所以先根据name=\'Arm\'到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。\\n\\n②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。 \\n\\n③. 最终拿到这一行的数据，直接返回即可\\n\\n> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。\\n\\n### 2.4 索引语法 \\n\\n1). 创建索引\\n\\n``` sql\\nCREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (\\nindex_col_name,... ) ;\\n```\\n\\n2). 查看索引\\n\\n``` sql\\nshow index FROM table_name ;\\n```\\n\\n3). 删除索引\\n\\n``` sql\\nDROP INDEX index_name ON table_name ;\\n```\\n\\n4). 创建联合索引\\n\\n``` sql\\nCREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);\\n```\\n\\n### 2.5 SQL性能分析 \\n\\n#### 2.5.1 SQL执行频率\\n\\nMySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：\\n\\n``` sql\\n-- session 是查看当前会话 ;\\n-- global 是查询全局数据 ;\\nSHOW GLOBAL STATUS LIKE \'Com_______\';\\n-- 7个下划线\\n```\\n\\n> Com_delete: 删除次数\\n>\\n> Com_insert: 插入次数 \\n>\\n> Com_select: 查询次数 \\n>\\n> Com_update: 更新次数\\n>\\n> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。\\n\\n那么通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假 如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询 日志。 \\n\\n接下来，我们就来介绍一下MySQL中的慢查询日志。\\n\\n#### 2.5.2 慢查询日志 \\n\\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。\\n\\nMySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。\\n\\n``` sql\\nshow variables like \'slow_query_log\'\\n```\\n\\n![image-20220707225306618](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072253672.png)\\n\\n如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\\n\\n``` shell\\n# 开启MySQL慢日志查询开关\\nslow_query_log=1\\n# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\\nlong_query_time=2\\n```\\n\\n配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。\\n\\n``` sh\\nsystemctl restart mysqld\\n```\\n\\n然后，再次查看开关情况，慢查询日志就已经打开了。\\n\\n![image-20220707225447531](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072254588.png)\\n\\n#### 2.5.3 profile详情\\n\\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：\\n\\n``` sql\\nSELECT @@have_profiling ;\\n```\\n\\n![image-20220707230356949](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072303036.png)\\n\\n可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：\\n\\n``` sql\\nSET profiling = 1;\\n```\\n\\n开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 我们直接执行如下的SQL语句：\\n\\n``` sql\\nselect * from tb_user;\\nselect * from tb_user where id = 1;\\nselect * from tb_user where name = \'白起\';\\nselect count(*) from tb_sku;\\n```\\n\\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：\\n\\n``` sql\\n-- 查看每一条SQL的耗时基本情况\\nshow profiles;\\n-- 查看指定query_id的SQL语句各个阶段的耗时情况\\nshow profile for query query_id;\\n-- 查看指定query_id的SQL语句CPU的使用情况\\nshow profile cpu for query query_id;\\n```\\n\\n查看每一条SQL的耗时情况:\\n\\n``` sql\\nshow profiles\\n```\\n\\n![image-20220707230532714](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072305799.png)\\n\\n查看指定SQL各个阶段的耗时情况 :\\n\\n![image-20220707230606309](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072306430.png)\\n\\n#### 2.5.4 explain（执行计划）\\n\\nEXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。\\n\\n语法:\\n\\n``` sql\\n-- 直接在select语句之前加上关键字 explain / desc\\nEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;\\n```\\n\\n![image-20220707230717108](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072307176.png)\\n\\nExplain 执行计划中各个字段的含义:\\n\\n| 字段         | 含义                                                         |\\n| ------------ | ------------------------------------------------------------ |\\n| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |\\n| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 |\\n| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 |\\n| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |\\n| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |\\n| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 |\\n| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |\\n| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |\\n\\n### 2.6 索引使用\\n\\n#### 2.6.1 最左前缀法则\\n\\n如果索引了多列（联合索引），要遵守最左前缀法则。\\n\\n**最左前缀法则指的是查询从联合索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。**\\n\\n> 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。\\n\\n#### 2.6.2 范围查询 \\n\\n联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。\\n\\n``` sql\\nexplain select * from tb_user where profession = \'软件工程\' and age > 30 and status\\n= \'0\';\\n```\\n\\n![image-20220707232234948](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072322008.png)\\n\\n当范围查询使用> 或 < 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。\\n\\n``` sql\\nexplain select * from tb_user where profession = \'软件工程\' and age >= 30 and\\nstatus = \'0\';\\n```\\n\\n![image-20220707232306611](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072323670.png)\\n\\n当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。\\n\\n所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 < 。\\n\\n#### 2.6.3 索引失效情况 \\n\\n##### 2.6.3.1 索引列运算 \\n\\n不要在索引列上进行运算操作， 索引将失效。\\n\\n- 比如各种运算符运算（substring）\\n\\n##### 2.6.3.2 字符串不加引号 \\n\\n字符串类型字段使用时，不加引号，索引将失效。\\n\\n**如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。**\\n\\n##### 2.6.3.3 模糊查询 \\n\\n**如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。**\\n\\n##### 2.6.3.4 or连接条件 \\n\\n**用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。**（or前后必须都有索引）\\n\\n##### 2.6.3.5 数据分布影响 \\n\\n如果MySQL评估使用索引比全表更慢，则不使用索引。\\n\\n就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。\\n\\n#### 2.6.5 SQL提示\\n\\nSQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。\\n\\n1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。\\n\\n``` sql\\nexplain select * from tb_user use index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n2). ignore index ： 忽略指定的索引。\\n\\n``` sql\\nexplain select * from tb_user ignore index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n3). force index ： 强制使用索引。\\n\\n``` sql\\nexplain select * from tb_user force index(idx_user_pro) where profession = \'软件工程\';\\n```\\n\\n#### 2.6.6 覆盖索引 \\n\\n尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。\\n\\n#### 2.6.7 前缀索引 \\n\\n当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。\\n\\n1). 语法\\n\\n``` sql\\ncreate index idx_xxxx on table_name(column(n)) ;\\n```\\n\\n2). 前缀长度 \\n\\n可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\\n\\n``` sql\\nselect count(distinct email) / count(*) from tb_user ;\\nselect count(distinct substring(email,1,5)) / count(*) from tb_user ;\\n```\\n\\n3). 前缀索引的查询流程\\n\\n![image-20220707233417388](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202207072334452.png)\\n\\n#### 2.6.8 单列索引与联合索引 \\n\\n单列索引：即一个索引只包含单个列。 \\n\\n联合索引：即一个索引包含了多个列\\n\\n> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。\\n\\n### 2.7 索引设计原则 \\n\\n1). 针对于数据量较大，且查询比较频繁的表建立索引。 \\n\\n2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。 \\n\\n3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 \\n\\n4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 \\n\\n5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 \\n\\n6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。 \\n\\n7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2a392709367b0c972a09663e2c2ca44.jpg\",\"articleTitle\":\"MySQL进阶（索引）\",\"categoryName\":\"MySQL\",\"id\":111,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-09-09 20:06:02',NULL),(1219,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# springboot+md5实现数据库密码加密\\n\\n## 引入依赖\\n\\n```xml\\n<!-- MD5加密依赖 -->\\n<dependency>\\n    <groupId>commons-codec</groupId>\\n    <artifactId>commons-codec</artifactId>\\n</dependency>\\n```\\n\\n## 工具类\\n\\n```java\\npackage com.icatw.wallpaperapi.utils;\\n\\nimport org.apache.commons.codec.digest.DigestUtils;\\n\\n/**\\n * md5加密工具\\n *\\n * @author 76218\\n * @date 2022/10/05\\n */\\npublic class MD5Utils {\\n    public static String md5(String src) {\\n        return DigestUtils.md5Hex(src);\\n    }\\n\\n    private static final String salt = \\\"1a2b3c4d\\\";\\n\\n    public static String inputPassToFormPass(String inputPass) {\\n        String str = \\\"\\\"+salt.charAt(0)+salt.charAt(2) + inputPass +salt.charAt(5) + salt.charAt(4);\\n        System.out.println(str);\\n        return md5(str);\\n    }\\n\\n    public static String formPassToDBPass(String formPass, String salt) {\\n        String str = \\\"\\\"+salt.charAt(0)+salt.charAt(2) + formPass +salt.charAt(5) + salt.charAt(4);\\n        return md5(str);\\n    }\\n\\n    public static String inputPassToDbPass(String inputPass, String saltDB) {\\n        String formPass = inputPassToFormPass(inputPass);\\n        String dbPass = formPassToDBPass(formPass, saltDB);\\n        return dbPass;\\n    }\\n    //编写主类进行测试\\n     public static void main(String args[]) {\\n        String s = \\\"123456\\\";\\n        System.out.println(\\\"原始：\\\" + s);\\n\\n        System.out.println(\\\"加密后：\\\"+MD5Utils.inputPassToFormPass(s));\\n\\n    }\\n}\\n```\\n\\n## 使用\\n\\n在登陆和注册接口将前端传来的密码进行加密再与数据库的加密密码进行比对\\n\\n```java\\npublic Object login(User user) {\\n    try {\\n        String userName = user.getUserName();\\n        User one = this.getOne(new QueryWrapper<User>().eq(\\\"user_name\\\" , userName));\\n        if (one != null) {\\n            String password = user.getPassword();\\n            //输入的密码加密后与数据库密码进行比较\\n            String formPass = MD5Utils.inputPassToFormPass(password);\\n            String onePassword = one.getPassword();\\n            //如果密码相同，生成token\\n            if (onePassword.equals(formPass)) {\\n                //根据用户id生成token，将userId存入token荷载中\\n                String token = JWTUtils.createToken(one.getUserId());\\n                return R.ok(token);\\n            }\\n        }\\n        //空，用户名不存在\\n        return R.fail(ResultStatusEnum.NOT_USER.getCode(),ResultStatusEnum.NOT_USER.getMessage());\\n    } catch (Exception e) {\\n        //抛出异常，系统错误\\n        e.printStackTrace();\\n        throw new CustomException(ResultStatusEnum.SYSTEM_EXCEPTION);\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/e44970f19d6d8a979d635bce34ac7727.jpg\",\"articleTitle\":\"springboot+md5实现数据库密码加密\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-10-05 20:41:23',NULL),(1220,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# RuoYi-Vue二开指南\\n\\n> RuoYi-Vue是一款基于SpringBoot+Vue前后端分离的Java快速开发框架（**gitee上拥有21.9k的star**）\\n\\n先来看看官方简介：\\n\\nGitee地址：https://gitee.com/y_project/RuoYi-Vue\\n\\n## 平台简介\\n\\n若依是一套全部开源的快速开发平台，毫无保留给个人及企业免费使用。\\n\\n- 前端采用Vue、Element UI。\\n- 后端采用Spring Boot、Spring Security、Redis & Jwt。\\n- 权限认证使用Jwt，支持多终端认证系统。\\n- 支持加载动态权限菜单，多方式轻松权限控制。\\n- 高效率开发，使用代码生成器可以一键生成前后端代码。\\n- 提供了技术栈（[Vue3](https://gitee.com/link?target=https%3A%2F%2Fv3.cn.vuejs.org) [Element Plus](https://gitee.com/link?target=https%3A%2F%2Felement-plus.org%2Fzh-CN) [Vite](https://gitee.com/link?target=https%3A%2F%2Fcn.vitejs.dev)）版本[RuoYi-Vue3](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue3)，保持同步更新。\\n- 提供了单应用版本[RuoYi-Vue-fast](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue-fast)，Oracle版本[RuoYi-Vue-Oracle](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue-Oracle)，保持同步更新。\\n- 不分离版本，请移步[RuoYi](https://gitee.com/y_project/RuoYi)，微服务版本，请移步[RuoYi-Cloud](https://gitee.com/y_project/RuoYi-Cloud)\\n- 特别鸣谢：[element](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement)，[vue-element-admin](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin)，[eladmin-web](https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Felunez%2Feladmin-web)。\\n- 阿里云折扣场：[点我进入](https://gitee.com/link?target=http%3A%2F%2Faly.ruoyi.vip)，腾讯云秒杀场：[点我进入](https://gitee.com/link?target=http%3A%2F%2Ftxy.ruoyi.vip) \\n- 阿里云优惠券：[点我领取](https://gitee.com/link?target=https%3A%2F%2Fwww.aliyun.com%2Fminisite%2Fgoods%3FuserCode%3Dbrki8iof%26share_source%3Dcopy_link)，腾讯云优惠券：[点我领取](https://gitee.com/link?target=https%3A%2F%2Fcloud.tencent.com%2Fredirect.php%3Fredirect%3D1025%26cps_key%3D198c8df2ed259157187173bc7f4f32fd%26from%3Dconsole) \\n\\n## 内置功能\\n\\n1. 用户管理：用户是系统操作者，该功能主要完成系统用户配置。\\n2. 部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。\\n3. 岗位管理：配置系统用户所属担任职务。\\n4. 菜单管理：配置系统菜单，操作权限，按钮权限标识等。\\n5. 角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。\\n6. 字典管理：对系统中经常使用的一些较为固定的数据进行维护。\\n7. 参数管理：对系统动态配置常用参数。\\n8. 通知公告：系统通知公告信息发布维护。\\n9. 操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。\\n10. 登录日志：系统登录日志记录查询包含登录异常。\\n11. 在线用户：当前系统中活跃用户状态监控。\\n12. 定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。\\n13. 代码生成：前后端代码的生成（java、html、xml、sql）支持CRUD下载 。\\n14. 系统接口：根据业务代码自动生成相关的api接口文档。\\n15. 服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。\\n16. 缓存监控：对系统的缓存信息查询，命令统计等。\\n17. 在线构建器：拖动表单元素生成相应的HTML代码。\\n18. 连接池监视：监视当前系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。\\n\\n## 个人修改版\\n\\n>  首先可以去http://fastbuild.run/这个网站修改若依的包名\\n\\n个人修改后的若依后台管理系统（去除了岗位和部门，使用knife4j作为接口文档，使用mybatisplus作为orm框架，改用oss上传文件）\\n\\nhttps://gitee.com/icatw/RuoYi-Vue-Icatw\\n\\n- 剔除了岗位和部门管理\\n\\n- 将接口文档工具swagger替换为了更美观的knife4j\\n\\n- 使用Mybatis-Plus作为数据库操作框架\\n\\n- 修改首页和登录页，后台登陆使用腾讯云人机验证\\n\\n- 使用lombok简化实体类get/set方法\\n\\n  ![image-20221004113727410](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041137098.png)\\n\\n![image-20221004113747815](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041137256.png)\\n\\n## 新增个人模块\\n\\n1. 新建maven模块\\n\\n   <img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041150786.png\\\" alt=\\\"image-20221004115026729\\\" style=\\\"zoom:50%;\\\" />\\n\\n2. 导入新模块坐标\\n\\n   ![image-20221004115131929](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041151026.png)\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041151800.png\\\" alt=\\\"image-20221004115152700\\\"  />\\n\\n<img src=\\\"https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041153488.png\\\" alt=\\\"image-20221004115343450\\\" style=\\\"zoom: 67%;\\\" />\\n\\n3. 启动前端\\n\\n   - npm install\\n   - npm run dev\\n\\n   ![image-20221004115607081](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041156201.png)\\n\\n4. 创建数据库\\n\\n![image-20221004115627556](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041156603.png)\\n\\n5. 新建菜单\\n\\n   ![image-20221004122053981](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041220055.png)\\n\\n6. 代码生成\\n\\n![image-20221004115709902](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041157990.png)\\n\\n![image-20221004120501142](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041205236.png)\\n\\n![image-20221004122408710](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041224780.png)\\n\\n![image-20221004122838731](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210041228776.png)\\n\\n7. 将代码复制粘贴到对应的目录下，并执行SQL\\n\\n8. 重启项目前后端\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/dde3c71e642f112140ce6ec3797bbf27.jpg\",\"articleTitle\":\" RuoYi-Vue二开指南\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-10-05 21:41:39',NULL),(1221,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# springboot使用@ConfigurationProperties读取配置文件\\n\\n1. 配置文件\\n\\n   ![image-20221010134115656](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/202210101341929.png)\\n\\n2. 注解使用\\n\\n   首先定义一个属性实体类\\n\\n``` java\\n@ConfigurationProperties(prefix = \\\"aliyun.vod.file\\\")\\n@Component\\n@Data\\npublic class AliConstant {\\n    private String keyId;\\n    private String keySecret;\\n}\\n```\\n\\n实体属性必须与配置文件中的属性对应\\n\\n***必须使用@Component将bean注入到spring容器中**\\n\\n3. 最终使用\\n\\n   ```Java\\n   @Autowired\\n   AliConstant aliConstant;\\n   ```\\n\\n   注入使用即可\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2d9ff49944343908a18340d6a43d9986.jpg\",\"articleTitle\":\"springboot使用@ConfigurationProperties读取配置文件\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-10-10 13:45:59',NULL),(1222,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 将本地jar包安装到本地maven仓库\\n\\n首先确保本地电脑有maven环境\\n\\n> 可使用mvn查看是否配置环境变量\\n\\n1. 首先下载好jar包\\n\\n2. 在存放jar包的文件夹cmd\\n\\n3. 使用mvn install命令\\n\\n   ``` java\\n   mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar\\n   ```\\n\\n   \\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/abd253be0e10c331cec2245f8ff76ca0.jpg\",\"articleTitle\":\"将本地jar包安装到本地maven仓库\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-10-10 14:16:13',NULL);
INSERT INTO `tb_operation_log` VALUES (1223,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 函数式编程-Stream流\\n\\n## 1. 概述\\n\\n### 1.1 为什么学？\\n\\n- 能够看懂公司里的代码\\n- 大数量下处理集合效率高\\n- 代码可读性高\\n- 消灭嵌套地狱\\n\\n~~~~java\\n//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重\\nList<Book> bookList = new ArrayList<>();\\nSet<Book> uniqueBookValues = new HashSet<>();\\nSet<Author> uniqueAuthorValues = new HashSet<>();\\nfor (Author author : authors) {\\n    if (uniqueAuthorValues.add(author)) {\\n        if (author.getAge() < 18) {\\n            List<Book> books = author.getBooks();\\n            for (Book book : books) {\\n                if (book.getScore() > 70) {\\n                    if (uniqueBookValues.add(book)) {\\n                        bookList.add(book);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\nSystem.out.println(bookList);\\n~~~~\\n\\n~~~~java\\nList<Book> collect = authors.stream()\\n    .distinct()\\n    .filter(author -> author.getAge() < 18)\\n    .map(author -> author.getBooks())\\n    .flatMap(Collection::stream)\\n    .filter(book -> book.getScore() > 70)\\n    .distinct()\\n    .collect(Collectors.toList());\\nSystem.out.println(collect);\\n~~~~\\n\\n\\n\\n### 1.2 函数式编程思想\\n\\n#### 1.2.1 概念\\n\\n​\\t面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。\\n\\n#### 1.2.2 优点\\n\\n* 代码简洁，开发快速\\n* 接近自然语言，易于理解\\n* 易于\\\"并发编程\\\"\\n\\n\\n\\n## 2. Lambda表达式\\n\\n### 2.1 概述\\n\\n​\\tLambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。\\n\\n### 2.2 核心原则\\n\\n> 可推导可省略\\n\\n### 2. 3 基本格式\\n\\n~~~~java\\n(参数列表)->{代码}\\n~~~~\\n\\n#### 例一\\n\\n我们在创建线程并启动时可以使用匿名内部类的写法：\\n\\n~~~~java\\nnew Thread(new Runnable() {\\n    @Override\\n    public void run() {\\n        System.out.println(\\\"你知道吗 我比你想象的 更想在你身边\\\");\\n    }\\n}).start();\\n~~~~\\n\\n可以使用Lambda的格式对其进行修改。修改后如下：\\n\\n~~~~java\\nnew Thread(()->{\\n    System.out.println(\\\"你知道吗 我比你想象的 更想在你身边\\\");\\n}).start();\\n~~~~\\n\\n\\n\\n#### 例二:\\n\\n现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。\\n\\n~~~~java\\n    public static int calculateNum(IntBinaryOperator operator){\\n        int a = 10;\\n        int b = 20;\\n        return operator.applyAsInt(a, b);\\n    }\\n\\n    public static void main(String[] args) {\\n        int i = calculateNum(new IntBinaryOperator() {\\n            @Override\\n            public int applyAsInt(int left, int right) {\\n                return left + right;\\n            }\\n        });\\n        System.out.println(i);\\n    }\\n~~~~\\n\\nLambda写法：\\n\\n~~~~java\\n    public static void main(String[] args) {\\n        int i = calculateNum((int left, int right)->{\\n            return left + right;\\n        });\\n        System.out.println(i);\\n    }\\n~~~~\\n\\n\\n\\n#### 例三：\\n\\n现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。\\n\\n~~~~java\\n    public static void printNum(IntPredicate predicate){\\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\\n        for (int i : arr) {\\n            if(predicate.test(i)){\\n                System.out.println(i);\\n            }\\n        }\\n    }\\n    public static void main(String[] args) {\\n        printNum(new IntPredicate() {\\n            @Override\\n            public boolean test(int value) {\\n                return value%2==0;\\n            }\\n        });\\n    }\\n~~~~\\n\\nLambda写法：\\n\\n~~~~java\\n    public static void main(String[] args) {\\n        printNum((int value)-> {\\n            return value%2==0;\\n        });\\n    }\\n    public static void printNum(IntPredicate predicate){\\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\\n        for (int i : arr) {\\n            if(predicate.test(i)){\\n                System.out.println(i);\\n            }\\n        }\\n    }\\n~~~~\\n\\n\\n\\n#### 例四：\\n\\n现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。\\n\\n~~~~java\\n    public static <R> R typeConver(Function<String,R> function){\\n        String str = \\\"1235\\\";\\n        R result = function.apply(str);\\n        return result;\\n    }\\n    public static void main(String[] args) {\\n        Integer result = typeConver(new Function<String, Integer>() {\\n            @Override\\n            public Integer apply(String s) {\\n                return Integer.valueOf(s);\\n            }\\n        });\\n        System.out.println(result);\\n    }\\n~~~~\\n\\nLambda写法：\\n\\n~~~~java\\n        Integer result = typeConver((String s)->{\\n            return Integer.valueOf(s);\\n        });\\n        System.out.println(result);\\n\\n~~~~\\n\\n\\n\\n#### 例五：\\n\\n现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。\\n\\n~~~~java\\n    public static void foreachArr(IntConsumer consumer){\\n        int[] arr = {1,2,3,4,5,6,7,8,9,10};\\n        for (int i : arr) {\\n            consumer.accept(i);\\n        }\\n    }\\n    public static void main(String[] args) {\\n        foreachArr(new IntConsumer() {\\n            @Override\\n            public void accept(int value) {\\n                System.out.println(value);\\n            }\\n        });\\n    }\\n~~~~\\n\\nLambda写法：\\n\\n~~~~java\\n    public static void main(String[] args) {\\n        foreachArr((int value)->{\\n            System.out.println(value);\\n        });\\n    }\\n~~~~\\n\\n\\n\\n### 2.4 省略规则\\n\\n* 参数类型可以省略\\n* 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略\\n* 方法只有一个参数时小括号可以省略\\n* 以上这些规则都记不住也可以省略不记\\n\\n\\n\\n\\n\\n## 3. Stream流\\n\\n### 3.1 概述\\n\\n​\\tJava8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。\\n\\n\\n\\n### 3.2 案例数据准备\\n\\n~~~~xml\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <version>1.18.16</version>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n\\n\\n~~~~java\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\n@EqualsAndHashCode//用于后期的去重使用\\npublic class Author {\\n    //id\\n    private Long id;\\n    //姓名\\n    private String name;\\n    //年龄\\n    private Integer age;\\n    //简介\\n    private String intro;\\n    //作品\\n    private List<Book> books;\\n}\\n~~~~\\n\\n~~~~java\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@EqualsAndHashCode//用于后期的去重使用\\npublic class Book {\\n    //id\\n    private Long id;\\n    //书名\\n    private String name;\\n\\n    //分类\\n    private String category;\\n\\n    //评分\\n    private Integer score;\\n\\n    //简介\\n    private String intro;\\n\\n}\\n~~~~\\n\\n~~~~java\\n    private static List<Author> getAuthors() {\\n        //数据初始化\\n        Author author = new Author(1L,\\\"蒙多\\\",33,\\\"一个从菜刀中明悟哲理的祖安人\\\",null);\\n        Author author2 = new Author(2L,\\\"亚拉索\\\",15,\\\"狂风也追逐不上他的思考速度\\\",null);\\n        Author author3 = new Author(3L,\\\"易\\\",14,\\\"是这个世界在限制他的思维\\\",null);\\n        Author author4 = new Author(3L,\\\"易\\\",14,\\\"是这个世界在限制他的思维\\\",null);\\n\\n        //书籍列表\\n        List<Book> books1 = new ArrayList<>();\\n        List<Book> books2 = new ArrayList<>();\\n        List<Book> books3 = new ArrayList<>();\\n\\n        books1.add(new Book(1L,\\\"刀的两侧是光明与黑暗\\\",\\\"哲学,爱情\\\",88,\\\"用一把刀划分了爱恨\\\"));\\n        books1.add(new Book(2L,\\\"一个人不能死在同一把刀下\\\",\\\"个人成长,爱情\\\",99,\\\"讲述如何从失败中明悟真理\\\"));\\n\\n        books2.add(new Book(3L,\\\"那风吹不到的地方\\\",\\\"哲学\\\",85,\\\"带你用思维去领略世界的尽头\\\"));\\n        books2.add(new Book(3L,\\\"那风吹不到的地方\\\",\\\"哲学\\\",85,\\\"带你用思维去领略世界的尽头\\\"));\\n        books2.add(new Book(4L,\\\"吹或不吹\\\",\\\"爱情,个人传记\\\",56,\\\"一个哲学家的恋爱观注定很难把他所在的时代理解\\\"));\\n\\n        books3.add(new Book(5L,\\\"你的剑就是我的剑\\\",\\\"爱情\\\",56,\\\"无法想象一个武者能对他的伴侣这么的宽容\\\"));\\n        books3.add(new Book(6L,\\\"风与剑\\\",\\\"个人传记\\\",100,\\\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\\\"));\\n        books3.add(new Book(6L,\\\"风与剑\\\",\\\"个人传记\\\",100,\\\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\\\"));\\n\\n        author.setBooks(books1);\\n        author2.setBooks(books2);\\n        author3.setBooks(books3);\\n        author4.setBooks(books3);\\n\\n        List<Author> authorList = new ArrayList<>(Arrays.asList(author,author2,author3,author4));\\n        return authorList;\\n    }\\n~~~~\\n\\n\\n\\n### 3.3 快速入门\\n\\n#### 3.3.1 需求\\n\\n​\\t我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。\\n\\n#### 3.3.2 实现\\n\\n~~~~java\\n        //打印所有年龄小于18的作家的名字，并且要注意去重\\n        List<Author> authors = getAuthors();\\n        authors.\\n                stream()//把集合转换成流\\n                .distinct()//先去除重复的作家\\n                .filter(author -> author.getAge()<18)//筛选年龄小于18的\\n                .forEach(author -> System.out.println(author.getName()));//遍历打印名字\\n~~~~\\n\\n\\n\\n### 3.4 常用操作\\n\\n#### 3.4.1 创建流\\n\\n单列集合： `集合对象.stream()`\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\t\\tStream<Author> stream = authors.stream();\\n~~~~\\n\\n数组：`Arrays.stream(数组) `或者使用`Stream.of`来创建\\n\\n~~~~JAVA\\n        Integer[] arr = {1,2,3,4,5};\\n        Stream<Integer> stream = Arrays.stream(arr);\\n        Stream<Integer> stream2 = Stream.of(arr);\\n~~~~\\n\\n双列集合：转换成单列集合后再创建\\n\\n~~~~java\\n        Map<String,Integer> map = new HashMap<>();\\n        map.put(\\\"蜡笔小新\\\",19);\\n        map.put(\\\"黑子\\\",17);\\n        map.put(\\\"日向翔阳\\\",16);\\n\\n        Stream<Map.Entry<String, Integer>> stream = map.entrySet().stream();\\n~~~~\\n\\n\\n\\n#### 3.4.2 中间操作\\n\\n##### filter\\n\\n​\\t可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。\\n\\n\\n\\n例如：\\n\\n​\\t打印所有姓名长度大于1的作家的姓名\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .filter(author -> author.getName().length()>1)\\n                .forEach(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n##### map\\n\\n​\\t可以把对流中的元素进行计算或转换。\\n\\n例如：\\n\\n​\\t打印所有作家的姓名\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\n        authors\\n                .stream()\\n                .map(author -> author.getName())\\n                .forEach(name->System.out.println(name));\\n~~~~\\n\\n~~~~java\\n//        打印所有作家的姓名\\n        List<Author> authors = getAuthors();\\n\\n//        authors.stream()\\n//                .map(author -> author.getName())\\n//                .forEach(s -> System.out.println(s));\\n\\n        authors.stream()\\n                .map(author -> author.getAge())\\n                .map(age->age+10)\\n                .forEach(age-> System.out.println(age));\\n~~~~\\n\\n\\n\\n\\n\\n##### distinct\\n\\n​\\t可以去除流中的重复元素。\\n\\n\\n\\n例如：\\n\\n​\\t打印所有作家的姓名，并且要求其中不能有重复元素。\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .distinct()\\n                .forEach(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n**注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。**\\n\\n\\n\\n##### sorted\\n\\n​\\t可以对流中的元素进行排序。\\n\\n例如：\\n\\n​\\t对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\\n        authors.stream()\\n                .distinct()\\n                .sorted()\\n                .forEach(author -> System.out.println(author.getAge()));\\n~~~~\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\\n        authors.stream()\\n                .distinct()\\n                .sorted((o1, o2) -> o2.getAge()-o1.getAge())\\n                .forEach(author -> System.out.println(author.getAge()));\\n~~~~\\n\\n\\n\\n**注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。**\\n\\n​\\t\\t\\n\\n\\n\\n##### limit\\t\\n\\n​\\t可以设置流的最大长度，超出的部分将被抛弃。\\n\\n\\n\\n例如：\\n\\n​\\t对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .distinct()\\n                .sorted()\\n                .limit(2)\\n                .forEach(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n##### skip\\n\\n​\\t跳过流中的前n个元素，返回剩下的元素\\n\\n\\n\\n例如：\\n\\n​\\t打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。\\n\\n~~~~java\\n//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .distinct()\\n                .sorted()\\n                .skip(1)\\n                .forEach(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n##### flatMap\\n\\n​\\tmap只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。\\n\\n\\n\\n例一：\\n\\n​\\t打印所有书籍的名字。要求对重复的元素进行去重。\\n\\n~~~~java\\n//        打印所有书籍的名字。要求对重复的元素进行去重。\\n        List<Author> authors = getAuthors();\\n\\n        authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .distinct()\\n                .forEach(book -> System.out.println(book.getName()));\\n~~~~\\n\\n\\n\\n例二：\\n\\n​\\t打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情\\n\\n~~~~java\\n//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .distinct()\\n                .flatMap(book -> Arrays.stream(book.getCategory().split(\\\",\\\")))\\n                .distinct()\\n                .forEach(category-> System.out.println(category));\\n~~~~\\n\\n\\n\\n\\n\\n#### 3.4.3 终结操作\\n\\n##### forEach\\n\\n​\\t对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。\\n\\n\\n\\n例子：\\n\\n​\\t输出所有作家的名字\\n\\n~~~~java\\n//        输出所有作家的名字\\n        List<Author> authors = getAuthors();\\n\\n        authors.stream()\\n                .map(author -> author.getName())\\n                .distinct()\\n                .forEach(name-> System.out.println(name));\\n\\n~~~~\\n\\n\\n\\n\\n\\n##### count\\n\\n​\\t可以用来获取当前流中元素的个数。\\n\\n例子：\\n\\n​\\t打印这些作家的所出书籍的数目，注意删除重复元素。\\n\\n~~~~java\\n//        打印这些作家的所出书籍的数目，注意删除重复元素。\\n        List<Author> authors = getAuthors();\\n\\n        long count = authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .distinct()\\n                .count();\\n        System.out.println(count);\\n~~~~\\n\\n\\n\\n\\n\\n##### max&min\\n\\n​\\t可以用来或者流中的最值。\\n\\n例子：\\n\\n​\\t分别获取这些作家的所出书籍的最高分和最低分并打印。\\n\\n~~~~java\\n//        分别获取这些作家的所出书籍的最高分和最低分并打印。\\n        //Stream<Author>  -> Stream<Book> ->Stream<Integer>  ->求值\\n\\n        List<Author> authors = getAuthors();\\n        Optional<Integer> max = authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .map(book -> book.getScore())\\n                .max((score1, score2) -> score1 - score2);\\n\\n        Optional<Integer> min = authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .map(book -> book.getScore())\\n                .min((score1, score2) -> score1 - score2);\\n        System.out.println(max.get());\\n        System.out.println(min.get());\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n##### collect\\n\\n​\\t把当前流转换成一个集合。\\n\\n\\n\\n例子：\\n\\n​\\t获取一个存放所有作者名字的List集合。\\n\\n~~~~java\\n//        获取一个存放所有作者名字的List集合。\\n        List<Author> authors = getAuthors();\\n        List<String> nameList = authors.stream()\\n                .map(author -> author.getName())\\n                .collect(Collectors.toList());\\n        System.out.println(nameList);\\n~~~~\\n\\n​\\t获取一个所有书名的Set集合。\\n\\n~~~~java\\n//        获取一个所有书名的Set集合。\\n        List<Author> authors = getAuthors();\\n        Set<Book> books = authors.stream()\\n                .flatMap(author -> author.getBooks().stream())\\n                .collect(Collectors.toSet());\\n\\n        System.out.println(books);\\n~~~~\\n\\n​\\t获取一个Map集合，map的key为作者名，value为List<Book>\\n\\n~~~~java\\n//        获取一个Map集合，map的key为作者名，value为List<Book>\\n        List<Author> authors = getAuthors();\\n\\n        Map<String, List<Book>> map = authors.stream()\\n                .distinct()\\n                .collect(Collectors.toMap(author -> author.getName(), author -> author.getBooks()));\\n\\n        System.out.println(map);\\n~~~~\\n\\n\\n\\n##### 查找与匹配\\n\\n###### anyMatch\\n\\n​\\t可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。\\n\\n\\n\\n例子：\\n\\n​\\t判断是否有年龄在29以上的作家\\n\\n~~~~java\\n//        判断是否有年龄在29以上的作家\\n        List<Author> authors = getAuthors();\\n        boolean flag = authors.stream()\\n                .anyMatch(author -> author.getAge() > 29);\\n        System.out.println(flag);\\n~~~~\\n\\n\\n\\n\\n\\n###### allMatch\\n\\n​\\t可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。\\n\\n例子：\\n\\n​\\t判断是否所有的作家都是成年人\\n\\n~~~~java\\n//        判断是否所有的作家都是成年人\\n        List<Author> authors = getAuthors();\\n        boolean flag = authors.stream()\\n                .allMatch(author -> author.getAge() >= 18);\\n        System.out.println(flag);\\n~~~~\\n\\n\\n\\n###### noneMatch\\n\\n​\\t可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false\\n\\n例子：\\n\\n​\\t判断作家是否都没有超过100岁的。\\n\\n~~~~java\\n//        判断作家是否都没有超过100岁的。\\n        List<Author> authors = getAuthors();\\n\\n        boolean b = authors.stream()\\n                .noneMatch(author -> author.getAge() > 100);\\n\\n        System.out.println(b);\\n~~~~\\n\\n\\n\\n\\n\\n###### findAny\\n\\n​\\t获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。\\n\\n\\n\\n例子：\\n\\n​\\t获取任意一个年龄大于18的作家，如果存在就输出他的名字\\n\\n~~~~java\\n//        获取任意一个年龄大于18的作家，如果存在就输出他的名字\\n        List<Author> authors = getAuthors();\\n        Optional<Author> optionalAuthor = authors.stream()\\n                .filter(author -> author.getAge()>18)\\n                .findAny();\\n\\n        optionalAuthor.ifPresent(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n###### findFirst\\n\\n​\\t获取流中的第一个元素。\\n\\n\\n\\n例子：\\n\\n​\\t获取一个年龄最小的作家，并输出他的姓名。\\n\\n~~~~java\\n//        获取一个年龄最小的作家，并输出他的姓名。\\n        List<Author> authors = getAuthors();\\n        Optional<Author> first = authors.stream()\\n                .sorted((o1, o2) -> o1.getAge() - o2.getAge())\\n                .findFirst();\\n\\n        first.ifPresent(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n##### reduce归并\\n\\n​\\t对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）\\n\\n​\\treduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。\\n\\n​\\treduce两个参数的重载形式内部的计算方式如下：\\n\\n~~~~java\\nT result = identity;\\nfor (T element : this stream)\\n\\tresult = accumulator.apply(result, element)\\nreturn result;\\n~~~~\\n\\n​\\t其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。\\n\\n\\n\\n例子：\\n\\n​\\t使用reduce求所有作者年龄的和\\n\\n~~~~java\\n//        使用reduce求所有作者年龄的和\\n        List<Author> authors = getAuthors();\\n        Integer sum = authors.stream()\\n                .distinct()\\n                .map(author -> author.getAge())\\n                .reduce(0, (result, element) -> result + element);\\n        System.out.println(sum);\\n~~~~\\n\\n​\\t使用reduce求所有作者中年龄的最大值\\n\\n~~~~java\\n//        使用reduce求所有作者中年龄的最大值\\n        List<Author> authors = getAuthors();\\n        Integer max = authors.stream()\\n                .map(author -> author.getAge())\\n                .reduce(Integer.MIN_VALUE, (result, element) -> result < element ? element : result);\\n\\n        System.out.println(max);\\n~~~~\\n\\n​\\t使用reduce求所有作者中年龄的最小值\\n\\n~~~~java\\n//        使用reduce求所有作者中年龄的最小值\\n        List<Author> authors = getAuthors();\\n        Integer min = authors.stream()\\n                .map(author -> author.getAge())\\n                .reduce(Integer.MAX_VALUE, (result, element) -> result > element ? element : result);\\n        System.out.println(min);\\n~~~~\\n\\n\\n\\n​\\treduce一个参数的重载形式内部的计算\\n\\n~~~~java\\n \\t boolean foundAny = false;\\n     T result = null;\\n     for (T element : this stream) {\\n         if (!foundAny) {\\n             foundAny = true;\\n             result = element;\\n         }\\n         else\\n             result = accumulator.apply(result, element);\\n     }\\n     return foundAny ? Optional.of(result) : Optional.empty();\\n~~~~\\n\\n​\\t如果用一个参数的重载方法去求最小值代码如下：\\n\\n~~~~java\\n        //        使用reduce求所有作者中年龄的最小值\\n        List<Author> authors = getAuthors();\\n        Optional<Integer> minOptional = authors.stream()\\n                .map(author -> author.getAge())\\n                .reduce((result, element) -> result > element ? element : result);\\n        minOptional.ifPresent(age-> System.out.println(age));\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### 3.5 注意事项\\n\\n- 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）\\n- 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）\\n- 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）\\n\\n\\n\\n\\n\\n## 4. Optional\\n\\n### 4.1 概述\\n\\n​\\t我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。\\n\\n​\\t例如：\\n\\n~~~~java\\n        Author author = getAuthor();\\n        if(author!=null){\\n            System.out.println(author.getName());\\n        }\\n~~~~\\n\\n​\\t尤其是对象中的属性还是一个对象的情况下。这种判断会更多。\\t\\n\\n​\\t而过多的判断语句会让我们的代码显得臃肿不堪。\\n\\n​\\t所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。\\n\\n​\\t并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。\\n\\n\\n\\n### 4.2 使用\\n\\n#### 4.2.1 创建对象\\n\\n​\\tOptional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。\\n\\n\\n\\n​\\t我们一般使用**Optional**的**静态方法ofNullable**来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。\\n\\n~~~~java\\n        Author author = getAuthor();\\n        Optional<Author> authorOptional = Optional.ofNullable(author);\\n~~~~\\n\\n​\\t你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。\\n\\n​\\t而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。\\n\\n\\n\\n​\\t如果你**确定一个对象不是空**的则可以使用**Optional**的**静态方法of**来把数据封装成Optional对象。\\n\\n~~~~java\\n        Author author = new Author();\\n        Optional<Author> authorOptional = Optional.of(author);\\n~~~~\\n\\n​\\t但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）\\n\\n\\n\\n​\\t如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用**Optional**的**静态方法empty**来进行封装。\\n\\n~~~~java\\n\\t\\tOptional.empty()\\n~~~~\\n\\n​\\t\\n\\n​\\t所以最后你觉得哪种方式会更方便呢？**ofNullable**\\n\\n\\n\\n#### 4.2.2 安全消费值\\n\\n​\\t我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其**ifPresent**方法对来消费其中的值。\\n\\n​\\t这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。\\n\\n​\\t例如,以下写法就优雅的避免了空指针异常。\\n\\n~~~~java\\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\\n\\n        authorOptional.ifPresent(author -> System.out.println(author.getName()));\\n~~~~\\n\\n\\n\\n#### 4.2.3 获取值\\n\\n​\\t如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。\\n\\n\\n\\n\\n\\n#### 4.2.4 安全获取值\\n\\n​\\t如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。\\n\\n* orElseGet\\n\\n  获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。\\n\\n  ~~~~java\\n          Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\\n          Author author1 = authorOptional.orElseGet(() -> new Author());\\n  ~~~~\\n\\n  \\n\\n\\n\\n* orElseThrow\\n\\n  获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。\\n\\n  ~~~~java\\n          Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\\n          try {\\n              Author author = authorOptional.orElseThrow((Supplier<Throwable>) () -> new RuntimeException(\\\"author为空\\\"));\\n              System.out.println(author.getName());\\n          } catch (Throwable throwable) {\\n              throwable.printStackTrace();\\n          }\\n  ~~~~\\n\\n  \\n\\n#### 4.2.5 过滤\\n\\n​\\t我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。\\n\\n~~~~java\\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\\n        authorOptional.filter(author -> author.getAge()>100).ifPresent(author -> System.out.println(author.getName()));\\n\\n~~~~\\n\\n\\n\\n#### 4.2.6 判断\\n\\n​\\t我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，**更推荐使用ifPresent方法**。\\n\\n~~~~java\\n        Optional<Author> authorOptional = Optional.ofNullable(getAuthor());\\n\\n        if (authorOptional.isPresent()) {\\n            System.out.println(authorOptional.get().getName());\\n        }\\n~~~~\\n\\n\\n\\n#### 4.2.7 数据转换\\n\\n​\\tOptional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。\\n\\n例如我们想获取作家的书籍集合。\\n\\n~~~~java\\n    private static void testMap() {\\n        Optional<Author> authorOptional = getAuthorOptional();\\n        Optional<List<Book>> optionalBooks = authorOptional.map(author -> author.getBooks());\\n        optionalBooks.ifPresent(books -> System.out.println(books));\\n    }\\n~~~~\\n\\n\\n\\n## 5. 函数式接口\\n\\n### 5.1 概述\\n\\n​\\t**只有一个抽象方法**的接口我们称之为函数接口。\\n\\n​\\tJDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。\\n\\n\\n\\n### 5.2 常见函数式接口\\t\\n\\n- ​\\tConsumer 消费接口\\n\\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。\\n\\n  ![image-20211028145622163](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145622163-16354041894551.png)\\n\\n- ​\\tFunction 计算转换接口\\n\\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回\\n\\n  ![image-20211028145707862](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145707862-16354042291112.png)\\n\\n- ​\\tPredicate 判断接口\\n\\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果\\n\\n  ![image-20211028145818743](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145818743-16354043004393.png)\\n\\n- ​\\tSupplier 生产型接口\\n\\n  根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回\\n\\n![image-20211028145843368](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20211028145843368-16354043246954.png)\\n\\n\\n\\n### 5.3 常用的默认方法\\n\\n- and\\n\\n  我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&&来拼接两个判断条件\\n\\n  例如：\\n\\n  打印作家中年龄大于17并且姓名的长度大于1的作家。\\n\\n  ~~~~java\\n          List<Author> authors = getAuthors();\\n          Stream<Author> authorStream = authors.stream();\\n          authorStream.filter(new Predicate<Author>() {\\n              @Override\\n              public boolean test(Author author) {\\n                  return author.getAge()>17;\\n              }\\n          }.and(new Predicate<Author>() {\\n              @Override\\n              public boolean test(Author author) {\\n                  return author.getName().length()>1;\\n              }\\n          })).forEach(author -> System.out.println(author));\\n  ~~~~\\n\\n- or \\n\\n  我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。\\n\\n  例如：\\n\\n  打印作家中年龄大于17或者姓名的长度小于2的作家。\\n\\n  ~~~~java\\n  //        打印作家中年龄大于17或者姓名的长度小于2的作家。\\n          List<Author> authors = getAuthors();\\n          authors.stream()\\n                  .filter(new Predicate<Author>() {\\n                      @Override\\n                      public boolean test(Author author) {\\n                          return author.getAge()>17;\\n                      }\\n                  }.or(new Predicate<Author>() {\\n                      @Override\\n                      public boolean test(Author author) {\\n                          return author.getName().length()<2;\\n                      }\\n                  })).forEach(author -> System.out.println(author.getName()));\\n  ~~~~\\n\\n  \\n\\n- negate\\n\\n  Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反\\n\\n  例如：\\n\\n  打印作家中年龄不大于17的作家。\\n\\n  ~~~~java\\n  //        打印作家中年龄不大于17的作家。\\n          List<Author> authors = getAuthors();\\n          authors.stream()\\n                  .filter(new Predicate<Author>() {\\n                      @Override\\n                      public boolean test(Author author) {\\n                          return author.getAge()>17;\\n                      }\\n                  }.negate()).forEach(author -> System.out.println(author.getAge()));\\n  ~~~~\\n\\n  \\n\\n## 6. 方法引用\\n\\n​\\t我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。\\n\\n\\n\\n### 6.1 推荐用法\\n\\n​\\t我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。\\n\\n​\\t当我们方法引用使用的多了慢慢的也可以直接写出方法引用。\\n\\n\\n\\n### 6.2 基本格式\\n\\n​\\t类名或者对象名::方法名\\n\\n\\n\\n### 6.3 语法详解(了解)\\n\\n#### 6.3.1 引用类的静态方法\\n\\n​\\t其实就是引用类的静态方法\\n\\n##### 格式\\n\\n~~~~java\\n类名::方法名\\n~~~~\\n\\n\\n\\n##### 使用前提\\n\\n​\\t如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个类的静态方法**，并且我们把要重写的**抽象方法中所有的参数都按照顺序传入了这个静态方法中**，这个时候我们就可以引用类的静态方法。\\n\\n​\\t\\n\\n例如：\\n\\n如下代码就可以用方法引用进行简化\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\n        Stream<Author> authorStream = authors.stream();\\n        \\n        authorStream.map(author -> author.getAge())\\n                .map(age->String.valueOf(age));\\n~~~~\\n\\n注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。\\n\\n优化后如下：\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\n        Stream<Author> authorStream = authors.stream();\\n\\n        authorStream.map(author -> author.getAge())\\n                .map(String::valueOf);\\n~~~~\\n\\n\\n\\n#### 6.3.2 引用对象的实例方法\\n\\n##### 格式\\n\\n~~~~java\\n对象名::方法名\\n~~~~\\n\\n\\n\\n##### 使用前提\\n\\n​\\t如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个对象的成员方法**，并且我们把要重写的**抽象方法中所有的参数都按照顺序传入了这个成员方法中**，这个时候我们就可以引用对象的实例方法\\n\\n\\n\\n例如：\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\n        Stream<Author> authorStream = authors.stream();\\n        StringBuilder sb = new StringBuilder();\\n        authorStream.map(author -> author.getName())\\n                .forEach(name->sb.append(name));\\n~~~~\\n\\n优化后：\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n\\n        Stream<Author> authorStream = authors.stream();\\n        StringBuilder sb = new StringBuilder();\\n        authorStream.map(author -> author.getName())\\n                .forEach(sb::append);\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n#### 6.3.4 引用类的实例方法\\n\\n##### 格式\\n\\n~~~~java\\n类名::方法名\\n~~~~\\n\\n\\n\\n##### 使用前提\\n\\n​\\t如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了第一个参数的成员方法**，并且我们把要**重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中**，这个时候我们就可以引用类的实例方法。\\n\\n\\n\\n例如：\\n\\n```java\\n    interface UseString{\\n        String use(String str,int start,int length);\\n    }\\n\\n    public static String subAuthorName(String str, UseString useString){\\n        int start = 0;\\n        int length = 1;\\n        return useString.use(str,start,length);\\n    }\\n    public static void main(String[] args) {\\n\\n        subAuthorName(\\\"三更草堂\\\", new UseString() {\\n            @Override\\n            public String use(String str, int start, int length) {\\n                return str.substring(start,length);\\n            }\\n        });\\n\\n\\t}\\n```\\n\\n优化后如下：\\n\\n~~~~java\\n    public static void main(String[] args) {\\n\\n        subAuthorName(\\\"三更草堂\\\", String::substring);\\n\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n#### 6.3.5 构造器引用\\n\\n​\\t如果方法体中的一行代码是构造器的话就可以使用构造器引用。\\n\\n\\n\\n##### 格式\\n\\n~~~~java\\n类名::new\\n~~~~\\n\\n\\n\\n##### 使用前提\\n\\n​\\t如果我们在重写方法的时候，方法体中**只有一行代码**，并且这行代码是**调用了某个类的构造方法**，并且我们把**要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中**，这个时候我们就可以引用构造器。\\n\\n例如：\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .map(author -> author.getName())\\n                .map(name->new StringBuilder(name))\\n                .map(sb->sb.append(\\\"-三更\\\").toString())\\n                .forEach(str-> System.out.println(str));\\n~~~~\\n\\n优化后：\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .map(author -> author.getName())\\n                .map(StringBuilder::new)\\n                .map(sb->sb.append(\\\"-三更\\\").toString())\\n                .forEach(str-> System.out.println(str));\\n~~~~\\n\\n\\n\\n\\n\\n## 7. 高级用法\\n\\n### 基本数据类型优化\\n\\n​\\t我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。\\n\\n​\\t即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。\\n\\n​\\t所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。\\n\\n​\\t例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。\\n\\n~~~~java\\n    private static void test27() {\\n\\n        List<Author> authors = getAuthors();\\n        authors.stream()\\n                .map(author -> author.getAge())\\n                .map(age -> age + 10)\\n                .filter(age->age>18)\\n                .map(age->age+2)\\n                .forEach(System.out::println);\\n\\n        authors.stream()\\n                .mapToInt(author -> author.getAge())\\n                .map(age -> age + 10)\\n                .filter(age->age>18)\\n                .map(age->age+2)\\n                .forEach(System.out::println);\\n    }\\n~~~~\\n\\n\\n\\n### 并行流\\n\\n​\\t当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。\\n\\n​\\tparallel方法可以把串行流转换成并行流。\\n\\n~~~~java\\n    private static void test28() {\\n        Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\\n        Integer sum = stream.parallel()\\n                .peek(new Consumer<Integer>() {\\n                    @Override\\n                    public void accept(Integer num) {\\n                        System.out.println(num+Thread.currentThread().getName());\\n                    }\\n                })\\n                .filter(num -> num > 5)\\n                .reduce((result, ele) -> result + ele)\\n                .get();\\n        System.out.println(sum);\\n    }\\n~~~~\\n\\n​\\t也可以通过parallelStream直接获取并行流对象。\\n\\n~~~~java\\n        List<Author> authors = getAuthors();\\n        authors.parallelStream()\\n                .map(author -> author.getAge())\\n                .map(age -> age + 10)\\n                .filter(age->age>18)\\n                .map(age->age+2)\\n                .forEach(System.out::println);\\n~~~~\\n\\n\\n\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c78e18bf6f8c87a7f7edbb28ae873f7c.jpg\",\"articleTitle\":\"Java8函数式编程\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-10-25 09:14:02',NULL),(1224,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# AOP+注解实现日志记录\\n\\n## 1、依赖\\n\\n首先引入springboot的aop依赖和fastjson用于序列化json\\n\\n```xml\\n        <!-- fastjson -->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.11</version>\\n        </dependency>\\n\\t\\t<!-- AOP切面 -->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-aop</artifactId>\\n        </dependency>\\n\\n```\\n\\n## 2、自定义切入点注解\\n\\n```java\\nimport java.lang.annotation.*;\\n\\n/**\\n * @author icatw\\n * @date 2022/10/26\\n * @email 762188827@qq.com\\n * @apiNote 自定义操作日志注解\\n */\\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\\n@Documented\\npublic @interface OperaLog {\\n    String businessName();\\n}\\n\\n/**\\n * @author icatw\\n * @date 2022/10/26\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target(ElementType.METHOD)\\npublic @interface SysLog {\\n    String businessName();\\n}\\n```\\n\\n## 3、建立日志表\\n\\n``` sql\\nCREATE TABLE `sys_log` (\\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT \'主键id\',\\n  `url` varchar(255) DEFAULT NULL COMMENT \'请求接口路径\',\\n  `business_name` varchar(20) DEFAULT NULL COMMENT \'接口名\',\\n  `http_method` varchar(20) DEFAULT NULL COMMENT \'请求类型\',\\n  `class_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT \'全路径类名\',\\n  `ip` varchar(255) DEFAULT NULL COMMENT \'请求ip\',\\n  `request_args` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT \'请求参数（json）\',\\n  `response` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci COMMENT \'响应（json）\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'请求时间\',\\n  `create_by` bigint DEFAULT NULL COMMENT \'创建人id\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=\'系统日志\';\\n```\\n\\n## 4.创建实体类\\n\\n``` java\\npackage cn.icatw.domain.entity;\\n\\nimport com.baomidou.mybatisplus.annotation.*;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport io.swagger.annotations.*;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 系统日志(Log)实体类\\n *\\n * @author icatw\\n * @since 2022-10-27 10:51:25\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@ApiModel(\\\"Log\\\")\\n@TableName(\\\"sys_log\\\")\\npublic class Log implements Serializable {\\n    private static final long serialVersionUID = -56646343480001713L;\\n    /**\\n     * 主键id\\n     */\\n    @TableId(value = \\\"id\\\", type = IdType.AUTO)\\n    private Long id;\\n\\n    /**\\n     * 请求接口路径\\n     */\\n    @TableField(value = \\\"url\\\")\\n    @ApiModelProperty(\\\"请求接口路径\\\")\\n    private String url;\\n\\n    /**\\n     * 接口名\\n     */\\n    @TableField(value = \\\"business_name\\\")\\n    @ApiModelProperty(\\\"接口名\\\")\\n    private String businessName;\\n\\n    /**\\n     * 请求类型\\n     */\\n    @TableField(value = \\\"http_method\\\")\\n    @ApiModelProperty(\\\"请求类型\\\")\\n    private String httpMethod;\\n\\n    /**\\n     * 类名\\n     */\\n    @TableField(value = \\\"class_method\\\")\\n    @ApiModelProperty(\\\"全路径类名\\\")\\n    private String classMethod;\\n\\n    /**\\n     * 请求ip\\n     */\\n    @TableField(value = \\\"ip\\\")\\n    @ApiModelProperty(\\\"请求ip\\\")\\n    private String ip;\\n\\n    /**\\n     * 请求参数（json）\\n     */\\n    @TableField(value = \\\"request_args\\\")\\n    @ApiModelProperty(\\\"请求参数（json）\\\")\\n    private String requestArgs;\\n\\n    /**\\n     * 响应（json）\\n     */\\n    @TableField(value = \\\"response\\\")\\n    @ApiModelProperty(\\\"响应（json）\\\")\\n    private String response;\\n    /**\\n     * 创建人的用户id\\n     */\\n    @TableField(fill = FieldFill.INSERT)\\n    private Long createBy;\\n    /**\\n     * 创建时间\\n     */\\n    @TableField(value = \\\"create_time\\\", fill = FieldFill.INSERT)\\n    @ApiModelProperty(\\\"请求时间\\\")\\n    private Date createTime;\\n}\\n\\n\\n```\\n\\n## 5、定义操作日志切面\\n\\n``` java\\n@Component\\n@Aspect\\n@Slf4j\\npublic class LogAspect {\\n    private final Log myLog = new Log();\\n\\n    @Autowired\\n    LogService logService;\\n\\n    @Pointcut(\\\"@annotation(cn.icatw.annotation.SysLog)\\\")\\n    public void pt() {\\n    }\\n\\n    @Around(\\\"pt()\\\")\\n    public Object printLog(ProceedingJoinPoint pjp) throws Throwable {\\n        Object ret;\\n        try {\\n            handleBefore(pjp);\\n            ret = pjp.proceed();\\n            handleAfter(ret);\\n        } finally {\\n            //结束后换行\\n            log.info(\\\"======End======\\\" + System.lineSeparator());\\n        }\\n        return ret;\\n    }\\n\\n    private void handleAfter(Object ret) {\\n        // 打印出参\\n        log.info(\\\"Response       : {}\\\", JSON.toJSONString(ret));\\n        myLog.setResponse(JSON.toJSONString(ret));\\n        logService.save(myLog);\\n    }\\n\\n    private void handleBefore(ProceedingJoinPoint pjp) {\\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\\n        HttpServletRequest request = requestAttributes.getRequest();\\n        //获取被增强方法上的注解对象\\n        SysLog sysLog = getSystemLog(pjp);\\n        log.info(\\\"=======Start=======\\\");\\n        // 打印请求 URL\\n        log.info(\\\"URL            : {}\\\", request.getRequestURL());\\n        myLog.setUrl(String.valueOf(request.getRequestURL()));\\n        // 打印描述信息\\n        log.info(\\\"BusinessName   : {}\\\", sysLog.businessName());\\n        myLog.setBusinessName(sysLog.businessName());\\n        // 打印 Http method\\n        log.info(\\\"HTTP Method    : {}\\\", request.getMethod());\\n        myLog.setHttpMethod(request.getMethod());\\n        // 打印调用 controller 的全路径以及执行方法\\n        log.info(\\\"Class Method   : {}.{}\\\",\\n                pjp.getSignature().getDeclaringTypeName(),\\n                ((MethodSignature) pjp.getSignature()).getName());\\n        myLog.setClassMethod(pjp.getSignature().getDeclaringTypeName() + \\\".\\\"\\n                + ((MethodSignature) pjp.getSignature()).getName());\\n        // 打印请求的 IP\\n        log.info(\\\"IP             : {}\\\", request.getRemoteHost());\\n        myLog.setIp(request.getRemoteHost());\\n        // 打印请求入参\\n        log.info(\\\"Request Args   : {}\\\", JSON.toJSONString(pjp.getArgs()));\\n        myLog.setRequestArgs(JSON.toJSONString(pjp.getArgs()));\\n        // 结束后换行\\n        log.info(\\\"=======End=======\\\" + System.lineSeparator());\\n    }\\n\\n    private SysLog getSystemLog(ProceedingJoinPoint pjp) {\\n        MethodSignature signature = (MethodSignature) pjp.getSignature();\\n        return signature.getMethod().getAnnotation(SysLog.class);\\n    }\\n}\\n```\\n\\n必须加上`@Component`和`@Aspect`注解\\n\\n## 6、在需要记录日志的Controller方法上打上@OperaLog注解\\n\\n``` java\\n @PostMapping(\\\"/login\\\")\\n    @SysLog(businessName = \\\"用户登陆\\\")\\n    public ResponseResult login(@RequestBody User user) {\\n        return blogLoginService.login(user);\\n    }\\n```\\n\\n大功告成！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/30f83ce0bea0c233814f0b6e2a5624e6.jpg\",\"articleTitle\":\" AOP+注解实现日志记录\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','116.162.0.30','湖南省 联通','2022-10-27 14:33:13',NULL),(1225,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot初始化程序\\n\\n> 今天在做博客项目时遇到了更新浏览量的问题\\n>\\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\\n\\n```java\\npackage cn.icatw.runner;\\n\\nimport cn.icatw.Constants.SystemConstants;\\nimport cn.icatw.domain.entity.Article;\\nimport cn.icatw.mapper.ArticleMapper;\\nimport cn.icatw.utils.RedisCache;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.boot.CommandLineRunner;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * 在项目启动时将文章浏览量存入Redis中\\n *\\n * @author icatw\\n * @date 2022/10/27\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class ViewCountRunner implements CommandLineRunner {\\n    @Resource\\n    ArticleMapper articleMapper;\\n    @Resource\\n    RedisCache redisCache;\\n\\n    @Override\\n    public void run(String... args) throws Exception {\\n        List<Article> articles = articleMapper.selectList(null);\\n        Map<String, Integer> map = articles.stream().collect(\\n                //将文章id和浏览量以map结构存入redis中\\n                Collectors.toMap(article -> article.getId().toString(),\\n                        article -> article.getViewCount().intValue()));\\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\\n        log.info(\\\"===缓存初始化成功===\\\");\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg\",\"articleTitle\":\"SpringBoot初始化程序\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','116.162.0.30','湖南省 联通','2022-10-27 16:37:52',NULL),(1226,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot初始化程序\\n\\n> 今天在做博客项目时遇到了更新浏览量的问题\\n>\\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\\n\\n```java\\npackage cn.icatw.runner;\\n\\nimport cn.icatw.Constants.SystemConstants;\\nimport cn.icatw.domain.entity.Article;\\nimport cn.icatw.mapper.ArticleMapper;\\nimport cn.icatw.utils.RedisCache;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.boot.CommandLineRunner;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * 在项目启动时将文章浏览量存入Redis中\\n *\\n * @author icatw\\n * @date 2022/10/27\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class ViewCountRunner implements CommandLineRunner {\\n    @Resource\\n    ArticleMapper articleMapper;\\n    @Resource\\n    RedisCache redisCache;\\n\\n    @Override\\n    public void run(String... args) throws Exception {\\n        List<Article> articles = articleMapper.selectList(null);\\n        Map<String, Integer> map = articles.stream().collect(\\n                //将文章id和浏览量以map结构存入redis中\\n                Collectors.toMap(article -> article.getId().toString(),\\n                        article -> article.getViewCount().intValue()));\\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\\n        log.info(\\\"===缓存初始化成功===\\\");\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg\",\"articleTitle\":\"SpringBoot初始化程序\",\"categoryName\":\"Java后端\",\"id\":118,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-11-14 21:32:24',NULL),(1227,'文章模块','修改','/admin/articles/top','com.minzheng.blog.controller.ArticleController.updateArticleTop','修改文章置顶','[{\"id\":118,\"isTop\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','58.20.30.140','湖南省长沙市 联通','2022-12-13 17:05:34',NULL),(1228,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1213213测试\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2023-11-13\",\"categoryName\":\"MySQL\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.126','湖南省张家界市 联通','2023-11-13 09:08:54',NULL),(1229,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1213213测试\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2023-11-13\",\"categoryName\":\"MySQL\",\"id\":119,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.126','湖南省张家界市 联通','2023-11-13 09:09:09',NULL),(1230,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[119],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.126','湖南省张家界市 联通','2023-11-13 09:09:50',NULL),(1231,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot使用@Scheduled注解实现定时任务\\n\\n1. 首先在启动类上加上@EnableScheduling注解\\n\\n![image-20231204081917602](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231204081917602.png)\\n\\n2. 创建定时任务\\n\\n使用@Scheduled注解创建定时任务，并使用@Component注入容器中。\\n\\n```java\\npackage com.pumpkin.disease.schedule;\\n\\nimport com.pumpkin.disease.service.ImageService;\\nimport org.springframework.scheduling.annotation.Scheduled;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.text.SimpleDateFormat;\\nimport java.util.Date;\\n\\n/**\\n * @author 王顺\\n * @date 2023/12/2\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\npublic class ImageUploadTask {\\n    @Resource\\n    ImageService imageService;\\n    private static final SimpleDateFormat f=new SimpleDateFormat(\\\"HH:mm:ss\\\");\\n\\n    /**\\n     * 上传oss\\n     * 60秒执行一次\\n     */\\n    @Scheduled(fixedRate = 60000)\\n    public void uploadOss(){\\n        imageService.timedUpload();\\n        System.out.println(\\\"timedUpload方式开启定时任务：现在的时间是\\\"+f.format(new Date()));\\n    }\\n}\\n```\\n\\n3. 编写定时任务实现\\n\\n```java\\n@Override\\npublic void timedUpload() {\\n    try {\\n        //最大520张\\n        long count = this.count();\\n        if (count > 520) {\\n            return;\\n        }\\n        ImageJson imageJson = ImageUtil.getRandomImageJson();\\n        AssertUtil.assertIsNotPass(AssertUtil.isNull(imageJson), \\\"壁纸接口异常！\\\");\\n        //把地址转换成URL对象\\n        URL url = new URL(Objects.requireNonNull(imageJson).getImgurl());\\n        //创建http链接\\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\\n        //设置超时间为3秒\\n        conn.setConnectTimeout(3 * 1000);\\n        //防止屏蔽程序抓取而返回403错误\\n        conn.setRequestProperty(\\\"User-Agent\\\", \\\"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\\\");\\n        //得到输入流\\n        InputStream inputStream = conn.getInputStream();\\n        /**\\n         * filename:文件名\\n         * file.getName()：原文件名称\\n         * file.getContentType()：原文件ContentType\\n         * fileStream：文件输入字节流\\n         */\\n        MultipartFile file = new MockMultipartFile(\\\"filename\\\", \\\"\\\", imageJson.getFormat(), inputStream);\\n        String ossUrl = uploadStrategyContext.executeUploadFile(file, UploadModeEnum.OSS_UPLOAD.getMode(), \\\"randomWallpaper\\\");\\n        Image image = new Image();\\n        image.setImageUrl(ossUrl);\\n        image.setImageName(\\\"随机测试\\\");\\n        image.setDescription(\\\"这是壁纸接口拿来的随机图片\\\");\\n        image.setTypeId(getTypeIdByCategory(imageJson.getCategory()));\\n        saveImage(image);\\n        log.info(\\\"图片保存成功！\\\");\\n        System.out.println(ossUrl);\\n    } catch (IOException e) {\\n        e.printStackTrace();\\n    }\\n}\\n```\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2dc722f14293755dad61ba4ef9980332.jpg\",\"articleTitle\":\"SpringBoot使用@Scheduled注解实现定时任务\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','110.52.110.219','湖南省张家界市永定区 联通','2023-12-04 08:28:40',NULL),(1232,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Spring Boot + Vue 壁纸分享平台项目讲解\\n\\n大家好，我很荣幸在这里向大家介绍我们的壁纸分享平台项目。这个项目包括了前台和后台两个部分，为用户提供了丰富的壁纸资源和强大的管理功能。\\n\\n## 1. 项目背景\\n\\n##### 随着互联网的发展，壁纸分享平台在用户生活中扮演着越来越重要的角色。与传统壁纸网站不同，我们的平台不仅提供了丰富多彩的壁纸资源，而且是完全免费的。用户可以自由上传、分享、和下载高质量的壁纸，为用户提供了更广泛的选择空间。 在传统壁纸网站中，用户往往需要支付费用或者受到下载次数的限制，一不小心可能还会跳转到广告页面。而我们的平台通过开放的上传和下载机制，鼓励用户分享和交流优秀的作品。这不仅丰富了平台的壁纸库，也构建了一个更加活跃和友好的社区。\\n\\n## 2. 在线地址\\n\\n- **前台地址：** [www.wallpaper.icatw.top](http://www.wallpaper.icatw.top)\\n- **后台管理系统地址：** [www.admin.wallpaper.icatw.top](http://www.admin.wallpaper.icatw.top)\\n\\n**项目截图**\\n\\n![项目截图1](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003029075.png)\\n\\n![项目截图2](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002930533.png)\\n\\n![项目截图3](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002945631.png)\\n\\n![项目截图4](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003010907.png)\\n\\n![项目截图5](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003120406.png)\\n\\n![项目截图6](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003134608.png)\\n\\n![项目截图7](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003145402.png)\\n\\n\\n## 3. 技术栈概览\\n\\n### 后端技术栈：\\n\\n- **Spring Boot：** 强大的后端框架，提供快速开发和部署的能力。\\n- **Spring Security：** 实现了基于RBAC权限模型的动态权限路由系统，确保灵活而安全的权限控制。\\n- **MyBatisPlus：** 数据库操作的优秀框架，简化了数据库交互的流程。\\n- **Swagger3和Knife4j：** 提供了强大的接口管理和文档生成功能，方便团队协作和API调试。\\n- **Redis：** 用于缓存和提高系统性能。\\n- **对象存储：** 支持腾讯云Cos、七牛云Kodo和阿里云Oss对象存储，为用户提供高效的图片存储和访问。\\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\\n- **JWT Token 登录：** 使用JWT实现了无状态的用户认证，增强了系统的安全性。\\n\\n### 代码结构：\\n\\n![代码结构](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205001504507.png)\\n\\n### 前端技术栈：\\n\\n- **Vue.js：** 强大的前端框架，使我们能够构建响应式和高性能的用户界面。\\n- **Vue Router：** 提供了在单页面应用中进行导航的能力，使用户能够方便地切换页面。\\n- **Vuex：** 用于管理应用的状态，实现组件之间的共享数据。\\n- **Element UI、Ant Design Vue：** 提供了一套美观、易用的UI组件，简化了页面的开发过程。\\n- **Axios：** 用于进行HTTP请求，与后端进行数据交互。\\n\\n## 4. 主要功能\\n\\n### 前台用户功能：\\n\\n- **用户认证与授权：** 提供注册和登录功能，确保用户信息的安全性。\\n- **壁纸搜索与分类：** 用户可以轻松找到自己喜欢的壁纸，支持多种分类方式。\\n- **个人信息管理：** 用户可以管理自己的个人信息，包括上传头像等。\\n- **收藏：** 用户可以收藏喜欢的壁纸。\\n- **JWT Token 登录：** 采用JWT Token方式进行用户身份验证，保障用户信息安全。\\n\\n### 后台管理系统功能：\\n\\n- **壁纸管理：**\\n  - 壁纸管理：管理壁纸相关信息，包括增删改查。\\n  - 分类管理：壁纸分类相关信息。\\n- **用户管理：**\\n  - 用户管理：管理用户相关信息，包括增删改查以及重置密码操作。\\n- **权限管理：**\\n  - 角色管理：管理系统角色，分配相应权限。\\n  - 菜单管理：配置系统菜单，实现动态权限路由。\\n- **日志管理：**\\n  - 登陆日志：记录用户登录信息，提高系统安全性。\\n  - 操作日志：记录用户操作信息，便于系统行为追溯。\\n- **系统管理：**\\n  - 系统配置：动态配置存储在数据库中，包括对象存储等。\\n  - 文件存储相关配置：配置文件存储的相关信息。\\n- **系统监控：**\\n  - 实现系统监控功能，包括性能、资源使用情况等。\\n\\n## 5. 创新与亮点\\n\\n- **动态权限路由：** 利用RBAC权限模型和Spring Security及前端Vue-Router实现的动态权限路由系统，确保权限控制的灵活性。\\n- **动态配置：** 使用策略模式和后台管理系统的配置菜单，实现了动态配置，包括对象存储等。\\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\\n- **用户自由度高：** 网站完全免费登录注册，无需积分，不限下载次数，可以自行上传与分享高质量的壁纸。\\n- **JWT Token登录：** 采用JWT Token方式进行用户身份验证，增加了系统的安全性。\\n\\n## 6. 不足及后续计划\\n\\n**项目不足之处：** 由于项目时间紧迫，我们承认某些功能可能没有完全开发完成，其中包括用户上传图片审核功能。此外，系统在使用过程中可能存在一些bug，我们期待老师及同学们能够给予宝贵的意见和建议，以帮助我们不断改进和提升。\\n\\n- **后续计划：** 我们已经在计划中，将在未来的版本中引入一些重要的功能和改进，包括但不限于：\\n  - **JustAuth第三方登录：** 提供更便捷的用户登录体验，增强用户友好性。\\n  - **忘记密码找回功能**：使用阿里云短信服务或者集成邮箱实现手机号/邮箱找回密码功能。\\n  - **用户上传图片审核功能：** 引入审核机制，防止恶意上传图片，提高平台内容质量。\\n  - **反馈功能：** 添加用户反馈功能，促进用户参与，及时发现和解决问题。\\n  - **性能优化和Bug修复：** 不断优化系统性能，修复已知和新发现的bug，提高系统稳定性。\\n\\n## 结语\\n\\n以上便是关于i壁纸的项目介绍，感谢老师们的聆听，目前项目已上线，我们欢迎大家在使用过程中提出建议和需求，共同为平台的持续改进努力。谢谢您的理解与支持！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2dc722f14293755dad61ba4ef9980332.jpg\",\"articleTitle\":\"Spring Boot + Vue 壁纸分享平台\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.2','湖南省张家界市 联通','2023-12-05 00:50:08',NULL),(1233,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# docker部署springboot项目\\n\\n前提是服务器安装了docker及相关服务\\n\\n## 1.使用maven打包springboot项目\\n\\n​\\t**使用maven-package打jar包**\\n\\n![image-20231221011704644](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221011704644.png)\\n\\n## 2.编写dockerfile文件\\n\\n![image-20231221015601110](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221015601110.png)\\n\\n```dockerfile\\n#依赖的父镜像\\nFROM java:8\\n#作者\\nMAINTAINER icatw\\n#jar包添加到镜像中\\n# ADD wallpaper-server-1.0.jar wallpaper.jar\\n#容器暴露的端口 即jar程序在容器中运行的端口\\nEXPOSE 9888\\n#容器启动之后要执行的命令\\nENTRYPOINT [\\\"java\\\",\\\"-Xmx256m\\\",\\\"-Xms256m\\\",\\\"-jar\\\",\\\"/data/wallpaper.jar\\\"]\\n```\\n\\n### 3.上传至服务器\\n\\n![image-20231221190059655](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190059655.png)\\n\\n![image-20231221190132391](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190132391.png)\\n\\n## 4.cd进入dockerfile\\n\\n**使用docker build -t wallpaper .**\\n\\n构建docker镜像\\n\\n## 5.运行docker容器\\n\\ndocker run --name wallpaper   -p 9999:9999 -d \\n\\n![image-20231221190834449](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231221190834449.png)\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"docker部署springboot项目\",\"categoryName\":\"Java后端\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','110.53.52.47','湖南省张家界市武陵源区 联通','2023-12-21 19:16:49',NULL),(1234,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2023-12-25\",\"categoryName\":\"MySQL\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2023-12-25 11:44:26',NULL),(1235,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2023-12-25\",\"categoryName\":\"MySQL\",\"id\":123,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2023-12-25 11:45:04',NULL),(1236,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"1\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2023-12-25\",\"categoryName\":\"MySQL\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2023-12-25 16:41:46',NULL),(1237,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[124],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2023-12-25 16:42:16',NULL),(1238,'文章模块','修改','/admin/articles','com.minzheng.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[123],\"isDelete\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2023-12-25 16:42:20',NULL),(1239,'评论模块','修改','/admin/comments/review','com.minzheng.blog.controller.CommentController.updateCommentsReview','审核评论','[{\"idList\":[733],\"isReview\":1}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.224','湖南省张家界市 联通','2023-12-26 01:11:06',NULL),(1240,'友链模块','新增或修改','/admin/links','com.minzheng.blog.controller.FriendLinkController.saveOrUpdateFriendLink','保存或修改友链','[{\"linkAddress\":\"http://www.icatw.top\",\"linkAvatar\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/dde3c71e642f112140ce6ec3797bbf27.jpg\",\"linkIntro\":\"一个博客网\",\"linkName\":\"icatwのblog\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.224','湖南省张家界市 联通','2023-12-26 01:14:34',NULL),(1241,'博客信息模块','修改','/admin/about','com.minzheng.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"一个服务器被挖矿的人..\\n\"}]','PUT','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','42.49.202.224','湖南省张家界市 联通','2023-12-26 01:20:30',NULL),(1242,'分类模块','新增或修改','/admin/categories','com.minzheng.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"代码片段\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.35.118','湖南省永州市 电信','2024-01-29 11:34:19',NULL),(1243,'标签模块','新增或修改','/admin/tags','com.minzheng.blog.controller.TagController.saveOrUpdateTag','添加或修改标签','[{\"tagName\":\"Java\"}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.35.118','湖南省永州市 电信','2024-01-29 11:34:33',NULL),(1244,'文章模块','新增或修改','/admin/articles','com.minzheng.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# 设计模式使用之策略模式\\n\\n在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\\n\\n在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。\\n\\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\\n\\n## 介绍\\n\\n**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\\n\\n**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\\n\\n**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。\\n\\n**如何解决：**将这些算法封装成一个一个的类，任意地替换。\\n\\n**关键代码：**实现同一个接口。\\n\\n**应用实例：** 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\\n\\n**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\\n\\n**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。\\n\\n**使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\\n\\n**注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\\n\\n**策略模式包含以下几个核心角色：**\\n\\n- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。\\n- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。\\n- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。\\n\\n策略模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法。客户端代码不需要知道具体的算法细节，而是通过调用环境类来使用所选择的策略。\\n\\n## 实现\\n\\n我们将创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。\\n\\n*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。\\n\\n![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)\\n\\n### 步骤 1\\n\\n创建一个接口。\\n\\n**Strategy.java**\\n\\n``` java\\npublic interface Strategy {   \\n\\tpublic int doOperation(int num1, int num2); \\n}\\n```\\n\\n### 步骤 2\\n\\n创建实现接口的实体类。\\n\\n**OperationAdd.java**\\n\\n```java\\npublic class OperationAdd implements Strategy{   \\n@Override   public int doOperation(int num1, int num2) \\n{return num1 + num2;} \\n}\\n```\\n\\n**OperationSubtract.java**\\n\\n```  java\\npublic class OperationSubtract implements Strategy{   \\n    @Override   public int doOperation(int num1, int num2) \\n    {      return num1 - num2;   } \\n}\\n```\\n\\n**OperationMultiply.java**\\n\\n``` java\\npublic class OperationMultiply implements Strategy{   \\n    @Override   public int doOperation(int num1, int num2) \\n    {      return num1 * num2;   } \\n}\\n```\\n\\n### 步骤 3\\n\\n创建 *Context* 类。\\n\\n**Context.java**\\n\\n``` java\\npublic class Context {   \\n    private Strategy strategy;    \\n    public Context(Strategy strategy)\\n    {this.strategy = strategy;}    \\n    public int executeStrategy(int num1, int num2){      \\n        return strategy.doOperation(num1, num2);} \\n}\\n```\\n\\n### 步骤 4\\n\\n使用 *Context* 来查看当它改变策略 *Strategy* 时的行为变化。\\n\\n**StrategyPatternDemo.java**\\n\\n``` java\\npublic class StrategyPatternDemo {   \\n    public static void main(String[] args) {      \\n        Context context = new Context(new OperationAdd());          \\n        System.out.println(\\\"10 + 5 = \\\" + context.executeStrategy(10, 5));       \\n        context = new Context(new OperationSubtract());            \\n        System.out.println(\\\"10 - 5 = \\\" + context.executeStrategy(10, 5));       \\n        context = new Context(new OperationMultiply());          \\n        System.out.println(\\\"10 * 5 = \\\" + context.executeStrategy(10, 5));   } } \\n```\\n\\n### 步骤 5\\n\\n执行程序，输出结果：\\n\\n```tex\\n10 + 5 = 15\\n10 - 5 = 5\\n10 * 5 = 50\\n```\\n\\n## 项目中的具体应用\\n\\n> 现有一个需求，要求系统能够强制删除数据（物理删除）以及保存删除的关键数据，并将此功能封装，之后会有更多的模块需要扩展实现强制删除的功能，在此我们使用策略模式实现。\\n\\n**需要保留的关键字段我们使用自定义注解 ` ForceDeleteLog` 标识**\\n\\n``` java\\nimport java.lang.annotation.ElementType;\\nimport java.lang.annotation.Retention;\\nimport java.lang.annotation.RetentionPolicy;\\nimport java.lang.annotation.Target;\\n\\n/**\\n * 强制删除日志保留字段\\n *\\n * @author wangshun\\n * @date 2024/01/24\\n */\\n@Target(ElementType.FIELD)\\n@Retention(RetentionPolicy.RUNTIME)\\npublic @interface ForceDeleteLog {\\n}\\n\\n```\\n\\n**之后在实体类中需要保存记录的属性上加上这个注解即可**\\n\\n#### **1.定义策略接口**\\n\\n``` java\\n/**\\n * @author 王顺\\n * @date 2024/1/24\\n * @apiNote 强制删除策略\\n */\\npublic interface ForceDeleteStrategy {\\n    /**\\n     * 强制删除和保存\\n     *\\n     * @param forceDelete 强制删除\\n     * @return {@link String}\\n     * @throws Exception 例外\\n     */\\n    @Transactional(rollbackFor = Exception.class)\\n    String forceDeletionAndSaving(ForceDelete forceDelete)throws Exception  ;\\n}\\n\\n```\\n\\n#### 2.扩展抽象接口\\n\\n``` java\\nimport com.chalco.contractor.forceDelete.aop.ForceDeleteLog;\\nimport com.chalco.contractor.forceDelete.entity.ForceDelete;\\nimport com.chalco.contractor.forceDelete.strategy.ForceDeleteStrategy;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport lombok.Getter;\\nimport lombok.Setter;\\nimport lombok.extern.slf4j.Slf4j;\\n\\nimport java.lang.reflect.Field;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * @author 王顺\\n * @date 2024/1/24\\n * @apiNote\\n */\\n@Getter\\n@Setter\\n@Slf4j\\npublic abstract class AbstractForceDeleteStrategyImpl implements ForceDeleteStrategy {\\n\\n    /**\\n     * 强制删除和保存\\n     *\\n     * @return {@link String}\\n     * @throws Exception 例外\\n     */\\n    @Override\\n    public String forceDeletionAndSaving(ForceDelete forceDelete) throws Exception {\\n        if (preCheck(forceDelete)) {\\n            save(forceDelete);\\n            forceDelete(forceDelete);\\n            return getModuleName()+\\\"强制删除成功！\\\";\\n\\n        }\\n        return \\\"错误\\\";\\n    }\\n\\n    public static String convertToJson(Object entity) {\\n        ObjectMapper objectMapper = new ObjectMapper();\\n        Map<String, Object> jsonMap = new HashMap<>(5);\\n\\n        for (Field field : entity.getClass().getDeclaredFields()) {\\n            field.setAccessible(true);\\n\\n            // 检查字段是否带有 @ForceDeleteLog 注解\\n            if (field.isAnnotationPresent(ForceDeleteLog.class)) {\\n                try {\\n                    // 将带有 @ForceDeleteLog 注解的字段添加到 JSON 中\\n                    jsonMap.put(field.getName(), field.get(entity));\\n                } catch (IllegalAccessException e) {\\n                    log.error(\\\"convertToJson error\\\", e);\\n                }\\n            }\\n        }\\n\\n        try {\\n            // 将 Map 转换为 JSON 字符串\\n            return objectMapper.writeValueAsString(jsonMap);\\n        } catch (Exception e) {\\n            log.error(\\\"convertToJson error\\\", e);\\n        }\\n\\n        return null;\\n    }\\n\\n    /**\\n     * 获取表名\\n     *\\n     * @return {@link String}\\n     * @throws Exception 例外\\n     */\\n    public abstract String getTableName() ;\\n\\n    /**\\n     * 获取模块名称\\n     *\\n     * @return {@link String}\\n     * @throws Exception 例外\\n     */\\n    public abstract String getModuleName() ;\\n\\n    /**\\n     * 前置校验\\n     *\\n     * @param forceDelete 强制删除\\n     * @return boolean\\n     * @throws Exception 例外\\n     */\\n    public abstract boolean preCheck(ForceDelete forceDelete) throws Exception;\\n\\n    /**\\n     * 强制删除\\n     *\\n     * @param forceDelete 强制删除\\n     * @throws Exception 例外\\n     */\\n    public abstract void forceDelete(ForceDelete forceDelete) throws Exception;\\n\\n    /**\\n     * 保存\\n     *\\n     * @param forceDelete 强制删除\\n     * @throws Exception 例外\\n     */\\n    public abstract void save(ForceDelete forceDelete) throws Exception;\\n}\\n\\n```\\n\\n#### 3.具体的业务接口\\n\\n``` java\\npackage com.chalco.contractor.forceDelete.strategy.impl;\\n\\nimport cn.hutool.core.collection.CollUtil;\\nimport com.alibaba.fastjson.JSON;\\nimport com.chalco.contractor.forceDelete.entity.ErrorMsg;\\nimport com.chalco.contractor.forceDelete.entity.ForceDelete;\\nimport com.chalco.contractor.forceDelete.service.ForceDeleteService;\\nimport com.chalco.contractor.outsourcingProjectManagement.entity.OutsourcingUnitManagement;\\nimport com.chalco.contractor.outsourcingProjectManagement.mapper.OutsourcingUnitManagementMapper;\\nimport com.chalco.contractor.outsourcingProjectManagement.service.MultipleUnitManagementService;\\nimport com.chalco.contractor.outsourcingProjectManagement.service.OutsourcingContractService;\\nimport com.chalco.contractor.outsourcingProjectManagement.service.OutsourcingUnitManagementService;\\nimport com.chalco.core.exception.BusinessException;\\nimport com.chalco.modules.sys.service.AppointmentService;\\nimport lombok.Getter;\\nimport lombok.RequiredArgsConstructor;\\nimport lombok.Setter;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\n\\n/**\\n * @author 王顺\\n * @date 2024/1/24\\n * @apiNote\\n */\\n@Getter\\n@Setter\\n@RequiredArgsConstructor\\n@Slf4j\\n@Service(\\\"unitForceDeletionStrategyImpl\\\")\\npublic class UnitForceDeleteStrategyImpl extends AbstractForceDeleteStrategyImpl {\\n    private final bean bean;\\n\\n    @Override\\n    public String getTableName()  {\\n        return \\\"表名\\\";\\n    }\\n\\n    @Override\\n    public String getModuleName()  {\\n        return \\\"模块名\\\";\\n    }\\n\\n    @Override\\n    public boolean preCheck(ForceDelete forceDelete) {\\n        return true;\\n    }\\n\\n    @Override\\n    public void forceDelete(ForceDelete forceDelete) throws Exception {\\n\\n    }\\n\\n    @Override\\n    public void save(ForceDelete forceDelete) throws Exception {\\n    }\\n}\\n\\n```\\n\\n**需要重写方法实现具体的业务逻辑**（略）\\n\\n#### 4.策略上下文\\n\\n``` java\\n/**\\n * 强制删除策略上下文\\n *\\n * @author wangshun\\n * @date 2024/01/26\\n */\\n@Component\\n@RequiredArgsConstructor\\npublic class ForceDeleteStrategyContext {\\n\\n    private final Map<String, ForceDeleteStrategy> forceDeletionStrategyMap;\\n\\n    /**\\n     * 执行强制删除策略\\n     *\\n     * @param forceDelete            强制删除\\n     * @param forceDeleteServiceName 强制删除服务名称\\n     * @return {@link String}\\n     */\\n    public String executeForceDeleteStrategy(ForceDelete forceDelete, String forceDeleteServiceName) throws Exception {\\n        //try {\\n            // 执行特定的强制删除策略\\n            return forceDeletionStrategyMap.get(forceDeleteServiceName).forceDeletionAndSaving(forceDelete);\\n        //} catch (Exception e) {\\n        //    throw new BusinessException(\\\"执行强制删除策略失败\\\");\\n        //}\\n    }\\n}\\n```\\n\\n>Spring在注入集合类的同时，会将集合泛型类的实例填入集合中，作为集合的初始值。 对于list、set填入的是注入类型Spring管理的实例，对于map，Spring会将service的名字作为key，对象作为value封装进入Map。\\n\\n#### 5.策略枚举类\\n\\n``` java\\nimport lombok.AllArgsConstructor;\\nimport lombok.Getter;\\n\\n/**\\n * @author 王顺\\n * @date 2024/1/24\\n * @apiNote\\n */\\n@Getter\\n@AllArgsConstructor\\npublic enum ForceDeleteStrategyImplEnum {\\n    /**\\n     * 承包单位\\n     */\\n    UNIT(\\\"承包单位\\\", \\\"unitForceDeletionStrategyImpl\\\");\\n\\n    private final String moduleName;\\n    private final String implClass;\\n\\n    /**\\n     * 按键获取值\\n     *\\n     * @param key 钥匙\\n     * @return {@link String}\\n     */\\n    public static String getValueByKey(String key) {\\n        for (ForceDeleteStrategyImplEnum sampleEnum : values()) {\\n            if (sampleEnum.getModuleName().equals(key)) {\\n                return sampleEnum.getImplClass();\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n#### 6.策略调用\\n\\n```java\\n/**\\n * 强制删除\\n *\\n * @param forceDelete ids\\n * @return {@link R}<{@link Boolean}>\\n */\\n@RequestMapping(\\\"forceDelete\\\")\\npublic R<String> forceDelete(ForceDelete forceDelete) throws Exception {\\n    return R.data(forceDeleteStrategyContext.executeForceDeleteStrategy(forceDelete, ForceDeleteStrategyImplEnum.UNIT.getImplClass()));\\n}\\n```\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"设计模式使用之策略模式\",\"categoryName\":\"设计模式\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"设计模式\"],\"type\":1}]','POST','{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','175.5.35.118','湖南省永州市 电信','2024-01-29 15:46:28',NULL),(1245,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"111\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-03-26\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[\"测试\"],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-27 15:32:39','2024-03-27 15:32:39'),(1246,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"111\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-03-26\",\"categoryName\":\"项目总结\",\"id\":126,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-27 19:07:54','2024-03-27 19:07:54'),(1247,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot初始化程序\\n\\n> 今天在做博客项目时遇到了更新浏览量的问题\\n>\\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\\n\\n```java\\npackage cn.icatw.runner;\\n\\nimport cn.icatw.Constants.SystemConstants;\\nimport cn.icatw.domain.entity.Article;\\nimport cn.icatw.mapper.ArticleMapper;\\nimport cn.icatw.utils.RedisCache;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.boot.CommandLineRunner;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * 在项目启动时将文章浏览量存入Redis中\\n *\\n * @author icatw\\n * @date 2022/10/27\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class ViewCountRunner implements CommandLineRunner {\\n    @Resource\\n    ArticleMapper articleMapper;\\n    @Resource\\n    RedisCache redisCache;\\n\\n    @Override\\n    public void run(String... args) throws Exception {\\n        List<Article> articles = articleMapper.selectList(null);\\n        Map<String, Integer> map = articles.stream().collect(\\n                //将文章id和浏览量以map结构存入redis中\\n                Collectors.toMap(article -> article.getId().toString(),\\n                        article -> article.getViewCount().intValue()));\\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\\n        log.info(\\\"===缓存初始化成功===\\\");\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg\",\"articleTitle\":\"SpringBoot初始化程序\",\"categoryName\":\"Java后端\",\"id\":118,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"msg\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-27 19:15:42','2024-03-27 19:15:42'),(1248,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[726]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:19:37','2024-03-28 09:19:37'),(1249,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[726]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:19:47','2024-03-28 09:19:47'),(1250,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:26:48','2024-03-28 09:26:48'),(1251,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:28:31','2024-03-28 09:28:31'),(1252,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:29:17','2024-03-28 09:29:17'),(1253,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:30:36','2024-03-28 09:30:36'),(1254,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:32:42','2024-03-28 09:32:42'),(1255,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:41:02','2024-03-28 09:41:02'),(1256,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','根据id恢复或删除文章','[{\"idList\":[126],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:42:40','2024-03-28 09:42:40'),(1257,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[726]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:45:23','2024-03-28 09:45:23'),(1258,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[726]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:45:59','2024-03-28 09:45:59'),(1259,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[726]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:50:40','2024-03-28 09:50:40'),(1260,'评论模块','删除','/admin/comments','cn.icatw.blog.controller.CommentController.deleteComments','根据主键id删除评论','[[725]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 09:51:12','2024-03-28 09:51:12'),(1261,'留言模块','修改','/admin/messages/review','cn.icatw.blog.controller.MessageController.updateMessagesReview','审核留言','[{\"idList\":[3947],\"isReview\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 10:38:35','2024-03-28 10:38:35'),(1262,'留言模块','修改','/admin/messages/review','cn.icatw.blog.controller.MessageController.updateMessagesReview','审核留言','[{\"idList\":[3947],\"isReview\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-03-28 10:40:58','2024-03-28 10:40:58'),(1264,'未知','删除','/admin/categories','cn.icatw.blog.controller.CategoryController.deleteCategories','','[[201,200]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-07 08:36:09','2024-04-07 08:36:09'),(1266,'博客信息模块','修改','/admin/about','cn.icatw.blog.controller.BlogInfoController.updateAbout','修改关于我信息','[{\"aboutContent\":\"测试\"}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-07 20:03:20','2024-04-07 20:03:20'),(1267,'角色模块','新增或修改','/admin/role','cn.icatw.blog.controller.RoleController.saveOrUpdateRole','保存或更新角色','[{\"menuIdList\":[1,2],\"roleLabel\":\"test\",\"roleName\":\"测试用户\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-10 10:06:48','2024-04-10 10:06:48'),(1268,'用户信息模块','修改','/admin/users/role','cn.icatw.blog.controller.UserInfoController.updateUserRole','后台修改用户角色和昵称','[{\"nickname\":\"用户1494523322402181121\",\"roleIdList\":[2,15],\"userInfoId\":1006}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-10 10:08:23','2024-04-10 10:08:23'),(1269,'角色模块','新增或修改','/admin/role','cn.icatw.blog.controller.RoleController.saveOrUpdateRole','保存或更新角色','[{\"id\":15,\"menuIdList\":[1,2,6,7,8,9,10],\"roleLabel\":\"test\",\"roleName\":\"测试用户\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-10 10:20:55','2024-04-10 10:20:55'),(1270,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"111\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-04-10\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',996,'用户1494523322402181121','127.0.0.1','','2024-04-10 10:21:44','2024-04-10 10:21:44'),(1271,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"测试\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-04-10\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',996,'用户1494523322402181121','127.0.0.1','','2024-04-10 11:43:43','2024-04-10 11:43:43'),(1272,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"测试\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-04-10\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',996,'用户1494523322402181121','127.0.0.1','','2024-04-10 11:45:48','2024-04-10 11:45:48'),(1273,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"测试\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/d34b4d9b7fcb59c2a9af90d8896ec5e0.jpg\",\"articleTitle\":\"2024-04-10\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',996,'用户1494523322402181121','127.0.0.1','','2024-04-10 11:47:17','2024-04-10 11:47:17'),(1274,'角色模块','新增或修改','/admin/role','cn.icatw.blog.controller.RoleController.saveOrUpdateRole','保存或更新角色','[{\"id\":15,\"resourceIdList\":[447,448,475,481],\"roleLabel\":\"test\",\"roleName\":\"测试用户\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'鹿满川','127.0.0.1','','2024-04-11 19:34:55','2024-04-11 19:34:55'),(1275,'角色模块','新增或修改','/admin/role','cn.icatw.blog.controller.RoleController.saveOrUpdateRole','保存或更新角色','[{\"id\":1,\"menuIdList\":[1,2,6,7,8,9,10,3,11,12,202,13,201,213,14,15,16,4,214,219,209,17,18,205,206,208,210,215,216,217,218,19,20,5],\"roleLabel\":\"admin\",\"roleName\":\"管理员\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'','127.0.0.1','','2024-04-16 15:54:44','2024-04-16 15:54:44'),(1276,'角色模块','新增或修改','/admin/role','cn.icatw.blog.controller.RoleController.saveOrUpdateRole','保存或更新角色','[{\"id\":1,\"menuIdList\":[1,2,6,7,8,9,10,3,11,12,202,13,201,213,14,15,16,4,214,219,209,17,18,205,206,208,210,215,216,217,218,19,20,5],\"roleLabel\":\"admin\",\"roleName\":\"管理员\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'','127.0.0.1','','2024-04-16 15:54:44','2024-04-16 15:54:44'),(1277,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"test\",\"articleCover\":\"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvjbiryxtj21hc0u07mz.jpg\",\"articleTitle\":\"2024-04-16\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 16:31:55','2024-04-16 16:31:55'),(1278,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"test\",\"articleCover\":\"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvjbiryxtj21hc0u07mz.jpg\",\"articleTitle\":\"2024-04-16\",\"categoryName\":\"项目总结\",\"id\":131,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 16:33:28','2024-04-16 16:33:28'),(1279,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"clientId\":\"1111\",\"clientSecret\":\"111·1\",\"isDisable\":0,\"name\":\"测试应用\",\"oauthName\":\"qq\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 18:01:03','2024-04-16 18:01:03'),(1280,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"测试QQ应用1\",\"clientId\":\"1111\",\"clientSecret\":\"111·1\",\"createTime\":1713261663000,\"id\":1,\"isDisable\":0,\"oauthName\":\"qq\",\"type\":2,\"updateTime\":1713261663000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 19:16:04','2024-04-16 19:16:04'),(1281,'未知','删除','/admin/oauth','cn.icatw.blog.controller.OauthController.deleteOauth','删除三方登录信息','[[1]]','DELETE','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 19:16:28','2024-04-16 19:16:28'),(1282,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"测试QQ应用1\",\"clientId\":\"11\",\"clientSecret\":\"111\",\"createTime\":1713261663000,\"isDisable\":0,\"oauthName\":\"qq\",\"updateTime\":1713261663000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 19:17:15','2024-04-16 19:17:15'),(1283,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"测试QQ应用1\",\"clientId\":\"11\",\"clientSecret\":\"111\",\"createTime\":1713266235000,\"id\":2,\"isDisable\":1,\"oauthName\":\"qq\",\"type\":2,\"updateTime\":1713266235000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 19:17:22','2024-04-16 19:17:22'),(1284,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"测试QQ应用1\",\"clientId\":\"11\",\"clientSecret\":\"111\",\"createTime\":1713266235000,\"id\":2,\"isDisable\":0,\"oauthName\":\"qq\",\"type\":2,\"updateTime\":1713266242000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','','2024-04-16 19:27:13','2024-04-16 19:27:13'),(1285,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"gitee登录\",\"clientId\":\"0ec57074c8cb9a72d306aa0d54d33a5aa086af7cb3b0d0bb026b10bf3a27aca5\",\"clientSecret\":\"79e21c2b3ab41c258d7a67cfe5a32fed99094597da754544ac5c0dca20b0711e\",\"isDisable\":0,\"oauthName\":\"gitee\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 20:45:31','2024-04-16 20:45:31'),(1286,'用户信息模块','修改','/admin/users/disable','cn.icatw.blog.controller.UserInfoController.updateUserDisable','修改用户禁用状态','[{\"id\":9,\"isDisable\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:13:12','2024-04-16 21:13:12'),(1287,'用户信息模块','修改','/admin/users/disable','cn.icatw.blog.controller.UserInfoController.updateUserDisable','修改用户禁用状态','[{\"id\":9,\"isDisable\":0}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:13:32','2024-04-16 21:13:32'),(1288,'用户信息模块','修改','/admin/users/disable','cn.icatw.blog.controller.UserInfoController.updateUserDisable','修改用户禁用状态','[{\"id\":9,\"isDisable\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:14:20','2024-04-16 21:14:20'),(1289,'用户信息模块','修改','/admin/users/disable','cn.icatw.blog.controller.UserInfoController.updateUserDisable','修改用户禁用状态','[{\"id\":9,\"isDisable\":0}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:14:22','2024-04-16 21:14:22'),(1290,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"测试QQ应用1\",\"clientId\":\"11\",\"clientSecret\":\"111\",\"createTime\":1713266235000,\"id\":2,\"isDisable\":1,\"oauthName\":\"qq\",\"type\":2,\"updateTime\":1713266832000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:27:25','2024-04-16 21:27:25'),(1291,'未知','新增或修改','/admin/oauth','cn.icatw.blog.controller.OauthController.saveOrUpdatePage','保存或更新','[{\"appName\":\"github登录\",\"clientId\":\"8310050a2b95902b2360\",\"clientSecret\":\"5aefb667c83e59c3cf4ecc7e7bbd813c0878666e\",\"createTime\":1713266235000,\"isDisable\":0,\"oauthName\":\"github\",\"updateTime\":1713266832000}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-16 21:32:16','2024-04-16 21:32:16'),(1292,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot初始化程序\\n\\n> 今天在做博客项目时遇到了更新浏览量的问题\\n>\\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\\n\\n```java\\npackage cn.icatw.runner;\\n\\nimport cn.icatw.Constants.SystemConstants;\\nimport cn.icatw.domain.entity.Article;\\nimport cn.icatw.mapper.ArticleMapper;\\nimport cn.icatw.utils.RedisCache;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.boot.CommandLineRunner;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * 在项目启动时将文章浏览量存入Redis中\\n *\\n * @author icatw\\n * @date 2022/10/27\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class ViewCountRunner implements CommandLineRunner {\\n    @Resource\\n    ArticleMapper articleMapper;\\n    @Resource\\n    RedisCache redisCache;\\n\\n    @Override\\n    public void run(String... args) throws Exception {\\n        List<Article> articles = articleMapper.selectList(null);\\n        Map<String, Integer> map = articles.stream().collect(\\n                //将文章id和浏览量以map结构存入redis中\\n                Collectors.toMap(article -> article.getId().toString(),\\n                        article -> article.getViewCount().intValue()));\\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\\n        log.info(\\\"===缓存初始化成功===\\\");\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg\",\"articleTitle\":\"SpringBoot初始化程序\",\"categoryName\":\"Java后端\",\"id\":118,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 15:10:11','2024-04-17 15:10:11'),(1293,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"::: hljs-center\\n\\n## 尚医通项目总结\\n\\n:::\\n# 模块说明\\n#### yygh_parent：根目录，管理子模块\\n##### common：公共模块父节点\\n###### common-util：工具类模块，所有模块都可以依赖于它\\n###### rabbit-util：rabbitmq业务封装\\n###### service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它\\n##### hospital-manage：医院接口模拟端\\n##### model：实体类模块\\n##### server-gateway：服务网关\\n##### service：api接口服务父节点\\n###### service-cmn：字典api接口服务\\n###### service-hosp：医院api接口服务\\n###### service-order：订单api接口服务\\n###### service-oss：文件存储api接口服务\\n###### service-sms：短信api接口服务\\n###### service-statistics：统计api接口服务\\n###### service-task：定时任务服务\\n###### service-user：用户api接口服务\\n##### service-client：feign服务调用父节点\\n###### service-cmn-client：字典api接口\\n###### service-hosp-client：医院api接口\\n###### service-order-client：订单api接口\\n###### service-user-client：用户api接口\\n#### sql：项目涉及的sql文件\\n\\n# 1、项目介绍\\n> 尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！\\n# 2、技术点\\n #### 后端:\\n1. SpringBoot：简化新Spring应用的初始搭建以及开发过程\\n2. SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）\\n3. MyBatis-Plus：持久层框架\\n4. Redis：内存缓存（验证码有效时间、支付二维码有效时间）\\n5. MongoDB：面向文档的NoSQL数据库（医院相关数据）\\n6. EasyExcel：操作excel表格，进行行读写操作\\n7. RabbitMQ：消息中间件（订单相关操作）\\n8. HTTPClient: Http协议客户端\\n9. Nginx：负载均衡\\n10. Mysql：关系型数据库\\n11. \\n#### 前端：\\n1. Vue.js：web 界面的渐进式框架\\n2. Node.js： JavaScript 运行环境\\n3. Axios：Axios 是一个基于 promise 的 HTTP 库\\n4. NPM：包管理器\\n5. Babel：转码器\\n6. Webpack：打包工具\\n7. ECharts：图表展示\\n#### 其他:\\n1. Lombok\\n2. Swagger2：Api接口文档工具\\n3. Docker ：容器技术\\n4. Git：代码管理工具\\n5. 阿里云oss\\n6. 阿里云短信服务\\n7. 微信登录、支付\\n8. 定时任务\\n# 3、业务流程\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/75caa1c073503ee6d40dcd83aa256cd9.png)\\n\\n# 4、微服务架构\\n![image.png](http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/c2ec4ed56cdb6682cee214b1390b6258.png)\\n\\n# 5、git地址\\nGitHub：[尚医通GitHub地址](https://github.com/icatw/yygh_icatw)\\ngitee：[尚医通gitee地址](https://gitee.com/icatw/yygh_parent)\\n\\n\\n\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/bddef9e9d0de1bb4b08bd75e5a9b2d95.png\",\"articleTitle\":\"尚医通项目总结\",\"categoryName\":\"项目总结\",\"id\":56,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 15:11:00','2024-04-17 15:11:00'),(1294,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# SpringBoot初始化程序\\n\\n> 今天在做博客项目时遇到了更新浏览量的问题\\n>\\n> 这里使用的方案是：在应用启动时将浏览量以hash结构存入Redis中，在每次访问文章接口时浏览量自增1，并且设置定时任务（每十分钟）同步一次数据库信息\\n\\n```java\\npackage cn.icatw.runner;\\n\\nimport cn.icatw.Constants.SystemConstants;\\nimport cn.icatw.domain.entity.Article;\\nimport cn.icatw.mapper.ArticleMapper;\\nimport cn.icatw.utils.RedisCache;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.boot.CommandLineRunner;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.annotation.Resource;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * 在项目启动时将文章浏览量存入Redis中\\n *\\n * @author icatw\\n * @date 2022/10/27\\n * @email 762188827@qq.com\\n * @apiNote\\n */\\n@Component\\n@Slf4j\\npublic class ViewCountRunner implements CommandLineRunner {\\n    @Resource\\n    ArticleMapper articleMapper;\\n    @Resource\\n    RedisCache redisCache;\\n\\n    @Override\\n    public void run(String... args) throws Exception {\\n        List<Article> articles = articleMapper.selectList(null);\\n        Map<String, Integer> map = articles.stream().collect(\\n                //将文章id和浏览量以map结构存入redis中\\n                Collectors.toMap(article -> article.getId().toString(),\\n                        article -> article.getViewCount().intValue()));\\n        redisCache.setCacheMap(SystemConstants.VIEW_COUNT_KEY, map);\\n        log.info(\\\"===缓存初始化成功===\\\");\\n    }\\n}\\n```\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/456cbe5b8db60665579493247729a821.jpg\",\"articleTitle\":\"SpringBoot初始化程序\",\"categoryName\":\"Java后端\",\"id\":118,\"isTop\":1,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 16:18:08','2024-04-17 16:18:08'),(1295,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[131,130,129,128,127],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 16:18:21','2024-04-17 16:18:21'),(1296,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"# Spring Boot + Vue 壁纸分享平台项目讲解\\n\\n大家好，我很荣幸在这里向大家介绍我们的壁纸分享平台项目。这个项目包括了前台和后台两个部分，为用户提供了丰富的壁纸资源和强大的管理功能。\\n\\n## 1. 项目背景\\n\\n##### 随着互联网的发展，壁纸分享平台在用户生活中扮演着越来越重要的角色。与传统壁纸网站不同，我们的平台不仅提供了丰富多彩的壁纸资源，而且是完全免费的。用户可以自由上传、分享、和下载高质量的壁纸，为用户提供了更广泛的选择空间。 在传统壁纸网站中，用户往往需要支付费用或者受到下载次数的限制，一不小心可能还会跳转到广告页面。而我们的平台通过开放的上传和下载机制，鼓励用户分享和交流优秀的作品。这不仅丰富了平台的壁纸库，也构建了一个更加活跃和友好的社区。\\n\\n## 2. 在线地址\\n\\n- **前台地址：** [www.wallpaper.icatw.top](http://www.wallpaper.icatw.top)\\n- **后台管理系统地址：** [www.admin.wallpaper.icatw.top](http://www.admin.wallpaper.icatw.top)\\n\\n**项目截图**\\n\\n![项目截图1](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003029075.png)\\n\\n![项目截图2](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002930533.png)\\n\\n![项目截图3](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205002945631.png)\\n\\n![项目截图4](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003010907.png)\\n\\n![项目截图5](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003120406.png)\\n\\n![项目截图6](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003134608.png)\\n\\n![项目截图7](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205003145402.png)\\n\\n\\n## 3. 技术栈概览\\n\\n### 后端技术栈：\\n\\n- **Spring Boot：** 强大的后端框架，提供快速开发和部署的能力。\\n- **Spring Security：** 实现了基于RBAC权限模型的动态权限路由系统，确保灵活而安全的权限控制。\\n- **MyBatisPlus：** 数据库操作的优秀框架，简化了数据库交互的流程。\\n- **Swagger3和Knife4j：** 提供了强大的接口管理和文档生成功能，方便团队协作和API调试。\\n- **Redis：** 用于缓存和提高系统性能。\\n- **对象存储：** 支持腾讯云Cos、七牛云Kodo和阿里云Oss对象存储，为用户提供高效的图片存储和访问。\\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\\n- **JWT Token 登录：** 使用JWT实现了无状态的用户认证，增强了系统的安全性。\\n\\n### 代码结构：\\n\\n![代码结构](https://picgo-iamges.oss-cn-hangzhou.aliyuncs.com/img/image-20231205001504507.png)\\n\\n### 前端技术栈：\\n\\n- **Vue.js：** 强大的前端框架，使我们能够构建响应式和高性能的用户界面。\\n- **Vue Router：** 提供了在单页面应用中进行导航的能力，使用户能够方便地切换页面。\\n- **Vuex：** 用于管理应用的状态，实现组件之间的共享数据。\\n- **Element UI、Ant Design Vue：** 提供了一套美观、易用的UI组件，简化了页面的开发过程。\\n- **Axios：** 用于进行HTTP请求，与后端进行数据交互。\\n\\n## 4. 主要功能\\n\\n### 前台用户功能：\\n\\n- **用户认证与授权：** 提供注册和登录功能，确保用户信息的安全性。\\n- **壁纸搜索与分类：** 用户可以轻松找到自己喜欢的壁纸，支持多种分类方式。\\n- **个人信息管理：** 用户可以管理自己的个人信息，包括上传头像等。\\n- **收藏：** 用户可以收藏喜欢的壁纸。\\n- **JWT Token 登录：** 采用JWT Token方式进行用户身份验证，保障用户信息安全。\\n\\n### 后台管理系统功能：\\n\\n- **壁纸管理：**\\n  - 壁纸管理：管理壁纸相关信息，包括增删改查。\\n  - 分类管理：壁纸分类相关信息。\\n- **用户管理：**\\n  - 用户管理：管理用户相关信息，包括增删改查以及重置密码操作。\\n- **权限管理：**\\n  - 角色管理：管理系统角色，分配相应权限。\\n  - 菜单管理：配置系统菜单，实现动态权限路由。\\n- **日志管理：**\\n  - 登陆日志：记录用户登录信息，提高系统安全性。\\n  - 操作日志：记录用户操作信息，便于系统行为追溯。\\n- **系统管理：**\\n  - 系统配置：动态配置存储在数据库中，包括对象存储等。\\n  - 文件存储相关配置：配置文件存储的相关信息。\\n- **系统监控：**\\n  - 实现系统监控功能，包括性能、资源使用情况等。\\n\\n## 5. 创新与亮点\\n\\n- **动态权限路由：** 利用RBAC权限模型和Spring Security及前端Vue-Router实现的动态权限路由系统，确保权限控制的灵活性。\\n- **动态配置：** 使用策略模式和后台管理系统的配置菜单，实现了动态配置，包括对象存储等。\\n- **AOP和注解：** 利用AOP和注解的方式控制权限和记录日志，提高系统的可维护性和可扩展性。\\n- **用户自由度高：** 网站完全免费登录注册，无需积分，不限下载次数，可以自行上传与分享高质量的壁纸。\\n- **JWT Token登录：** 采用JWT Token方式进行用户身份验证，增加了系统的安全性。\\n\\n## 6. 不足及后续计划\\n\\n**项目不足之处：** 由于项目时间紧迫，我们承认某些功能可能没有完全开发完成，其中包括用户上传图片审核功能。此外，系统在使用过程中可能存在一些bug，我们期待老师及同学们能够给予宝贵的意见和建议，以帮助我们不断改进和提升。\\n\\n- **后续计划：** 我们已经在计划中，将在未来的版本中引入一些重要的功能和改进，包括但不限于：\\n  - **JustAuth第三方登录：** 提供更便捷的用户登录体验，增强用户友好性。\\n  - **忘记密码找回功能**：使用阿里云短信服务或者集成邮箱实现手机号/邮箱找回密码功能。\\n  - **用户上传图片审核功能：** 引入审核机制，防止恶意上传图片，提高平台内容质量。\\n  - **反馈功能：** 添加用户反馈功能，促进用户参与，及时发现和解决问题。\\n  - **性能优化和Bug修复：** 不断优化系统性能，修复已知和新发现的bug，提高系统稳定性。\\n\\n## 结语\\n\\n以上便是关于i壁纸的项目介绍，感谢老师们的聆听，目前项目已上线，我们欢迎大家在使用过程中提出建议和需求，共同为平台的持续改进努力。谢谢您的理解与支持！\",\"articleCover\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/articles/2dc722f14293755dad61ba4ef9980332.jpg\",\"articleTitle\":\"Spring Boot + Vue 壁纸分享平台\",\"categoryName\":\"项目总结\",\"id\":121,\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 17:46:51','2024-04-17 17:46:51'),(1297,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"**测试**\",\"articleCover\":\"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvj5sjt88j21hc0u07hp.jpg\",\"articleTitle\":\"2024-04-17\",\"categoryName\":\"项目总结\",\"isTop\":0,\"originalUrl\":\"\",\"status\":1,\"tagNameList\":[],\"type\":1}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-17 23:49:33','2024-04-17 23:49:33'),(1298,'分类模块','新增或修改','/admin/categories','cn.icatw.blog.controller.CategoryController.saveOrUpdateCategory','添加或修改分类','[{\"categoryName\":\"其他\"}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 00:06:22','2024-04-18 00:06:22'),(1299,'文章模块','爬虫','/admin/articles/reptile','cn.icatw.blog.controller.ArticleController.reptile','文章爬虫','[\"https://blog.csdn.net/lance666/article/details/112436679\"]','GET','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 01:38:21','2024-04-18 01:38:21'),(1300,'文章模块','修改','/admin/articles','cn.icatw.blog.controller.ArticleController.updateArticleDelete','恢复或删除文章','[{\"idList\":[133],\"isDelete\":1}]','PUT','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 01:38:51','2024-04-18 01:38:51'),(1301,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"我们知道发送一个http请求时，如果使用的是GET方法，请求的参数会包含在url中并通过\\\\&进行分割，如：http://www.example.com/index?name=name1\\\\&id=id2。服务端根据url中的参数获取对应的值。java编写的后台代码，可通过HttpServletRequest的方法getParameter(\\\"name\\\")获取name的值:name=name1.\\n\\n事实上HttpServletRequest获取参数是对字符串\\\"?name=name1\\\\&id=id2\\\"进行拆分，根据\\\"\\\\&\\\"分割出参数名称，根据\\\"=\\\"分割出参数值。那么问题来了，如果我们的name里面本身就包含有\\\\&或者=，如name=\\\"na\\\\&me=1\\\"，如果发送http请求前不做相应的处理，url就变成了http://www.example.com/index?name=na\\\\&me=1\\\\&id=id2,这个时候后台解析出来的参数就变成了：name=na;me=1;id=id2,这显然不是我们想要的结果。\\n\\n面对这个情况的解决方法是对url中存在歧义的字符串进行URL编码。URL编码就是使用一种安全的字符去表示不安全的或存在歧义的字符，\\\"na\\\\&me=1\\\"经过URL编码后的值为：na%26me%3d1，这个时候我们发送http请求的url改为：http://www.example.com/index?name=na%26me%3d1\\\\&id=id2，服务端进行解码后解析参数便可获得正确的值：name=\\\"na\\\\&me=1\\\"。\\n\\n#### 接收URL参数时当其中有参数值含有#的时候，后面的参数就被截断，收不到值 {#content_views}\\n\\n因为\\\"#\\\"代表url的结束。在请求之前先替换\\\"#\\\"为其他字符例如\\\"$\\\"然后request的时候在替换为原来那个或者进行编码。\\n\\n在url中直接使用一些特殊字符，如果字符为\\\"a-z\\\",\\\"A-Z\\\",\\\"0-9\\\",\\\".\\\",\\\"-\\\",\\\"_\\\",\\\"\\\\*\\\"，则这些字符会直接被服务器识别，维持原值，如果是字符\\\"+\\\",\\\"/\\\",\\\"?\\\",\\\"%\\\",\\\"#\\\",\\\"\\\\&\\\",\\\"=\\\"，则它们将会被转码。那么我们就需要转码来让服务器进行识别。\\n\\n编码js语法： encodeURI(URIstring)\\n\\n解码js语法： decodeURI(URIstring)\\n\\n参考：<https://blog.csdn.net/qq_22855325/article/details/75335030>\\n\\n<https://blog.csdn.net/weixin_34186950/article/details/92316158>\\n\\n[https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\\\\&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control](https://blog.csdn.net/u011324293/article/details/53426549?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)\\n\",\"articleCover\":\"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkf96kuyj31hc0u04kb.jpg\",\"articleTitle\":\"URL中带特殊字符导致传值丢失的处理方式\",\"categoryName\":\"其他\",\"id\":137,\"isTop\":0,\"originalUrl\":\"https://blog.csdn.net/lance666/article/details/112436679\",\"status\":1,\"tagNameList\":[],\"type\":2}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 01:45:17','2024-04-18 01:45:17'),(1302,'文章模块','爬虫','/admin/articles/reptile','cn.icatw.blog.controller.ArticleController.reptile','文章爬虫','[\"https://blog.csdn.net/xiaoxianer321/article/details/119548202\"]','GET','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 01:46:33','2024-04-18 01:46:33'),(1303,'文章模块','新增或修改','/admin/articles','cn.icatw.blog.controller.ArticleController.saveOrUpdateArticle','添加或修改文章','[{\"articleContent\":\"vuepress使用简介 {#content_views}\\n-----------------------------\\n\\n1、vuepress概述\\n------------\\n\\nvuepress 是 Vuejs 官方提供的一个是Vue驱动的静态网站生成器，基于Markdown语法生成网页。简单的说它就是一个快速建设文档站点的工具，在简单配置好功能后，需要做的事情就剩下写好一个个 Markdown 文档，并且可以将其发布到github。\\n\\nvuepress官网：[VuePress](https://vuepress.vuejs.org/zh/ \\\"VuePress\\\")，对[vuepress](https://vuepress.vuejs.org/zh/ \\\"vuepress\\\")的描述比较详细。\\n\\n声明：原创文章未经允许，不得转载！！！\\n\\n2、vuepress简介\\n------------\\n\\n### 2.1、vuepress搭建\\n\\n1）**新建一个工程目录为mjxWebBlog**\\n\\n新建一个mjxWebBlog文件夹，并导入到Visual Studio Code中\\n\\n![](https://img-blog.csdnimg.cn/20210809223150627.png)\\n\\n2）**安装本地依赖**\\n\\n```bash\\nyarn add -D vuepress # npm install -D vuepress\\n```\\n\\n![](https://img-blog.csdnimg.cn/20210809232348868.png)\\n\\n注：官方不再推荐全局安装 npm install -g vuepress\\n\\n扩展：yarn和npm等都是用于构建和打包 javascript 代码的工具。npm 出现之前**，** 前端依赖项是保存到存储库中并手动下载的，而如今，大量依赖项存储在神奇的 `node_modules` 内的嵌套文件夹中，Yarn 是为了弥补 npm 的一些缺陷而出现的，为了防止拉取到不同的版本，Yarn 有一个锁定文件 (yarn.lock) 记录了被确切安装上的模块的版本号，后来npm也做了一些类似的改进新增了类似yarn.lock的 package-lock.json。\\n\\n**3）初始化项目**\\n\\n将会创建一个package.json文件\\n\\n```bash\\nyarn init -y # npm init -y (-y免去确认)\\n```\\n\\nnpm init -y后生成package.json文件\\n\\n```bash\\n{\\n  \\\"name\\\": \\\"y\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"index.js\\\",\\n  \\\"dependencies\\\": {\\n    \\\"vuepress\\\": \\\"^1.8.2\\\"\\n  },\\n  \\\"devDependencies\\\": {},\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\n  },\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"ISC\\\"\\n}\\n```\\n\\n**4）创建你的第一篇文档**\\n\\n```bash\\nmkdir docs \\n\\necho \'# Hello VuePress\' > docs/README.md\\n```\\n\\n**5）在 package.json 中添加一些 scripts**\\n\\n```bash\\n{\\n  \\\"scripts\\\": {\\n    \\\"docs:dev\\\": \\\"vuepress dev docs\\\",\\n    \\\"docs:build\\\": \\\"vuepress build docs\\\"\\n  }\\n}\\n```\\n\\n注：启动脚本docs:dev 键值可以自定义修改，此处是为了和一些项目中默认脚本中自带的 dev 区分开，都是等效于执行vuepress dev doc，根据你目录中的.vuepress配置项和docs下的所有.md/.html文件做一个项目的编译和打包。\\n\\n6）在本地启动服务器\\n\\n```bash\\nyarn docs:dev # npm run docs:dev\\n```\\n\\n启动之后（如果乱码，则改下README.md的编码），效果如下：\\n\\n![](https://img-blog.csdnimg.cn/20210809233648100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n### 2.2、vuepress目录结构说明\\n\\nVuePress 遵循 **\\\"约定优于配置\\\"** 的原则，推荐的目录结构如下：\\n\\n```XML\\n.\\n├── docs\\n│   ├── .vuepress (可选的)\\n│   │   ├── components (可选的)\\n│   │   ├── theme (可选的)\\n│   │   │   └── Layout.vue\\n│   │   ├── public (可选的)\\n│   │   ├── styles (可选的)\\n│   │   │   ├── index.styl\\n│   │   │   └── palette.styl\\n│   │   ├── templates (可选的, 谨慎配置)\\n│   │   │   ├── dev.html\\n│   │   │   └── ssr.html\\n│   │   ├── config.js (可选的)\\n│   │   └── enhanceApp.js (可选的)\\n│   │ \\n│   ├── README.md\\n│   ├── guide (一般用户都在这个目录下创建网站指南,当然可以不用)\\n│   │   └── README.md （指南里面的具体内容）\\n│   └── config.md\\n│ \\n└── package.json 项目初始化时，根目录下自动生成的配置文件,定义了项目的基本配置信息及需要依赖的各个模块、指定运行脚本命令的npm命令行缩写等。\\n\\n```\\n\\n* `docs/.vuepress`: 用于存放全局的配置、组件、静态资源等。\\n* `docs/.vuepress/components`: 该目录中的 Vue 组件将会被自动注册为全局组件。\\n* `docs/.vuepress/theme`: 用于存放本地主题。\\n* `docs/.vuepress/styles`: 用于存放样式相关的文件。\\n* `docs/.vuepress/styles/index.styl`: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。\\n* `docs/.vuepress/styles/palette.styl`: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\\n* `docs/.vuepress/public`: 静态资源目录。\\n* `docs/.vuepress/templates`: 存储 HTML 模板文件。\\n* `docs/.vuepress/templates/dev.html`: 用于开发环境的 HTML 模板文件。\\n* `docs/.vuepress/templates/ssr.html`: 构建时基于 Vue SSR 的 HTML 模板文件。\\n* `docs/.vuepress/config.js`: 配置文件的入口文件，也可以是 `YML` 或 `toml`。\\n* `docs/.vuepress/enhanceApp.js`: 客户端应用的增强。\\n\\n### 2.3、MarkDown语法简介\\n\\n为了后续更好的学习，我们需要先了解一下MarkDown相关语法。\\n\\nMarkDown是一种轻量级标记语言，使用易读易写的纯文本格式编写文档。2004年由约翰·格鲁伯创建。使用MarkDown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。MarkDown编写的文档，后缀名为.md或.markdown。\\n\\n对于MarkDown的编写，我们可以下载Typora软件玩一下，当然也可以直接在Visual Studio Code中写或者使用在线工具：[在线markdown编辑器_微信公众号markdown排版工具](https://markdown.com.cn/editor/ \\\"在线markdown编辑器_微信公众号markdown排版工具\\\")\\n\\n#### 2.3.1、注释语法\\n\\n```html\\n### 1.1、代码法\\n    <div style=\'display:none\'>\\n        哈哈哈哈，看不到我的我隐藏的很深\\n    </div>\\n### 1.2、html注释语法\\n    <!--哈哈哈哈，我是注释，不会在浏览器中显示-->\\n### 1.3、markdown注释语法\\n    [//]: # (注释，不会在浏览器中显示)\\n    [^_^]: # (我是注释)\\n    [//]: <> (我是注释)\\n    [comment]: <> (我是注释)\\n```\\n\\n将这段代码放到我们的项目中运行，效果如下：\\n\\n![](https://img-blog.csdnimg.cn/20210810214854386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 2.3.2、标题\\n\\nMarkdown 支持两种形式的标题：\\n\\n1）使用的等号来表示一级标题, 使用连字符表示二级标题（只支持两级）\\n\\n2）每行开头使用 1-6 井号, 对应 1-6 级标题\\n\\n```cs\\n# 我是一级标题\\n## 我是二级标题\\n### 我是三级标题\\n#### 我是四级标题\\n##### 我是五级标题\\n###### 我是六级标题\\n\\nThis is an H1\\n===\\n我是二级标题\\n---\\n```\\n\\n案例效果：\\n\\n![](https://img-blog.csdnimg.cn/2021081022401272.gif)\\n\\n#### 2.3.3、目录\\n\\n根据标题生成目录，语法：\\\\[TOC\\\\]\\n\\n![](https://img-blog.csdnimg.cn/20210810224705534.gif)\\n\\n#### 2.3.4、块引用\\n\\nMarkdown 使用 email 样式的 `>` 字符作为块引用（最好对引用文本采取强制换行并在每一行行首放一个 `>`）\\n\\n1）单行引用\\n\\n2）多行引用\\n\\n3）嵌套引用\\n\\n![](https://img-blog.csdnimg.cn/20210810225859594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 2.3.5、列表\\n\\nMarkdown 支持有序列表和无序列表\\n\\n1）有序列表：序列`.`后 保持空格\\n\\n2）无序列表：无序列表使用星号, 加号, 和连字符 -- 这些符号是可互换。\\n\\n![](https://img-blog.csdnimg.cn/20210810231656138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 2.3.6、代码块\\n\\n预格式化的代码块用于输出编程语言和标记语言。要在 Markdown 中插入代码块：\\n\\n方式一： 只需要将每一行都缩进 4 个空格或者 1 个水平制表符；\\n\\n方式二：使用\\\\`\\\\`\\\\` 或者 \\\\`\\\\`\\\\`javascript指定语言配置。\\n\\n![](https://img-blog.csdnimg.cn/20210810234921483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 2.3.7、表格\\n\\nmarkdown中的表格，只能是中规中矩的表格，一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的。**`:`** 代表对齐方式。\\n\\n```bash\\n|    a    |       b       |      c     |\\n|:-------:|:------------- | ----------:|\\n|   居中  |     左对齐    |   右对齐   |\\n|=========|===============|============|\\n```\\n\\n案例效果：\\n\\n![](https://img-blog.csdnimg.cn/20210810235614312.gif)\\n\\n#### 2.3.8、水平线（分割线）\\n\\n如果一行中只有三个以上的连字符, 星号, 或者下划线则会在该位置生成一个 `<hr />` 标签。\\n\\n![](https://img-blog.csdnimg.cn/20210811000852760.png)\\n\\n注：多个---使用时前一行不能写内容，会变成二级标题\\n\\n#### 2.3.9、链接\\n\\nMarkdown 支持两种链接形式: *内联* 和 *引用。*这两种形式下链接文本的定界符都是 \\\\[中括号\\\\]。\\n\\n![](https://img-blog.csdnimg.cn/20210811004409504.png)\\n\\n#### 2.3.10、强调（粗体、斜体、删除线）\\n\\nMarkdown 将星号 (`*`) 和下划线 (`_`) 作为强调标记。 用 `*` 或者 `_` 包裹的文本将会用 HTML `<em>` 标签包裹; 双 `*` 或者 `_` 将会用 HTML `<strong>` 标签包裹.。\\n\\n```bash\\n普通文字*斜体文字*普通文字\\n\\n普通文字**粗体文字**普通文字\\n\\n普通文字~~删除文字~~普通文字\\n```\\n\\n效果：![](https://img-blog.csdnimg.cn/20210811005328201.png)\\n\\n#### 2.3.11、代码\\n\\n要输出一个代码片段, 需要使用重音符号 (`````). 不同于预格式的代码块, 代码片段只是在普通段落中标识出代码.。\\n\\n![](https://img-blog.csdnimg.cn/20210811005711582.png)\\n\\n#### 2.3.12、图片\\n\\nMarkdown 使用了类似链接的语法来插入图片, 包含两种形式: *内联* 和 *引用。*\\n\\n![](https://img-blog.csdnimg.cn/20210811012549814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 2.3.13、自动链接\\n\\nMarkdown 支持一种 \\\"自动\\\" 创建 URL 和 email 地址链接的简短形式: 只需用尖括号包围 URL 或 email 地址即可。\\n\\n![](https://img-blog.csdnimg.cn/20210811012811631.png)\\n\\n#### 2.3.14、反斜杠转义\\n\\nMarkdown 中可以使用反斜杠转义 Markdown 语法符号为字面量。Markdown 为下面字符提供反斜杠转义:\\n\\n```java\\n\\\\   backslash\\n`   backtick\\n*   asterisk\\n_   underscore\\n{}  curly braces\\n[]  square brackets\\n()  parentheses\\n#   hash mark\\n+   plus sign\\n-   minus sign (hyphen)\\n.   dot\\n!   exclamation mark\\n```\\n\\n#### 2.3.15、复选框\\n\\n使用- \\\\[ \\\\]标识复选框，x表示默认选中。\\n\\n```bash\\n- [ ] 没选中的复选框\\n- [x] 选中复选框\\n```\\n\\n效果：![](https://img-blog.csdnimg.cn/20210811013714193.png)\\n\\n#### 2.3.16、语义标签\\n\\n|  描述  |                                               效果                                                |        代码         |\\n|------|-------------------------------------------------------------------------------------------------|-------------------|\\n| 斜体   | \\\\<i\\\\>斜体\\\\</i\\\\>                                                                                   | `<i>斜体</i>`       |\\n| 加粗   | \\\\<b\\\\>加粗\\\\</b\\\\>                                                                                   | `<b>加粗</b>`       |\\n| 强调   | \\\\<em\\\\>强调\\\\</em\\\\>                                                                                 | `<em>强调</em>`     |\\n| 上标   | Za                                                                                              | `Z<sup>a</sup>`   |\\n| 下标   | Za                                                                                              | `Z<sub>a</sub>`   |\\n| 键盘文本 | <br /> ![](https://img-blog.csdnimg.cn/img_convert/fc63d48e41e03e240f6b1d7290b54fdb.png) <br /> | `<kbd>Ctrl</kbd>` |\\n\\n3、默认主题设置\\n--------\\n\\n我们看到的首页，是通过配置根路径下的README.md文件实现的、而一些，导航栏、侧边栏，则是通过配置docs/config.js实现。\\n\\n### 3.1、首页\\n\\n1）创建`public目录存放`静态资源`和`config.js配置文件\\n\\n在.vuepress中创建 public 文件夹和config.js 文件，形成如下结构。这也是最简单的目录格式。\\n\\n```XML\\nmjxWebBlog\\n├─── docs\\n│   ├── README.md\\n│   └── .vuepress\\n│       ├── public\\n│       └── config.js\\n└── package.json\\n```\\n\\n2）官网给默认的主题提供了一个首页（Homepage）的布局。\\n\\n将docs目录下的README.md中的内容替换，并在public目录下放置一张图片,再次启动。\\n\\n**注：根路径默认的README.md，会被编译成index.html文件。**\\n\\n```java\\n---\\nhome: true\\nheroImage: /logo.jpg\\nactionText: 快速上手 →\\nactionLink: /zh/guide/\\nfeatures:\\n- title: 简洁至上\\n  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\\n- title: Vue驱动\\n  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。\\n- title: 高性能\\n  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。\\nfooter: MIT Licensed | Copyright © 2018-present Evan You\\n---\\n```\\n\\n图片：![](https://img-blog.csdnimg.cn/20210810002022515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n效果如下：![](https://img-blog.csdnimg.cn/20210810002202508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n再添加一些基本配置：修改docs/config.js文件\\n\\n```javascript\\nmodule.exports = {\\n  // 网站的一些基本配置\\n  // base:配置部署站点的基础路径，后续再介绍\\n  title: \'穆瑾轩\', // 网站的标题\\n  description: \'穆瑾轩测试网页\', // 网站的描述，它将会以 <meta> 标签渲染到当前页面的 HTML 中。\\n  head: [\\n    [\'link\', { rel: \'icon\', href: \'/logo.png\' }] // 需要被注入到当前页面的 HTML <head> 中的标签\\n  ],\\n}\\n```\\n\\n案例效果：![](https://img-blog.csdnimg.cn/20210813015811593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n### 3.2、导航栏\\n\\n我们可以看到页面的最上面默认有一个导航栏和搜索框。关于导航栏我们可以设置：页面标题、搜索框、 导航栏Logo/链接、多语言切换、仓库链接等。\\n\\n#### 3.2.1、**导航栏 Logo**\\n\\n你可以通过 `themeConfig.logo` 增加导航栏 Logo。\\n\\n```javascript\\n//修改 .vuepress/config.js\\n\\nmodule.exports = {\\n  themeConfig: {\\n    logo: \'/dh_logo.jpg\',\\n  }\\n}\\n```\\n\\n案例效果：![](https://img-blog.csdnimg.cn/20210811232634676.png)\\n\\n#### 3.2.2、**导航栏链接**\\n\\n可以通过 `themeConfig.nav` 增加一些导航栏链接。\\n\\n```javascript\\n// 配置导航栏logo(themeConfig.logo)\\nmodule.exports = {\\n  themeConfig: {\\n    logo: \'/dh_logo.jpg\',\\n    nav: [\\n      { text: \'Home\', link: \'/\' },\\n      // 可指定链接跳转模式：默认target: \'_blank\'新窗口打开，_self当前窗口打开\\n      { text: \'百度\', link: \'https://www.baidu.com\' },\\n      { text: \'CSDN\', link: \'https://blog.csdn.net\', target: \'_blank\' },\\n      { text: \'豆瓣\', link: \'https://movie.douban.com\', target: \'_self\', rel: \'\' },\\n      // 支持嵌套,形成下拉式的导航菜单\\n      {\\n        text: \'语言\',\\n        ariaLabel: \'Language Menu\',\\n        items: [\\n          { text: \'中文\', link: \'/language/chinese/\' },\\n          { text: \'英文\', link: \'/language/english/\' }\\n        ]\\n      }\\n    ],\\n  }\\n}\\n```\\n\\n案例效果：![](https://img-blog.csdnimg.cn/20210811235923329.gif)\\n\\n如果还想继续嵌套,则可以这样继续往下嵌套：{ text: \'中文\', items: \\\\[{ text: \'语文\', link: \'/language/chinese/\'\' }\\\\] }\\n\\n当然也不是所有的页面都需要导航栏的， 所以vuepress使用下面这个配置禁用导航栏，禁用后页面就不会出现导航栏。\\n\\n```javascript\\n// .vuepress/config.js\\nmodule.exports = {\\n  themeConfig: {\\n    navbar: false\\n  }\\n}\\n```\\n\\n### 3.3、侧边栏\\n\\n想要使侧边栏（sidebar）生效，需要配置 `themeConfig.sidebar`。`sidebar`可以分为全局设置以及局部设置。\\n\\n如果配置单页的侧边栏，只需要使用**sidebar: \'auto\'属性即可帮我们完成自动补充侧边栏。**\\n\\n#### **需要一个或多个侧边栏，可以使用数组实现侧边栏分组，也可以使用对象的形式来配置**。\\n\\n![](https://img-blog.csdnimg.cn/20210817222905258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### **3.3.1、单页侧边栏设置方式一**\\n\\n**在`.vuepress/config.js`中配置属性：sidebar: \'auto\'**\\n\\n第一步：建立如下目录结构及文件，/blog/fontend/README.md等文件内容这里就不展示了\\n\\n![](https://img-blog.csdnimg.cn/20210816233042783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n详细解析：vuepress的文件寻址，**不同类型的文件都已经预设好不同的默认路径**。\\n\\n1）图标/图片等**静态资源**相关的，第一个 \'/\' 默认指向的是 docs/.vuepress/public/\\n\\n2）侧边栏/导航栏链接的markdown文件，**第一个 \'/\' 默认指向的是 docs/**，我们这里是都放置在docs/xxx里，所以通常把目录建在docs下\\n\\n3）嵌入在markdown中使用的Vue组件，放置在docs/.vuepress/components目录中\\n\\n注：为此我们的路径最好是按规范来放置文件。找不到对应的文件，则会跳出404。\\n\\n第二步：修改**`.vuepress/config.js中的配置如下`**\\n\\n```javascript\\n// 配置导航栏logo(themeConfig.logo)\\n// 配置导航栏logo(themeConfig.logo)\\nmodule.exports = {\\n  // 网站的一些基本配置\\n  // base:配置部署站点的基础路径，后续再介绍\\n  title: \'穆瑾轩\', // 网站的标题\\n  description: \'穆瑾轩测试网页\', // 网站的描述，它将会以 <meta> 标签渲染到当前页面的 HTML 中。\\n  head: [\\n    [\'link\', { rel: \'icon\', href: \'/logo.jpg\' }] // 需要被注入到当前页面的 HTML <head> 中的标签\\n  ],\\n  // host port在本地运行就不配置了\\n  themeConfig: {\\n    logo: \'/dh_logo.jpg\',\\n    nav: [\\n      // 直接跳转，\'/\'为不添加路由，跳转至首页，以/结尾的最终对应的都是/index.html,也就是README.md文件编译后的页面\\n      { text: \'Home\', link: \'/\' },\\n      // 对应blog/fontend/README.md\\n      { text: \'前端\', link: \'/blog/fontend/\' },\\n      { text: \'后端\', link: \'/blog/backend/\' },\\n      // 对应/guide/guide.md\\n      { text: \'导航\', link: \'/guide/guide\' },\\n      // 不指定深度，默认深度1-提取h2 最大深度-2，同一标题下最多提取到h3，想要改变深度可以指定sidebarDepth\\n    ],\\n    // 禁用导航栏\\n    // navbar: false,\\n    // 设置自动生成侧边栏\\n    sidebar: \'auto\',\\n  }\\n}\\n```\\n\\n第三步：重启后效果如下\\n\\n案例效果：![](https://img-blog.csdnimg.cn/20210812021847129.gif)\\n\\n#### **3.3.2、单页侧边栏设置方式二**\\n\\n在md文件的顶部写上下面代码：\\n\\n```TypeScript\\n# 自动补充侧边栏\\n---\\nsidebar: auto\\n---\\n\\n# 禁用侧边栏\\n---\\nsidebar: false\\n---\\n```\\n\\n步骤一：注释或删除**`.vuepress/config.js中`**sidebar: \'auto\'属性，并且在guide.md中加入上诉代码：\\n\\n![](https://img-blog.csdnimg.cn/20210817000337700.png)\\n\\n步骤二： 重启后再效果如下，只有加了上诉配置的才出现了导航栏\\n\\n![](https://img-blog.csdnimg.cn/20210817000735715.gif)\\n\\n#### **3.3.3、**设置侧边栏标题显示的层数\\n\\n官网上提到了这样一个属性：sidebarDepth，可以通过在配置文件中配置`themeConfig.sidebarDepth`来设置嵌套层级。默认情况下，侧边栏会自动显示当前页面的标题(h2\\\\~h3)组成的链接，所以上面的案例中我们看到都是h2和h3可以被点击。\\n\\nsidebarDepth可设置的值：\\n\\n| 值 |              说明               |\\n|---|-------------------------------|\\n| 0 | 禁用标题（headers）链接               |\\n| 1 | 默认值,只显示`h2`的标题                |\\n| 2 | 可设置的最大值，再大无效, 同时提取`h2`和`h3`标题 |\\n\\n***注：如果设置了` sidebar: \'auto\' `,侧边栏会显示`h2`和`h3`标题，此时sidebarDepth的值只有0是生效的(仅显示`h2`的标题)，这里需要注意一下。***\\n\\n第一步：`.vuepress/config.js中加入sidebarDepth: 0属性`\\n\\n```TypeScript\\n...\\nsidebar: \'auto\',\\n// 设置深度，使用了sidebar: \'auto\'的话只有设置0才会生效，否则默认2\\nsidebarDepth: 0,\\n...\\n```\\n\\n第二步：重启后效果如下\\n\\n![](https://img-blog.csdnimg.cn/20210817001920488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n#### 3.3.4、显示一个/多个侧边栏 {#item-7-3}\\n\\n前面呢，我们使用属性***`sidebar: \'auto\' `*** ，会自动生成单页侧边栏，单页如果我们想要将一个模块集成在一个页面呢？我们可以为***`sidebar指定一个对象属性。`***\\n\\n语法格式：***sidebar{目录_key:\\\\[子链接1,子链接2...\\\\]}***\\n\\n***第一步：声明一个对象，对象的链接为：*** ***目录/blog/fontend/***\\n\\n```javascript\\n...\\nthemeConfig: {\\n    logo: \'/dh_logo.jpg\',\\n    nav: [\\n      // 直接跳转，\'/\'为不添加路由，跳转至首页，以/结尾的最终对应的都是/index.html,也就是README.md文件编译后的页面\\n      { text: \'Home\', link: \'/\' },\\n      // 对应blog/fontend/README.md\\n      { text: \'前端\', link: \'/blog/fontend/\' },\\n      { text: \'后端\', link: \'/blog/backend/\' },\\n      // 对应/guide/guide.md\\n      { text: \'导航\', link: \'/guide/guide\' },\\n    ],\\n    // sidebar: \'auto\',\\n    sidebar: {\\n      //对象的默认路径\\n      \'/blog/fontend/\': [\\n        \'\', //侧边栏第一个页面是：/blog/fontend/README.md,、链接文字自动获取(页面的第一个header)，即h1(前端技术)\\n        \'myhtml\',  //侧边栏第二个页面是：/blog/fontend/myhtml.md,链接文字自动获取(页面的第一个header)，即h2(html 二级标题)\\n        [\'myJavascript\', \'js自定义的标题\'] //侧边栏第三个页面是：/blog/fontend/myJavascript.md ,指定链接的文字，使用一个格式为 [link, text] 的数组。\\n      ]\\n    },\\n    sidebarDepth: 2,\\n...\\n```\\n\\n第二步：重启后效果如下：\\n\\n![](https://img-blog.csdnimg.cn/20210817012108737.gif)\\n\\n备注说明：\\n\\nsidebar: { \'/blog/fontend/\': \\\\[数组中只定义字符串（文件路径），则侧边栏页面的链接文字是当前页面中的第一个header)\\\\]}\\n\\nsidebar: { \'/blog/fontend/\': \\\\[数组中嵌套数组，数组的第一个参数为文件路径，而第二个参数为侧边栏页面的链接文字\\\\]}\\n\\n当然也可以在.md文件中指定名字，作为自定义标题\\n\\n```javascript\\n---\\ntitle: 自定义标题\\n---\\n```\\n\\n#### 3.3.5、侧边栏分组\\n\\n当然还可以使用分组的形式去实现。\\n\\n语法格式： ![](https://img-blog.csdnimg.cn/20210817233036316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n分组：侧边栏的每个子组默认是可折叠的，你可以设置 collapsable: false 来让一个组永远都是展开状态。\\n\\n第一步：添加如下代码\\n\\n```javascript\\n...\\nsidebar: [\\n      {\\n        title: \'分组1 前端\',\\n        collapsable: false,\\n        children: [\\n          \'/blog/fontend/myhtml\',\\n          [\'/blog/fontend/myJavascript\', \'js自定义的标题\']\\n        ],\\n      },\\n      {\\n        title: \'分组2 后端\',\\n        collapsable: true,\\n        children: [\\n          \'/blog/backend/myjava\',\\n        ]\\n      }\\n    ],\\nsidebarDepth: 2,\\n...\\n```\\n\\n第二步：重启后效果如下：\\n\\n![](https://img-blog.csdnimg.cn/20210817022329415.gif)\\n\\n### 3.4、其他配置\\n\\n#### 3.4.1、搜索框\\n\\n**3.4.1.1、内置搜索**\\n\\n内置搜索只会为页面的标题、h2 、 h3 以及 tags 构建搜索索引。 如果你需要全文搜索，你可以使用 Algolia 搜索。官网提供给我们的内置搜索配置项如下：\\n\\n```javascript\\n// .vuepress/config.js\\nmodule.exports = {\\n  themeConfig: {\\n    search: false, // 设置是否使用导航栏上的搜索框\\n    searchMaxSuggestions: 10  // 搜索框显示的搜索结果数量\\n  }\\n}\\n```\\n\\n1）search: false 禁用内置搜索框。false为禁用，默认为true\\n\\n![](https://img-blog.csdnimg.cn/20210817235407967.png)\\n\\n2）searchMaxSuggestions: 10，调整默认搜索框显示的搜索结果数量，最大为10\\n\\n![](https://img-blog.csdnimg.cn/20210817235609359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n**3.4.1.2、Algolia 搜索**\\n\\n第三方免费搜索服务 algolia需要注册，访问[Algolia DocSearch](https://community.algolia.com/docsearch/ \\\"Algolia DocSearch\\\")来设置。\\n\\n#### 3.4.2、更新时间\\n\\n```javascript\\n// .vuepress/config.js\\nmodule.exports = {\\n  themeConfig: {\\n    lastUpdated: \'Last Updated\', // string | boolean\\n  }\\n}\\n```\\n\\n由于 `lastUpdated` 是基于 `git` 的, 所以你只能在一个基于 `git` 的项目中启用它。在本地将文件提交到本地仓库也可以看到`lastUpdated`。\\n\\n![](https://img-blog.csdnimg.cn/2021081801482110.png)\\n\\n后面的内容呢，在项目实践中边做边学\\n\\n4、个人博客搭建实战\\n----------\\n\\n### 4.1、建一个博客的模板\\n\\n网上有很多优秀的开源博客页面，我们就直接安装好，再继续开发。我这里找到的是[vuepress-theme-reco](https://vuepress-theme-reco.recoluan.com/ \\\"vuepress-theme-reco\\\")这个博客模板。\\n\\n#### 4.1.1、在本地安装博客模板\\n\\n```bash\\n# init\\nnpm install @vuepress-reco/theme-cli -g\\ntheme-cli init mjxWebBlog\\n\\n# install\\ncd mjxWebBlog\\nnpm install\\n\\n# run\\nnpm run dev\\n\\n# build\\nnpm run build\\n```\\n\\n注：如果出现禁止执行远程脚本的错误：可以执行：Set-ExecutionPolicy -Scope CurrentUse\\n\\n安装步骤一：\\n\\n![](https://img-blog.csdnimg.cn/20210818025224682.png)\\n\\n安装步骤二：\\n\\n![](https://img-blog.csdnimg.cn/20210818031102465.png)\\n\\n有三个风格的主题：\\n\\n![](https://img-blog.csdnimg.cn/20210818025924830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n安装步骤三：执行npm install，安装依赖包node_modules\\n\\n![](https://img-blog.csdnimg.cn/20210818030259840.png)\\n\\n步骤四：启动npm run dev\\n\\nblog主题：\\n\\n![](https://img-blog.csdnimg.cn/20210818030549498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n我选择第三个模板：afternoon-grocery主题：\\n\\n![](https://img-blog.csdnimg.cn/20210818031648216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n步骤五：继续开发：\\n\\n我的博客开发到这种进度时：\\n\\n![](https://img-blog.csdnimg.cn/20210820011027892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n步骤六：我在gitHub上创建一个名为：[mjxol.github.io](https://github.com/mjxol/mjxol.github.io \\\"mjxol.github.io\\\")的仓库\\n\\n![](https://img-blog.csdnimg.cn/2021082001123286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n步骤七：在博客地址中运行npm run build,静态文件都在public目录下生成了\\n\\n![](https://img-blog.csdnimg.cn/20210820011307636.png)\\n\\n步骤八：将文件推送至远程仓库，并合并到远程仓库的main分支\\n\\n![](https://img-blog.csdnimg.cn/20210820020059972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n最终：我们的文件都上传到github上了\\n\\n![](https://img-blog.csdnimg.cn/2021082002021090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\\n### 4.2、我的博客基础版\\n\\n我的个人博客基础版访问地址：[穆瑾轩的博客](https://mjxol.github.io/ \\\"穆瑾轩的博客\\\")\\n\\n页面展示：\\n\\n![](https://img-blog.csdnimg.cn/20210820021400165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWFuZXIzMjE=,size_16,color_FFFFFF,t_70)\\n\",\"articleCover\":\"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxk3yu6vwj31kw0w04k5.jpg\",\"articleTitle\":\"vuepress使用简介及个人博客搭建\",\"categoryName\":\"其他\",\"id\":138,\"isTop\":0,\"originalUrl\":\"https://blog.csdn.net/xiaoxianer321/article/details/119548202\",\"status\":1,\"tagNameList\":[],\"type\":2}]','POST','{\"code\":200,\"flag\":true,\"message\":\"操作成功\"}',1,'icatw','127.0.0.1','未知','2024-04-18 01:47:20','2024-04-18 01:47:20');
/*!40000 ALTER TABLE `tb_operation_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_page`
--

DROP TABLE IF EXISTS `tb_page`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_page` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '页面id',
  `page_name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面名',
  `page_label` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '页面标签',
  `page_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '页面封面',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=905 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC COMMENT='页面';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_page`
--

LOCK TABLES `tb_page` WRITE;
/*!40000 ALTER TABLE `tb_page` DISABLE KEYS */;
INSERT INTO `tb_page` VALUES (1,'首页','home','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/c36646b6effe06ccfe2727f1603ec692.jpg','2021-08-07 10:32:36','2022-02-28 23:23:02'),(2,'归档','archive','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/db7779cffcdac02828fa7dedd6833d1c.jpg','2021-08-07 10:32:36','2022-02-28 23:23:28'),(3,'分类','category','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/2904b329e08607f13e50d22582c9716d.jpg','2021-08-07 10:32:36','2022-02-28 23:23:40'),(4,'标签','tag','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/458219609a7e9f5579d8ba87c7d65d5c.jpg','2021-08-07 10:32:36','2022-02-28 23:23:58'),(5,'相册','album','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/93fecbb5ce7e9f907d1895ce2914d1e2.jpg','2021-08-07 10:32:36','2022-02-28 23:24:11'),(6,'友链','link','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/02e0b77f5d157dff5bc7b912fa173113.jpg','2021-08-07 10:32:36','2022-02-28 23:24:24'),(7,'关于','about','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/df9c1307704f20ebaf55d7a0ffffe126.jpg','2021-08-07 10:32:36','2022-02-28 23:24:38'),(8,'留言','message','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/88b67fe99351c59bca1635e02bbc1683.jpg','2021-08-07 10:32:36','2022-02-28 23:25:15'),(9,'个人中心','user','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/eff6141712fb3af80d00595a19d9d5e0.jpg','2021-08-07 10:32:36','2022-02-28 23:25:36'),(10,'文章列表','articleList','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/d8afa7b4d72f0765e8a1cae491582411.jpg','2021-08-10 15:36:19','2022-02-28 23:25:48'),(904,'说说','talk','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/b6ca16c4768b3e963997131f64e49b63.jpg','2022-01-23 00:51:24','2022-02-28 23:28:57');
/*!40000 ALTER TABLE `tb_page` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_photo`
--

DROP TABLE IF EXISTS `tb_photo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_photo` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '照片描述',
  `photo_src` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片地址',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC COMMENT='照片';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_photo`
--

LOCK TABLES `tb_photo` WRITE;
/*!40000 ALTER TABLE `tb_photo` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_photo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_photo_album`
--

DROP TABLE IF EXISTS `tb_photo_album`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_photo_album` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否删除',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态值 1公开 2私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC COMMENT='相册';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_photo_album`
--

LOCK TABLES `tb_photo_album` WRITE;
/*!40000 ALTER TABLE `tb_photo_album` DISABLE KEYS */;
INSERT INTO `tb_photo_album` VALUES (11,'我的大学','记录大学生活~','http://icatw-blog.oss-cn-beijing.aliyuncs.com/photos/b6ca16c4768b3e963997131f64e49b63.jpg',0,1,'2022-03-06 01:22:25',NULL);
/*!40000 ALTER TABLE `tb_photo_album` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_resource`
--

DROP TABLE IF EXISTS `tb_resource`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_resource` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '请求方式',
  `parent_id` int DEFAULT NULL COMMENT '父权限id',
  `is_anonymous` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否匿名访问 0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=508 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_resource`
--

LOCK TABLES `tb_resource` WRITE;
/*!40000 ALTER TABLE `tb_resource` DISABLE KEYS */;
INSERT INTO `tb_resource` VALUES (382,'留言模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(383,'页面模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(384,'用户信息模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(385,'博客信息模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(386,'用户账号认证模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(387,'分类模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(388,'资源模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(389,'角色模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(390,'相册模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(391,'登录模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(392,'文章模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(393,'标签模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(394,'菜单模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(395,'日志模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(396,'友链模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(397,'说说模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(398,'评论模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(399,'照片模块',NULL,NULL,NULL,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(400,'修改密码','/users/password','PUT',386,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(401,'更新用户信息','/users/info','PUT',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(402,'获取网站配置','/admin/website/config','GET',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(403,'更新网站配置','/admin/website/config','PUT',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(404,'查询用户角色选项','/admin/users/role','GET',389,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(405,'后台修改用户角色和昵称','/admin/users/role','PUT',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(406,'修改管理员密码','/admin/users/password','PUT',386,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(407,'修改用户禁用状态','/admin/users/disable','PUT',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(408,'根据相册id获取照片列表','/admin/photos','GET',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(409,'更新照片信息','/admin/photos','PUT',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(410,'保存照片','/admin/photos','POST',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(411,'删除照片','/admin/photos','DELETE',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(412,'更新照片删除状态','/admin/photos/delete','PUT',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(413,'移动照片相册','/admin/photos/album','PUT',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(414,'审核留言','/admin/messages/review','PUT',382,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(415,'审核评论','/admin/comments/review','PUT',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(416,'查看后台文章','/admin/articles','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(417,'恢复或删除文章','/admin/articles','PUT',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(418,'添加或修改文章','/admin/articles','POST',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(419,'物理删除文章','/admin/articles','DELETE',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(420,'修改文章置顶','/admin/articles/top','PUT',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(421,'修改关于我信息','/admin/about','PUT',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(422,'保存访问信息','/visit','POST',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(423,'绑定用户邮箱','/users/email','POST',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(424,'更新用户头像','/users/avatar','POST',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(425,'点赞说说','/talks/*/like','POST',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(426,'用户注册','/register','POST',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(427,'用户登录','/login','POST',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(428,'查询当前页面的评论','/comments','GET',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(429,'添加评论','/comments','POST',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(430,'评论点赞','/comments/*/like','POST',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(431,'点赞文章','/articles/*/like','POST',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(432,'查看后台说说','/admin/talks','GET',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(433,'保存或修改说说','/admin/talks','POST',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(434,'删除说说','/admin/talks','DELETE',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(435,'上传说说图片','/admin/talks/images','POST',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(436,'查询后台标签列表','/admin/tags','GET',393,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(437,'添加或修改标签','/admin/tags','POST',393,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(438,'删除标签','/admin/tags','DELETE',393,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(439,'保存或更新角色','/admin/role','POST',389,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(440,'查看资源列表','/admin/resources','GET',388,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(441,'新增或修改资源','/admin/resources','POST',388,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(442,'查看后台相册列表','/admin/photos/albums','GET',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(443,'保存或更新相册','/admin/photos/albums','POST',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(444,'上传相册封面','/admin/photos/albums/cover','POST',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(445,'获取页面列表','/admin/pages','GET',383,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(446,'保存或更新页面','/admin/pages','POST',383,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(447,'查看菜单列表','/admin/menus','GET',394,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(448,'新增或修改菜单','/admin/menus','POST',394,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(449,'查看后台友链列表','/admin/links','GET',396,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(450,'保存或修改友链','/admin/links','POST',396,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(451,'删除友链','/admin/links','DELETE',396,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(452,'上传博客配置图片','/admin/config/images','POST',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(453,'查看后台分类列表','/admin/categories','GET',387,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(454,'添加或修改分类','/admin/categories','POST',387,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(455,'删除分类','/admin/categories','DELETE',387,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(456,'上传文章图片','/admin/articles/images','POST',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(457,'发送邮箱验证码','/users/code','GET',386,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(458,'查看说说列表','/talks','GET',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(459,'根据id查看说说','/talks/*','GET',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(460,'查询标签列表','/tags','GET',393,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(461,'获取相册列表','/photos/albums','GET',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(462,'查看友链列表','/links','GET',396,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(463,'查看首页说说','/home/talks','GET',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(464,'查询评论下的回复','/comments/*/replies','GET',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(465,'查看分类列表','/categories','GET',387,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(466,'查看首页文章','/articles','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(467,'根据id查看文章','/articles/*','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(468,'搜索文章','/articles/search','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(469,'根据条件查询文章','/articles/condition','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(470,'查看文章归档','/articles/archives','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(471,'根据相册id查看照片列表','/albums/*/photos','GET',399,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(472,'查询后台用户列表','/admin/users','GET',386,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(473,'查看在线用户','/admin/users/online','GET',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(474,'获取用户区域分布','/admin/users/area','GET',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(475,'用户菜单列表','/admin/user/menus','GET',394,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(476,'根据id查看后台说说','/admin/talks/*','GET',397,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(477,'标签列表（搜索用）','/admin/tags/search','GET',393,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(478,'查询角色列表','/admin/roles','GET',389,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(479,'删除角色','/admin/roles','DELETE',389,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(480,'查看角色资源选项','/admin/role/resources','GET',388,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(481,'查看角色菜单选项','/admin/role/menus','GET',394,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(482,'导入swagger接口','/admin/resources/import/swagger','GET',388,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(483,'根据id获取后台相册信息','/admin/photos/albums/*/info','GET',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(484,'获取后台相册列表信息','/admin/photos/albums/info','GET',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(485,'查看操作日志','/admin/operation/logs','GET',395,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(486,'删除操作日志','/admin/operation/logs','DELETE',395,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(487,'查看后台留言列表','/admin/messages','GET',382,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(488,'删除留言','/admin/messages','DELETE',382,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(489,'查询后台评论','/admin/comments','GET',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(490,'删除评论','/admin/comments','DELETE',398,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(491,'分类列表（搜索用）','/admin/categories/search','GET',387,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(492,'获取博客后台信息','/admin/backHomeInfo','GET',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(493,'根据id查看后台文章','/admin/articles/*','GET',392,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(494,'查看关于我信息','/about','GET',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(495,'查看博客信息','/','GET',385,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(496,'下线用户','/admin/users/*/online','DELETE',384,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(497,'删除资源','/admin/resources/*','DELETE',388,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(498,'根据id删除相册','/admin/photos/albums/*','DELETE',390,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(499,'删除页面','/admin/pages/*','DELETE',383,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(500,'删除菜单','/admin/menus/*','DELETE',394,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(501,'注销登录','/logout','GET',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(502,'注销登录','/logout','PUT',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(503,'注销登录','/logout','POST',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(504,'注销登录','/logout','DELETE',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(505,'注销登录','/logout','OPTIONS',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(506,'注销登录','/logout','HEAD',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06'),(507,'注销登录','/logout','PATCH',391,0,'2024-04-09 11:00:06','2024-04-09 11:00:06');
/*!40000 ALTER TABLE `tb_resource` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名',
  `role_label` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色描述',
  `is_disable` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否禁用  0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'管理员','admin',0,'2021-03-22 14:10:21','2024-04-16 15:54:44'),(2,'用户','user',0,'2021-03-22 14:25:25','2022-01-24 01:32:21'),(3,'测试','test',0,'2021-03-22 14:42:23','2022-01-24 01:32:59'),(15,'测试用户','test',0,'2024-04-10 10:06:37','2024-04-11 19:34:55');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_role_menu`
--

DROP TABLE IF EXISTS `tb_role_menu`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role_menu` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int DEFAULT NULL COMMENT '角色id',
  `menu_id` int DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2604 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role_menu`
--

LOCK TABLES `tb_role_menu` WRITE;
/*!40000 ALTER TABLE `tb_role_menu` DISABLE KEYS */;
INSERT INTO `tb_role_menu` VALUES (1397,8,1),(1398,8,2),(1399,8,6),(1400,8,7),(1401,8,8),(1402,8,9),(1403,8,10),(1404,8,3),(1405,8,11),(1406,8,12),(1407,8,202),(1408,8,13),(1409,8,14),(1410,8,201),(1411,8,4),(1412,8,16),(1413,8,15),(1414,8,17),(1415,8,18),(1416,8,19),(1417,8,20),(1418,8,5),(1595,9,1),(1596,9,2),(1597,9,6),(1598,9,7),(1599,9,8),(1600,9,9),(1601,9,10),(1602,9,3),(1603,9,11),(1604,9,12),(1605,9,202),(1606,9,13),(1607,9,14),(1608,9,201),(1609,9,4),(1610,9,16),(1611,9,15),(1612,9,17),(1613,9,18),(1614,9,19),(1615,9,20),(1616,9,5),(1639,13,2),(1640,13,6),(1641,13,7),(1642,13,8),(1643,13,9),(1644,13,10),(1645,13,3),(1646,13,11),(1647,13,12),(2366,14,1),(2367,14,2),(2494,3,1),(2495,3,2),(2496,3,6),(2497,3,7),(2498,3,8),(2499,3,9),(2500,3,10),(2501,3,3),(2502,3,11),(2503,3,12),(2504,3,202),(2505,3,13),(2506,3,201),(2507,3,213),(2508,3,14),(2509,3,15),(2510,3,16),(2511,3,4),(2512,3,214),(2513,3,209),(2514,3,17),(2515,3,18),(2516,3,205),(2517,3,206),(2518,3,208),(2519,3,210),(2520,3,215),(2521,3,216),(2522,3,217),(2523,3,218),(2524,3,19),(2525,3,20),(2526,3,5),(2529,15,1),(2530,15,2),(2531,15,6),(2532,15,7),(2533,15,8),(2534,15,9),(2535,15,10),(2548,1,201),(2549,1,213),(2550,1,14),(2551,1,15),(2552,1,1),(2553,1,16),(2554,1,4),(2555,1,214),(2556,1,2),(2557,1,219),(2558,1,209),(2559,1,17),(2560,1,6),(2561,1,18),(2562,1,205),(2563,1,206),(2564,1,208),(2565,1,7),(2566,1,210),(2567,1,215),(2568,1,216),(2569,1,217),(2570,1,8),(2571,1,218),(2572,1,19),(2573,1,20),(2574,1,5),(2575,1,9),(2576,1,10),(2577,1,3),(2578,1,11),(2579,1,12),(2580,1,202),(2581,1,13),(2582,1,201),(2583,1,213),(2584,1,14),(2585,1,15),(2586,1,16),(2587,1,4),(2588,1,214),(2589,1,219),(2590,1,209),(2591,1,17),(2592,1,18),(2593,1,205),(2594,1,206),(2595,1,208),(2596,1,210),(2597,1,215),(2598,1,216),(2599,1,217),(2600,1,218),(2601,1,19),(2602,1,20),(2603,1,5);
/*!40000 ALTER TABLE `tb_role_menu` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_role_resource`
--

DROP TABLE IF EXISTS `tb_role_resource`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role_resource` (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int DEFAULT NULL COMMENT '角色id',
  `resource_id` int DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4890 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role_resource`
--

LOCK TABLES `tb_role_resource` WRITE;
/*!40000 ALTER TABLE `tb_role_resource` DISABLE KEYS */;
INSERT INTO `tb_role_resource` VALUES (4886,15,447),(4887,15,448),(4888,15,475),(4889,15,481);
/*!40000 ALTER TABLE `tb_role_resource` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_social_user`
--

DROP TABLE IF EXISTS `tb_social_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_social_user` (
  `id` varchar(64) NOT NULL COMMENT '主键uuid',
  `uuid` varchar(64) NOT NULL COMMENT '第三方uuid',
  `source` tinyint NOT NULL COMMENT '第三方来源(1:qq,2:gitee,3:github)',
  `access_token` varchar(64) DEFAULT NULL COMMENT '用户授权令牌',
  PRIMARY KEY (`id`),
  UNIQUE KEY `tb_social_user_pk_2` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='社会化用户表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_social_user`
--

LOCK TABLES `tb_social_user` WRITE;
/*!40000 ALTER TABLE `tb_social_user` DISABLE KEYS */;
INSERT INTO `tb_social_user` VALUES ('beee080b2433d69766a7aeda409c228d','10142330',4,NULL),('cec7848820c57ff994707f1799e11052','99238504',5,NULL);
/*!40000 ALTER TABLE `tb_social_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_social_user_auth`
--

DROP TABLE IF EXISTS `tb_social_user_auth`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_social_user_auth` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `user_id` int NOT NULL COMMENT '用户表id',
  `social_user_id` varchar(64) NOT NULL COMMENT '三方用户表id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='三方登录-用户关联表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_social_user_auth`
--

LOCK TABLES `tb_social_user_auth` WRITE;
/*!40000 ALTER TABLE `tb_social_user_auth` DISABLE KEYS */;
INSERT INTO `tb_social_user_auth` VALUES (5,9,'beee080b2433d69766a7aeda409c228d'),(6,10,'cec7848820c57ff994707f1799e11052');
/*!40000 ALTER TABLE `tb_social_user_auth` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_tag`
--

DROP TABLE IF EXISTS `tb_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '逻辑删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=58 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_tag`
--

LOCK TABLES `tb_tag` WRITE;
/*!40000 ALTER TABLE `tb_tag` DISABLE KEYS */;
INSERT INTO `tb_tag` VALUES (30,'项目总结','2022-02-20 21:29:03','2022-05-23 22:57:32',0),(33,'springboot','2022-03-06 00:49:33',NULL,0),(34,'多线程','2022-03-28 03:10:47',NULL,0),(35,'java基础','2022-03-31 02:13:43',NULL,0),(36,'面经八股文','2022-03-31 02:13:43',NULL,0),(37,'算法','2022-04-17 02:44:29',NULL,0),(38,'vue','2022-04-27 13:16:55',NULL,0),(39,'其他技术','2022-05-22 20:14:15',NULL,0),(40,'docker','2022-05-23 22:48:35',NULL,0),(41,'mysql','2022-05-23 22:48:35',NULL,0),(42,'mybatis','2022-05-28 15:21:36',NULL,0),(43,'springmvc','2022-06-09 00:19:07',NULL,0),(44,'Redis','2022-06-12 11:53:44',NULL,0),(45,'Java','2024-01-29 11:34:33',NULL,0),(46,'设计模式','2024-01-29 15:46:28',NULL,0),(47,'测试','2024-03-27 15:32:39','2024-03-27 15:32:39',0),(48,'网站开发','2024-04-18 01:15:55','2024-04-18 01:15:55',0),(49,'字符串','2024-04-18 01:15:55','2024-04-18 01:15:55',0),(50,'url','2024-04-18 01:15:55','2024-04-18 01:15:55',0),(51,'js','2024-04-18 01:15:55','2024-04-18 01:15:55',0),(52,'# vue学习板块','2024-04-18 01:46:33','2024-04-18 01:46:33',0),(53,'原创未经允许不得转载','2024-04-18 01:46:33','2024-04-18 01:46:33',0),(54,'我的前端学习板块','2024-04-18 01:46:33','2024-04-18 01:46:33',0),(55,'javascript','2024-04-18 01:46:33','2024-04-18 01:46:33',0),(56,'前端','2024-04-18 01:46:33','2024-04-18 01:46:33',0),(57,'vue.js','2024-04-18 01:46:33','2024-04-18 01:46:33',0);
/*!40000 ALTER TABLE `tb_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_talk`
--

DROP TABLE IF EXISTS `tb_talk`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_talk` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '说说id',
  `user_id` int NOT NULL COMMENT '用户id',
  `content` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '说说内容',
  `images` varchar(2500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '图片',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否置顶',
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '状态 1.公开 2.私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_talk`
--

LOCK TABLES `tb_talk` WRITE;
/*!40000 ALTER TABLE `tb_talk` DISABLE KEYS */;
INSERT INTO `tb_talk` VALUES (49,1,'新年快乐！<img src=\"http://www.static.icatw.top/emoji/tiaopi.jpg\" width=\"24\" height=\"24\" alt=\"[调皮]\" style=\"margin: 0 1px;vertical-align: text-bottom\">',NULL,0,1,'2022-01-24 23:34:59','2022-03-06 01:22:47'),(50,1,'唯一的人生课题就是找到自己','[\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/talks/dde3c71e642f112140ce6ec3797bbf27.jpg\"]',1,1,'2022-03-06 01:24:34',NULL),(51,1,'测试',NULL,0,1,'2024-04-07 10:13:26','2024-04-07 10:13:26');
/*!40000 ALTER TABLE `tb_talk` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_unique_view`
--

DROP TABLE IF EXISTS `tb_unique_view`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_unique_view` (
  `id` int NOT NULL AUTO_INCREMENT,
  `create_time` datetime NOT NULL COMMENT '时间',
  `views_count` int NOT NULL COMMENT '访问量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=997 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_unique_view`
--

LOCK TABLES `tb_unique_view` WRITE;
/*!40000 ALTER TABLE `tb_unique_view` DISABLE KEYS */;
INSERT INTO `tb_unique_view` VALUES (535,'2022-02-18 00:00:00',14),(536,'2022-02-19 00:00:00',0),(537,'2022-02-20 00:00:00',3),(538,'2022-02-21 00:00:00',1),(539,'2022-02-22 00:00:00',5),(540,'2022-02-23 00:00:00',9),(541,'2022-02-24 00:00:00',10),(542,'2022-02-25 00:00:00',0),(543,'2022-02-26 00:00:00',7),(544,'2022-02-27 00:00:00',31),(545,'2022-02-28 00:00:00',2),(546,'2022-03-01 00:00:00',28),(547,'2022-03-02 00:00:00',15),(548,'2022-03-03 00:00:00',0),(549,'2022-03-04 00:00:00',6),(550,'2022-03-05 00:00:00',3),(551,'2022-03-06 00:00:00',12),(552,'2022-03-07 00:00:00',4),(553,'2022-03-08 00:00:00',4),(554,'2022-03-09 00:00:00',0),(555,'2022-03-10 00:00:00',1),(556,'2022-03-11 00:00:00',3),(557,'2022-03-12 00:00:00',0),(558,'2022-03-13 00:00:00',3),(559,'2022-03-14 00:00:00',3),(560,'2022-03-15 00:00:00',8),(561,'2022-03-16 00:00:00',3),(562,'2022-03-17 00:00:00',2),(563,'2022-03-18 00:00:00',2),(564,'2022-03-19 00:00:00',0),(565,'2022-03-20 00:00:00',0),(566,'2022-03-21 00:00:00',3),(567,'2022-03-22 00:00:00',3),(568,'2022-03-23 00:00:00',2),(569,'2022-03-24 00:00:00',2),(570,'2022-03-25 00:00:00',6),(571,'2022-03-26 00:00:00',1),(572,'2022-03-27 00:00:00',0),(573,'2022-03-28 00:00:00',5),(574,'2022-03-29 00:00:00',5),(575,'2022-03-30 00:00:00',2),(576,'2022-03-31 00:00:00',1),(577,'2022-04-01 00:00:00',3),(578,'2022-04-02 00:00:00',0),(579,'2022-04-03 00:00:00',0),(580,'2022-04-04 00:00:00',1),(581,'2022-04-05 00:00:00',22),(582,'2022-04-06 00:00:00',1),(583,'2022-04-07 00:00:00',0),(584,'2022-04-08 00:00:00',2),(585,'2022-04-09 00:00:00',0),(586,'2022-04-10 00:00:00',33),(587,'2022-04-11 00:00:00',2),(588,'2022-04-12 00:00:00',2),(589,'2022-04-13 00:00:00',21),(590,'2022-04-14 00:00:00',5),(591,'2022-04-15 00:00:00',11),(592,'2022-04-16 00:00:00',13),(593,'2022-04-17 00:00:00',8),(594,'2022-04-18 00:00:00',6),(595,'2022-04-19 00:00:00',9),(596,'2022-04-20 00:00:00',12),(597,'2022-04-21 00:00:00',2),(598,'2022-04-22 00:00:00',10),(599,'2022-04-23 00:00:00',6),(600,'2022-04-24 00:00:00',4),(601,'2022-04-25 00:00:00',8),(602,'2022-04-26 00:00:00',0),(603,'2022-04-27 00:00:00',10),(604,'2022-04-28 00:00:00',1),(605,'2022-04-29 00:00:00',7),(606,'2022-04-30 00:00:00',1),(607,'2022-05-01 00:00:00',2),(608,'2022-05-02 00:00:00',4),(609,'2022-05-03 00:00:00',1),(610,'2022-05-04 00:00:00',5),(611,'2022-05-05 00:00:00',2),(612,'2022-05-06 00:00:00',6),(613,'2022-05-07 00:00:00',13),(614,'2022-05-08 00:00:00',4),(615,'2022-05-09 00:00:00',5),(616,'2022-05-10 00:00:00',3),(617,'2022-05-11 00:00:00',8),(618,'2022-05-12 00:00:00',11),(619,'2022-05-13 00:00:00',12),(620,'2022-05-14 00:00:00',8),(621,'2022-05-15 00:00:00',1),(622,'2022-05-16 00:00:00',10),(623,'2022-05-17 00:00:00',3),(624,'2022-05-18 00:00:00',3),(625,'2022-05-19 00:00:00',1),(626,'2022-05-20 00:00:00',16),(627,'2022-05-21 00:00:00',4),(628,'2022-05-22 00:00:00',5),(629,'2022-05-23 00:00:00',12),(630,'2022-05-24 00:00:00',10),(631,'2022-05-25 00:00:00',6),(632,'2022-05-26 00:00:00',25),(633,'2022-05-27 00:00:00',2),(634,'2022-05-28 00:00:00',6),(635,'2022-05-29 00:00:00',2),(636,'2022-05-30 00:00:00',18),(637,'2022-05-31 00:00:00',3),(638,'2022-06-01 00:00:00',0),(639,'2022-06-02 00:00:00',1),(640,'2022-06-03 00:00:00',0),(641,'2022-06-04 00:00:00',8),(642,'2022-06-05 00:00:00',0),(643,'2022-06-06 00:00:00',2),(644,'2022-06-07 00:00:00',9),(645,'2022-06-08 00:00:00',4),(646,'2022-06-09 00:00:00',8),(647,'2022-06-10 00:00:00',4),(648,'2022-06-11 00:00:00',4),(649,'2022-06-12 00:00:00',4),(650,'2022-06-13 00:00:00',9),(651,'2022-06-14 00:00:00',5),(652,'2022-06-15 00:00:00',3),(653,'2022-06-16 00:00:00',1),(654,'2022-06-17 00:00:00',2),(655,'2022-06-18 00:00:00',2),(656,'2022-06-19 00:00:00',2),(657,'2022-06-20 00:00:00',4),(658,'2022-06-21 00:00:00',3),(659,'2022-06-22 00:00:00',2),(660,'2022-06-23 00:00:00',3),(661,'2022-06-24 00:00:00',4),(662,'2022-06-25 00:00:00',4),(663,'2022-06-26 00:00:00',2),(664,'2022-06-27 00:00:00',5),(665,'2022-06-28 00:00:00',6),(666,'2022-06-29 00:00:00',4),(667,'2022-06-30 00:00:00',7),(668,'2022-07-01 00:00:00',3),(669,'2022-07-02 00:00:00',9),(670,'2022-07-03 00:00:00',1),(671,'2022-07-04 00:00:00',1),(672,'2022-07-05 00:00:00',2),(673,'2022-07-06 00:00:00',5),(674,'2022-07-07 00:00:00',5),(675,'2022-07-08 00:00:00',2),(676,'2022-07-09 00:00:00',1),(677,'2022-07-10 00:00:00',28),(678,'2022-07-11 00:00:00',2),(679,'2022-07-12 00:00:00',2),(680,'2022-07-13 00:00:00',2),(681,'2022-07-14 00:00:00',2),(682,'2022-07-15 00:00:00',5),(683,'2022-07-16 00:00:00',2),(684,'2022-07-17 00:00:00',2),(685,'2022-07-18 00:00:00',2),(686,'2022-07-19 00:00:00',1),(687,'2022-07-20 00:00:00',3),(688,'2022-07-21 00:00:00',5),(689,'2022-07-22 00:00:00',7),(690,'2022-07-23 00:00:00',1),(691,'2022-07-24 00:00:00',2),(692,'2022-07-25 00:00:00',4),(693,'2022-07-26 00:00:00',1),(694,'2022-07-27 00:00:00',1),(695,'2022-07-28 00:00:00',3),(696,'2022-07-29 00:00:00',3),(697,'2022-07-30 00:00:00',3),(698,'2022-07-31 00:00:00',4),(699,'2022-08-01 00:00:00',8),(700,'2022-08-02 00:00:00',5),(701,'2022-08-03 00:00:00',6),(702,'2022-08-04 00:00:00',9),(703,'2022-08-05 00:00:00',7),(704,'2022-08-06 00:00:00',4),(705,'2022-08-07 00:00:00',55),(706,'2022-08-08 00:00:00',4),(707,'2022-08-09 00:00:00',8),(708,'2022-08-10 00:00:00',5),(709,'2022-08-11 00:00:00',10),(710,'2022-08-12 00:00:00',3),(711,'2022-08-13 00:00:00',4),(712,'2022-08-14 00:00:00',4),(713,'2022-08-15 00:00:00',4),(714,'2022-08-16 00:00:00',4),(715,'2022-08-17 00:00:00',6),(716,'2022-08-18 00:00:00',6),(717,'2022-08-19 00:00:00',4),(718,'2022-08-20 00:00:00',4),(719,'2022-08-21 00:00:00',5),(720,'2022-08-22 00:00:00',4),(721,'2022-08-23 00:00:00',3),(722,'2022-08-24 00:00:00',3),(723,'2022-08-25 00:00:00',6),(724,'2022-08-26 00:00:00',1),(725,'2022-08-27 00:00:00',5),(726,'2022-08-28 00:00:00',5),(727,'2022-08-29 00:00:00',6),(728,'2022-08-30 00:00:00',3),(729,'2022-08-31 00:00:00',2),(730,'2022-09-01 00:00:00',1),(731,'2022-09-02 00:00:00',8),(732,'2022-09-03 00:00:00',4),(733,'2022-09-04 00:00:00',4),(734,'2022-09-05 00:00:00',2),(735,'2022-09-06 00:00:00',6),(736,'2022-09-07 00:00:00',7),(737,'2022-09-08 00:00:00',4),(738,'2022-09-09 00:00:00',10),(739,'2022-09-10 00:00:00',4),(740,'2022-09-11 00:00:00',4),(741,'2022-09-12 00:00:00',6),(742,'2022-09-13 00:00:00',6),(743,'2022-09-14 00:00:00',2),(744,'2022-09-15 00:00:00',8),(745,'2022-09-16 00:00:00',7),(746,'2022-09-17 00:00:00',12),(747,'2022-09-18 00:00:00',15),(748,'2022-09-19 00:00:00',8),(749,'2022-09-20 00:00:00',15),(750,'2022-09-21 00:00:00',12),(751,'2022-09-22 00:00:00',13),(752,'2022-09-23 00:00:00',9),(753,'2022-09-24 00:00:00',18),(754,'2022-09-25 00:00:00',9),(755,'2022-09-26 00:00:00',16),(756,'2022-09-27 00:00:00',13),(757,'2022-09-28 00:00:00',5),(758,'2022-09-29 00:00:00',4),(759,'2022-09-30 00:00:00',4),(760,'2022-10-01 00:00:00',10),(761,'2022-10-02 00:00:00',9),(762,'2022-10-03 00:00:00',5),(763,'2022-10-04 00:00:00',10),(764,'2022-10-05 00:00:00',7),(765,'2022-10-06 00:00:00',5),(766,'2022-10-07 00:00:00',6),(767,'2022-10-08 00:00:00',5),(768,'2022-10-09 00:00:00',7),(769,'2022-10-10 00:00:00',9),(770,'2022-10-11 00:00:00',7),(771,'2022-10-12 00:00:00',5),(772,'2022-10-13 00:00:00',3),(773,'2022-10-14 00:00:00',5),(774,'2022-10-15 00:00:00',9),(775,'2022-10-16 00:00:00',4),(776,'2022-10-17 00:00:00',13),(777,'2022-10-18 00:00:00',5),(778,'2022-10-19 00:00:00',3),(779,'2022-10-20 00:00:00',1),(780,'2022-10-21 00:00:00',5),(781,'2022-10-22 00:00:00',2),(782,'2022-10-23 00:00:00',3),(783,'2022-10-24 00:00:00',8),(784,'2022-10-25 00:00:00',8),(785,'2022-10-26 00:00:00',4),(786,'2022-10-27 00:00:00',2),(787,'2022-10-28 00:00:00',1),(788,'2022-10-29 00:00:00',2),(789,'2022-10-30 00:00:00',4),(790,'2022-10-31 00:00:00',5),(791,'2022-11-01 00:00:00',8),(792,'2022-11-02 00:00:00',0),(793,'2022-11-03 00:00:00',3),(794,'2022-11-04 00:00:00',3),(795,'2022-11-05 00:00:00',7),(796,'2022-11-06 00:00:00',1),(797,'2022-11-07 00:00:00',6),(798,'2022-11-08 00:00:00',3),(799,'2022-11-09 00:00:00',2),(800,'2022-11-10 00:00:00',2),(801,'2022-11-11 00:00:00',8),(802,'2022-11-12 00:00:00',11),(803,'2022-11-13 00:00:00',3),(804,'2022-11-14 00:00:00',4),(805,'2022-11-15 00:00:00',5),(806,'2022-11-16 00:00:00',2),(807,'2022-11-17 00:00:00',6),(808,'2022-11-18 00:00:00',3),(809,'2022-11-19 00:00:00',1),(810,'2022-11-20 00:00:00',5),(811,'2022-11-21 00:00:00',3),(812,'2022-11-22 00:00:00',1),(813,'2022-11-23 00:00:00',6),(814,'2022-11-24 00:00:00',3),(815,'2022-11-25 00:00:00',13),(816,'2022-11-26 00:00:00',4),(817,'2022-11-27 00:00:00',16),(818,'2022-11-28 00:00:00',7),(819,'2022-11-29 00:00:00',2),(820,'2022-11-30 00:00:00',10),(821,'2022-12-01 00:00:00',7),(822,'2022-12-02 00:00:00',6),(823,'2022-12-03 00:00:00',6),(824,'2022-12-04 00:00:00',6),(825,'2022-12-05 00:00:00',6),(826,'2022-12-06 00:00:00',6),(827,'2022-12-07 00:00:00',5),(828,'2022-12-08 00:00:00',7),(829,'2022-12-09 00:00:00',8),(830,'2022-12-10 00:00:00',7),(831,'2022-12-11 00:00:00',7),(832,'2022-12-12 00:00:00',5),(833,'2022-12-13 00:00:00',10),(834,'2022-12-14 00:00:00',3),(835,'2022-12-15 00:00:00',4),(836,'2022-12-16 00:00:00',4),(837,'2022-12-17 00:00:00',4),(838,'2022-12-18 00:00:00',7),(839,'2022-12-19 00:00:00',6),(840,'2022-12-20 00:00:00',4),(841,'2022-12-21 00:00:00',9),(842,'2022-12-22 00:00:00',11),(843,'2022-12-23 00:00:00',4),(844,'2022-12-24 00:00:00',5),(845,'2022-12-25 00:00:00',9),(846,'2022-12-26 00:00:00',8),(847,'2022-12-27 00:00:00',9),(848,'2022-12-28 00:00:00',5),(849,'2022-12-29 00:00:00',5),(850,'2022-12-30 00:00:00',10),(851,'2022-12-31 00:00:00',9),(852,'2023-01-01 00:00:00',6),(853,'2023-01-02 00:00:00',7),(854,'2023-01-03 00:00:00',6),(855,'2023-01-04 00:00:00',5),(856,'2023-01-05 00:00:00',8),(857,'2023-01-06 00:00:00',11),(858,'2023-01-07 00:00:00',4),(859,'2023-01-08 00:00:00',2),(860,'2023-01-09 00:00:00',7),(861,'2023-01-10 00:00:00',14),(862,'2023-01-11 00:00:00',8),(863,'2023-01-12 00:00:00',3),(864,'2023-01-13 00:00:00',5),(865,'2023-01-14 00:00:00',8),(866,'2023-01-15 00:00:00',3),(867,'2023-11-10 00:00:00',5),(868,'2023-11-11 00:00:00',2),(869,'2023-11-12 00:00:00',9),(870,'2023-11-13 00:00:00',6),(871,'2023-11-14 00:00:00',3),(872,'2023-11-15 00:00:00',1),(873,'2023-11-16 00:00:00',4),(874,'2023-11-17 00:00:00',7),(875,'2023-11-18 00:00:00',5),(876,'2023-11-19 00:00:00',10),(877,'2023-11-20 00:00:00',8),(878,'2023-11-21 00:00:00',6),(879,'2023-11-22 00:00:00',7),(880,'2023-11-23 00:00:00',1),(881,'2023-11-24 00:00:00',4),(882,'2023-11-25 00:00:00',5),(883,'2023-11-26 00:00:00',7),(884,'2023-11-27 00:00:00',16),(885,'2023-11-28 00:00:00',5),(886,'2023-11-29 00:00:00',6),(887,'2023-11-30 00:00:00',3),(888,'2023-12-01 00:00:00',13),(889,'2023-12-02 00:00:00',12),(890,'2023-12-03 00:00:00',5),(891,'2023-12-04 00:00:00',7),(892,'2023-12-05 00:00:00',5),(893,'2023-12-06 00:00:00',3),(894,'2023-12-07 00:00:00',6),(895,'2023-12-08 00:00:00',5),(896,'2023-12-09 00:00:00',6),(897,'2023-12-10 00:00:00',6),(898,'2023-12-11 00:00:00',3),(899,'2023-12-12 00:00:00',3),(900,'2023-12-13 00:00:00',6),(901,'2023-12-14 00:00:00',6),(902,'2023-12-15 00:00:00',3),(903,'2023-12-16 00:00:00',9),(904,'2023-12-17 00:00:00',8),(905,'2023-12-18 00:00:00',11),(906,'2023-12-19 00:00:00',12),(907,'2023-12-20 00:00:00',10),(908,'2023-12-21 00:00:00',11),(909,'2023-12-25 00:00:00',2),(910,'2023-12-26 00:00:00',6),(911,'2023-12-27 00:00:00',150),(912,'2023-12-28 00:00:00',14),(913,'2023-12-29 00:00:00',22),(914,'2023-12-30 00:00:00',9),(915,'2023-12-31 00:00:00',2),(916,'2024-01-01 00:00:00',3),(917,'2024-01-02 00:00:00',6),(918,'2024-01-03 00:00:00',5),(919,'2024-01-04 00:00:00',3),(920,'2024-01-05 00:00:00',8),(921,'2024-01-06 00:00:00',9),(922,'2024-01-07 00:00:00',8),(923,'2024-01-08 00:00:00',6),(924,'2024-01-09 00:00:00',4),(925,'2024-01-10 00:00:00',5),(926,'2024-01-11 00:00:00',6),(927,'2024-01-12 00:00:00',7),(928,'2024-01-13 00:00:00',2),(929,'2024-01-14 00:00:00',12),(930,'2024-01-15 00:00:00',9),(931,'2024-01-16 00:00:00',5),(932,'2024-01-17 00:00:00',5),(933,'2024-01-18 00:00:00',9),(934,'2024-01-19 00:00:00',8),(935,'2024-01-20 00:00:00',6),(936,'2024-01-21 00:00:00',4),(937,'2024-01-22 00:00:00',4),(938,'2024-01-23 00:00:00',7),(939,'2024-01-24 00:00:00',5),(940,'2024-01-25 00:00:00',2),(941,'2024-01-26 00:00:00',5),(942,'2024-01-27 00:00:00',7),(943,'2024-01-28 00:00:00',8),(944,'2024-01-29 00:00:00',9),(945,'2024-01-30 00:00:00',4),(946,'2024-01-31 00:00:00',11),(947,'2024-02-01 00:00:00',3),(948,'2024-02-02 00:00:00',10),(949,'2024-02-03 00:00:00',7),(950,'2024-02-04 00:00:00',7),(951,'2024-02-05 00:00:00',4),(952,'2024-02-06 00:00:00',2),(953,'2024-02-07 00:00:00',7),(954,'2024-02-08 00:00:00',4),(955,'2024-02-09 00:00:00',2),(956,'2024-02-10 00:00:00',4),(957,'2024-02-11 00:00:00',7),(958,'2024-02-12 00:00:00',5),(959,'2024-02-13 00:00:00',3),(960,'2024-02-14 00:00:00',1),(961,'2024-02-15 00:00:00',7),(962,'2024-02-16 00:00:00',3),(963,'2024-02-17 00:00:00',7),(964,'2024-02-18 00:00:00',5),(965,'2024-02-19 00:00:00',7),(966,'2024-02-20 00:00:00',4),(967,'2024-02-21 00:00:00',2),(968,'2024-02-22 00:00:00',5),(969,'2024-02-23 00:00:00',5),(970,'2024-02-24 00:00:00',4),(971,'2024-02-25 00:00:00',5),(972,'2024-02-26 00:00:00',2),(973,'2024-02-27 00:00:00',7),(974,'2024-02-28 00:00:00',1),(975,'2024-02-29 00:00:00',11),(976,'2024-03-01 00:00:00',6),(977,'2024-03-02 00:00:00',5),(978,'2024-03-03 00:00:00',4),(979,'2024-03-04 00:00:00',4),(980,'2024-03-05 00:00:00',3),(981,'2024-03-06 00:00:00',8),(982,'2024-03-07 00:00:00',2),(983,'2024-03-08 00:00:00',8),(984,'2024-03-09 00:00:00',6),(985,'2024-03-10 00:00:00',1),(986,'2024-03-11 00:00:00',3),(987,'2024-03-12 00:00:00',5),(988,'2024-03-13 00:00:00',4),(989,'2024-03-14 00:00:00',8),(990,'2024-03-15 00:00:00',5),(991,'2024-03-16 00:00:00',3),(992,'2024-03-17 00:00:00',4),(993,'2024-03-18 00:00:00',7),(994,'2024-03-19 00:00:00',6),(995,'2024-03-20 00:00:00',8),(996,'2024-08-21 00:00:14',1);
/*!40000 ALTER TABLE `tb_unique_view` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(128) DEFAULT NULL,
  `password` varchar(100) DEFAULT NULL,
  `login_type` tinyint(1) DEFAULT NULL,
  `ip_address` varchar(50) DEFAULT NULL,
  `ip_source` varchar(50) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `last_login_time` datetime DEFAULT NULL,
  `nickname` varchar(128) NOT NULL COMMENT '昵称',
  `avatar` varchar(128) DEFAULT NULL COMMENT '头像',
  `intro` varchar(64) DEFAULT NULL COMMENT '个人简介',
  `web_site` varchar(32) DEFAULT NULL COMMENT '个人网站',
  `is_disable` tinyint(1) DEFAULT '0' COMMENT '是否禁用',
  `email` varchar(16) DEFAULT NULL COMMENT '邮箱',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'icatw','$2a$10$fv.QEsjlOZuA5WRX7IQnL.LpfWNCCyrbfGyG7dZWx3TlKiUE54WCm',1,'127.0.0.1','未知','2021-08-12 15:43:18','2024-04-23 18:00:37','2024-08-17 01:48:03','icatw','https://foruda.gitee.com/avatar/1677199917990540845/10142330_icatw_1646491228.png','这个人很懒，什么都没有留下...','http://www.icatw.top',0,NULL),(9,'10142330',NULL,4,'172.20.112.1','本地局域网','2024-04-16 20:46:36','2024-04-24 10:55:36','2024-04-24 10:55:36','icatw','https://foruda.gitee.com/avatar/1677199917990540845/10142330_icatw_1646491228.png',NULL,NULL,0,NULL),(10,'99238504',NULL,5,'172.24.160.1','本地局域网','2024-04-16 21:32:40','2024-04-16 21:32:40','2024-04-17 08:19:56','Wang Shun','https://avatars.githubusercontent.com/u/99238504?v=4',NULL,NULL,0,NULL),(11,'762188827@qq.com','$2a$10$9eJtLnlhqRMr8PSffBVMU.y00S8me45Y9dLq6p54vcUL/M8tlknwO',1,'127.0.0.1','未知','2024-08-15 20:39:40','2024-08-15 20:39:43','2024-08-15 20:39:43','用户1824063403437514753','http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/2cd793c8744199053323546875655f32.jpg',NULL,NULL,0,'762188827@qq.com');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL COMMENT '用户id',
  `role_id` int DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1028 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1001,1,1),(1002,1005,2),(1004,1007,2),(1005,1008,2),(1006,1009,2),(1007,1010,2),(1008,1011,2),(1009,1012,2),(1010,1013,2),(1011,1014,2),(1012,1015,2),(1013,1016,2),(1014,1017,2),(1015,1018,2),(1016,1006,2),(1017,1006,15),(1018,2,2),(1019,3,2),(1020,4,2),(1021,5,2),(1022,6,2),(1023,7,2),(1024,8,2),(1025,9,2),(1026,10,2),(1027,11,2);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_website_config`
--

DROP TABLE IF EXISTS `tb_website_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_website_config` (
  `id` int NOT NULL AUTO_INCREMENT,
  `config` longtext COMMENT '配置信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_website_config`
--

LOCK TABLES `tb_website_config` WRITE;
/*!40000 ALTER TABLE `tb_website_config` DISABLE KEYS */;
INSERT INTO `tb_website_config` VALUES (1,'{\"alipayQRCode\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/2f2524e9d7c36be2dea375c2ba44a589.jpg\",\"gitee\":\"https://gitee.com/icatw\",\"github\":\"https://github.com/icatw\",\"isChatRoom\":1,\"isCommentReview\":0,\"isEmailNotice\":1,\"isMessageReview\":0,\"isMusicPlayer\":0,\"isRandomCover\":1,\"isReward\":1,\"isSensitiveWordFilter\":1,\"qq\":\"762188827\",\"socialLoginList\":[\"gitee\",\"github\"],\"socialUrlList\":[\"qq\",\"github\",\"gitee\"],\"touristAvatar\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/0bca52afdb2b9998132355d716390c9f.png\",\"userAvatar\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/2cd793c8744199053323546875655f32.jpg\",\"websiteAuthor\":\"鹿满川\",\"websiteAvatar\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/dde3c71e642f112140ce6ec3797bbf27.jpg\",\"websiteCreateTime\":\"2022-02-19\",\"websiteIntro\":\"一个博客网\",\"websiteName\":\"icatwのblog\",\"websiteNotice\":\"做自己想做的\",\"websiteRecordNo\":\"湘ICP备2021018757号-1\",\"websocketUrl\":\"ws://www.ws.icatw.top\",\"weiXinQRCode\":\"http://icatw-blog.oss-cn-beijing.aliyuncs.com/config/759a3e637444d32e509683f69d2aaa21.jpg\"}','2021-08-09 19:37:30','2024-04-19 20:42:03');
/*!40000 ALTER TABLE `tb_website_config` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-08-23  0:38:50
